第4章 串
    串计算机上的非数值处理的对象基本上是字符串数据。在较早的程序设计语言中，字符串是作为输入和输出的常量出现的。随着语言加工程序的发展，产生了字符串处理。这样，字符串也就作为一种变量类型出现在越来越多的程序设计语言中，同时也产生了一系列字符串的操作。字符串一般简称为串。在汇编和语言的编译程序中，源程序和目标程序都是字符串数据。在事务处理程序中，顾客的姓名和地址以及货物的名称、产地和规格等一般也是作为字符串处理的。又如信息检索系统、文字编辑程序、问答系统、自然语言翻译系统以及音乐分析程序、等等，都是以字符串数据作为处理对象的。
    然而，现今我们使用的计算机的硬件结构主要是反映数值计算的需要的，因此，在处理字符串数据时比处理整数和浮点数要复杂得多。而且，在不同类型的应用中，所处理的字符串具有不同的特点，要有效地实现字符串的处理，就必须根据具体情况使用合适的存储结构。这一章，我们将讨论一些基本的串处理操作和几种不同的存储结构。
4．1  串类型的定义
    串(string)(或字符串)，是由零个或多个字符组成的有限序列。一般记为    s=’。1“2…n。’    (n≥0)    (4．1)
其中，s是串的名，用单引号括起来的字符序列是串的值；ai(1≤i≤n)可以是字母、数字或其它字符；串中字符的数目n称为串的长度。零个字符的串称为空串(Null string)，它的长度为零。
    串中任意个连续的字符组成的子序列称为该串的子串。包含子串的串相应地称为主串。通常称字符在序列中的序号为该字符在串中的位置。子串在主串中的位置则以子串的第一个字符在主串中的位置来表示。
    例如，假设口、6、“d为如下的四个串    a=’BEI’    ，  6=’JING’
    f=’BEIJING’，  d=’．BEI J．ING’
则它们的长度分别为3、4、7和8；并且a和b都是c和d的子串，n在c和d中的位置都是1，而6在c中的位置是4，在d中的位置则是5。
    称两个串是相等的，当且仅当这两个串的值相等。也就是说，只有当两个串的长度相等，并且各个对应位置的字符都相等时才相等。例如上例中的串a、6、c和d彼此都不相等。
    值得一提的是，串值必须用一对单引号括起来，但单引号本身不属于串，它的作用只是为了避免与变量名或数的常量混淆而已。
  例如在程序设计语言中    x=’123’：则表明x是一个串变量名，赋给它的值是字符序列123。又如  tsing=’T"SING’中，tsm’g是一个串变量名，而字符序列TSING是其值。
　　在各种应用中，空格常常是串的字符集合中的一个元素，因而可以出现在其它字符中间。由一个或多个空格组成的串～称为空格串(bIank string，请注意：此处不是空串)。它的长度为串中空格字符的个数。为了清楚起见，以后我们用符号“黟”来表示“空串”。
　　串的逻辑结构和线性表极为相似，区别仅在于串的数据对象约束为字符集。然而，串的基本操作和线性表有很大差别。在线性表的基本操作中，大多以“单个元素”作为操作对象，如：在线性表中查找某个元素、求取某个元素、在某个位置上插入一个元素和删除一个元素等；而在串的基本操作中，通常以“串的整体”作为操作对象，如：在串中查找某个子串、求取一个子串、在串的某个位置上插入一个子串以及删除一个子串等。
　　串的抽象数据类型的定义如下：  ，
ADT String l
    数据对象：D={ai}ai∈CharacterSet，i=1，2，…，n，n≥O}
    数据关系：R1={<ai―1．aj>l ai一1，ai∈D。i=2，．．．，n}
    基本操作：
    Str~ssign(＆T，chars)
    初始条件：chars是字符串常量。
    操作结果：生成一个其值等于chars的串T。
    strCopy(&T，s)
  初始条件：串s存在。
  操作结果：由串s复制得串T。
    StrEmpty(s)
    初始条件：串s存在。
    操作结果：若s为空串，则返回TRUE，否则返回FALSE。
    StrCoapare(s，T)    。
  初始条件：串s和T存在。
  操作结果：若s>T，则返回值>0；若s=．T，则返回值=0；若s<T，贝Ⅱ返回值<0。
    StrUmgth(s)
    初始条件：串s存在。
    操作结果：返回s的元素个数，称为串的长度。
    ClearString(＆S)
    初始条件：串s存在。
    操作结果：将s清为空串。
    Concat(&T，sl，s2)
    初始条件：串sl和S2存在。
    操作结果：用T返回由s1和s2联接而成的新串。
    SubS~ing(＆sub，s，pos，len)
    初始条件：串s存在，1≤pos≤StrLength(s)且O≤len≤StrLength(s)-pos+1。
    操作结果：用Sub返回串s的第pos个字符起长度为len的子串。
    Index(S，T，pos)
    初始条件：串s和T存在，T是非空串，1≤pos≤Strl,ength(s)。
    操作结果：若主串s中存在和串T值相同的子串，则返回它在主串s中第pos个字符之后第一次出现的位置；否则函数值为0。
    Replace(&s，T，V)
    初始条件：串S，T和v存在，T是非空串。
    操作结果：用v替换主串S中出现的所有与T相等的不重叠的子串。
    StrInsert(&S，pos，T)
    初始条件：串S和T存在，1≤pos≤StrLength(S)+l。
    操作结果：在串S的第pos个字符之前插入串T。
    StrDelete(&S，pos，len)
    初始条件：串S存在，1≤pos≤StrLength(S)一len十1。
    操作结果：从串S中删除第pos个字符起长度为len的子串。
    DestroyStrlng(as)
    初始条件：串S存在。
    操作结果：串S被销毁。
    IADT String
    对于串的基本操作集可以有不同的定义方法，读者在使用高级程序设计语言中的串类型时，应以该语言的参考手册为准。在上述抽象数据类型定义的13种操作中，串赋值StrAssign、串比较StrCompare、求串长StrLength、串联接Concat以及求子串SubString等五种操作构成串类型的最小操作子集。即：这些操作不可能利用其他串操作来实现，反之，其他串操作(除串清除ClearString和串销毁DestroyString外)均可在这个最小操作子集上实现。
    例如，可利用判等、求串长和求子串等操作实现定位函数Index(S，T，pos)。算法的基本思想为：在主串s中取从第i(i的初值为pos)个字符起、长度和串T相等的子串和串T比较，若相等，则求得函数值为i，否则i值增1直至串s中不存在和串T相等的子串为止。如算法4．1所示。
int Index(String S，String T，int pos)l
  ∥T为非空串。若主串S中第pos个字符之后存在与T相等的子串
  ∥则返回第一个这样的子串在S中的位置，否则返回0
  if(pos>O){
  n=StrLength(S)；m=StrLength(T)；  i=pos；
  while(i<=n―m+1){
    SubString(sub，S，i，m)；
    if(StrCompare(sub，T)!=0)    十+i；
    else return i；    ∥返回子串在主串中的位置
    }∥while
  }∥if
  return 0；    ∥S中不存在与T相等的子串
＼f}Index
算法4．1
4．2  串的表示和实现
如果在程序设计语言中，串只是作为输入或输出的常量出现，则只需存储此串的串值，即字符序列即可。但在多数非数值处理的程序中，串也以变量的形式出现。
    串有三种机内表示方法，分别介绍如下。
    4．2．1定长顺序存储表示
    类似于线性表的顺序存储结构，用一组地址连续的存储单元存储串值的字符序列。在串的定长顺序存储结构中，按照予定义的大小，为每个定义的串变量分配一个固定长度的存储区，则可用定长数组如下描述之。
    ∥…串的定长顺序存储表示～
    #defi．e MAXSTRLEN 255    ∥用户可在255以内定义最大串长
    thief  unsigned char SStr’ing[MAXSTRLEN+1]；    ∥O号单元存放串的长度
串的实际长度可在这予定义长度的范围内随意，超过予定义长度的串值则被舍去，称之为“截断”。对串长有两种表示方法：一是如上述定义描述的那样，以下标为0的数组分量存放串的实际长度，如PAS(：AL语言中的串类型采用这种表示方法；二是在串值后面加一个不计入串长的结束标记字符，如在有的C语言中以“＼0”表示串值的终结。此时的串长为隐含值，显然不便于进行某些串操作。
    在这种存储结构表示时如何实现串的操作，下面以串联接和求子串为例讨论之。    1．串联接Concat(&T，S1，S2)
    假设S1、S2和T都是SString型的串变量，且串T是由串S1联结串s2得到的，即串T的值的前一段和串s1的值相等，串T的值的后一段和串S2的值相等，则只要进行相应的“串值复制”操作即可，只是需按前述约定，对超长部分实施“截断”操作。基于串s1和s2长度的不同情况，串T值的产生可能有如下三种情况：1)s1[0]+S2[0]≤MAXS'TRLEN，如图4．10(a)所示，得到的串T是正确的结果；2)S1[0]<MAXSTRLEN而s1[0]+s2[0]>MAXSTRLEN，则将串S2的一部分截断，得到的串T只包含串s2的一个子串，如图4．1(b)所示；3)S1[O]=MAXS'TRL,EN，则得到的串T并非联接结果，而和串s1相等。上述算法描述如算法4．2所示。
    Status Concat(SString＆T，SString s1，SString s2)I
    ∥用T返回由sl和S2联接而成的新串。若未截断，则返回，TRUE，否则FALSE。    if(sl[0]+s2[0]<=MAXSTRLEN){    ∥未截断
    T[1．．sl[0]]=s1[1．．s1[O]]；
    T[sl[0]+1．．s1[0]+s2[0]]：s2[1．．s2[0]]；
    T[O]：s1[0]+S2[：O]；uncut=TRI；E；
    }   
    else if(s1[0]<MAXSTRSlZE){    ∥截断
    T[1．．s1[O]]=s1[1．．s1[O]]；
    T[s1[0]+1．．MAXSTRLEN]=s2[1．．MAXSTRLEN―sl[0]]；
    ’r[0]=MAXSTRLEN；1mcut=FAI~；
    }
    else{    ∥截断(仅取s1)
    T[0．．MAXSTRLEN]=s1[0．．MAXSTRLEN]；
    ∥T[0]==s1[0]==MAXSTRLF~
    1mcut=FALSE；
   }
    returll uncut
}f Concat
S1
算法4．2
图4．1  串的联结操作Concat(T，S1，S2)示意图
  (a)S1[0]+S2[0]≤MAXSTRLEN；
  (b)S1[0]<MAXSTRLEN而S1[0】+SZ[0]>MAXSTRLEN
  (c)S1[0]=MAXSTRLEN
  2．求子串SubString(&Sub，S，pos，len)
  求子串的过程即为复制字符序列的过程，将串s中从第pos个字符开始长度为1en的字符序列复制到串Sub中。显然，本操作不会有需截断的情况，但有可能产生用户给出的参数不符合操作的初始条件，当参数非法时，返回ERROR。其算法描述如算法4．3所示。
Status SubStr’ing(SString&Sub．SStri‘ng s，int pos，int len){
    ∥用Sub返回串s的第pos个字符起长度为len的子串。
    ∥其中，l pos~StrLength(s)且0≤len~StrLength(s)-pos+1。
    if(pos<l lI pos>s[0]ll len<0 lI len>s[0]-pos+1)
    return ERROR；
    sub[1．．1eTl]=s[pos．．pos+len一1]；    ’
    Sub[0 3=len；  return OK；
}∥SubString
算法4．3
    综上两个操作可见，在顺序存储结构中，实现串操作的原操作为“字符序列的复制”，操作的时间复杂度基于复制的字符序列的长度。另一操作特点是，如果在操作中出现串值序列的长度超过上界MAXSTRl．EN时，约定用截尾法处理，这种情况不仅在求联接串时可能发生，在串的其它操作中，如插入、置换等也可能发生。克服这个弊病唯有不限定串长的最大长度，即动态分配串值的存储空间。
4．2．2堆分配存储表示
    这种存储表示的特点是，仍以一组地址连续的存储单元存放串值字符序列，但它们的存储空间是在程序执行过程中动态分配而得。在c语言中，存在一个称之为“堆”的自由存储区，并由c语言的动态分配函数malloc()和free()来管理。利用函数maltoc()为每个新产生的串分配一块实际串长所需的存储空间，若分配成功，则返回一个指向起始地址的指针，作为串的基址，同时，为了以后处理方便，约定串长也作为存储结构的一部分。
    ∥串的堆分配存储表示
  tst~aet{
    char  *ch；    ∥若是非空串，则按串长分配存储区，否则ch为NULL
    int length；    ∥串长度
    l HString；
这种存储结构表示时的串操作仍是基于“字符序列的复制”进行的。例如，串复制操作str(bpy(&T，s)的实现算法是，若串T已存在，则先释放串T所占空间，当串s不空时，先为串T分配大小和串S长度相等的存储空间，然后将串S的值复制到串T中；又如串插入操作StrInsert(&S，pos，T)的实现算法是，为串s重新分配大小等于串s和串T长度之和的存储空间，然后进行串值复制，如算法4．4所示。
Status strInsert(HString＆s，int pos，HString T){
    ∥1≤pos≤strLength(s)+1。在串s的第pos个字符之前插入串T。
    if(pos<1 lI pos>s．1ength+1)return ERROR；  ∥pos不合法
    if(T．1ength){    ∥T非空，则重新分配空间，插入T
    if(!(s．ch=(char*)realloc(s．ch，(s．1ength+T．1ength)*siz~f(char))))
    exit(OVERFLOw)；
    for(i=s．1ength【一1；i>=pos一1；--i)  ∥为插入T而腾出位置
    s ch【i+T．1ength_]=s．ch[i]；
    s．ch[pos-1．．pos+T．1ength-2]=T．ch[0．．T．1ength-1]；∥插入T
        S．1ength+=T．1ength：
    }
    return OK{
}／／Strlnsert
    算法4．4
    以上两种存储表示通常为高级程序设计语言所采用。由于堆分配存储结构的串既有顺序存储结构的特点，处理方便，操作中对串长又没有任何限制，更显灵活，因此在串处理的应用程序中也常被选用。以下所示为只含最小操作子集的HString串类型的模块说明。
    ／／…==ADT String的表示与实现=：===
    ∥串的堆分配存储表示…
    typedef struct{
    d  *ch；    ／／若是非空串，则按串长分配存储区，否则ch为NULL
    int length；  ／／串长度
    }HString；
∥基本操作的函数原型说明
Status StrAsslgn(HString＆T，char*chars)；
    ∥生成一个其值等于串常量chars的串T
int StrLength(HString S)；
    ∥返回S的元素个数，称为串的长度。
Ant StrCompare(HString S。HString T，
    ∥若S>T，则返回值>O；若S=T，则返回值=O；若S<T，则返回值<0
Status ClearString(HString＆S)；
    ∥将s清为空串，并释放S所占空间。
Status Concat(}{String&T，HString s1，HString S2)；
    ∥用T返回由s1和S2联接而成的新串。
HString SubString(HString S，int pos，int len)；
    ／／1≤pos~<StrLength(S)且0≤len≤strLength(S)一poi+1。
    ∥返回串S的第pos个字符起长度为len的子串。
    ∥基本操作的算法描述…
Status StrAssign(HString＆T，char*chars)l
    ∥生成一个其值等于串常量chars的串T
    if(T．ch)free(T．ch)；    ／／释放T原有空间
    for(i：0，C=chars；  c；  ++i，++c)；  ／／求chars的长度i
    if(!i){T．ch=IqULL；T．1ength=0；}
    else{
    if(!(T．ch；(cllar*)帕lla_c(i*sizeof(char))))
    exit(OVERFLOW)；
    T．ch[0．．i一1]=chars[0．．i一1]；
    T．1ength=i；
    }
    return OK；
・  76  ・
＼jI StrAssign
int StrLength(HString S){
    ∥返回S的元素个数，称为串J的长度。
    return S．1ength；
＼{f StrLength
int StrCompare(HString S，HString T){’
    ∥若S>T，则返回值>O；若S=T，则返回值：0；若S<T，则返回值<0
    for(i：0；i<S．1ength&&i<T．1ength；++i)
    if(s．ch[i]!=T．ch[i])return S．ch[1]一T．ch[i]；
    return S．1ength-T．1~ngth；
}／／StrCompare
Status ClearString(HString&s){
    ∥将S清为空串。
    if(S．ch)  lfree(S．oh)；  S．ch=NULL；
    S．1ength=0；
    return OK；
、ii ClearString
Status Concat(HStrinq＆T，HString S1，HString S2){
    ∥用T返回由s1和s2联接而成的新串。
    if(T．ch)free(T．ch)；    ／／释放旧空间
    if(!(T．ch=(char*)malloc((S1．1ength+S2．1ength)*sizeof(char))))
    exit(OVERFLO．)；
  T．ch[0．．S1．1ength一1]=S1．ch[0．．S1．1ength一1]；
  T．1ength=S1．1ength+S2．1ength；
  T．ch[S1．1ength．．T．1ength一1]=s2．ch[0．．S2．1ength～1]；
  returnOK；
  }／／Concat
Status SubString(HString&Sub，HString S，int pos，int fen){
    ∥用Sub返回串S的第pos个字符起长度为fen的子串。
    ∥其中，1≤pos≤StrLength(S)且0≤len≤StrLength(S)一pos+1。
    if(pos<1 l】pos>S．1ength ll len<0}I len>s．1ength―pos+1)
    return E~ROR；
  if(Sub．ch)free(Sub．ch)；
  if(!len){Sub．ch：NULL；Sub．1ength=0；}
  else{
    Sub．ch=(char*)mallo~(1en*sizeof(char))；
    Sub．ch[0．．1en-1]=S[pos-i．．pos+len-2]；
    Sub．1ength=lea；
    I
    return OK；
＼f}SubString
∥释放旧空间
∥空子串
∥完整子串
77・
  4．2．3串的块链存储表示
  和线性表的链式存储结构相类似，也可采用链表方式存储串值。由于串结构的特殊性--结构中的每个数据元素是一个字符，则用链表存储串值时，存在一个“结点大小”的问题，即每个结点可以存放一个字符，也可以存放多个字符。例如，图4．2(a)是结点大小为4(即每个结点存放四个字符)的链表，图4．2(b)是结点大小为1的链表。当结点大小大于1时．由于串长不一定是结点大小的整倍数，则链表中的最后一个结点不一定全被串值占满，此时通常补上“#”或其它的非串值字符(通常“#”不属于串的字符集，是一个特殊的符号)。
head
(a)
head
    (b)
    图4．2串值的链表存储方式
(a)结点大小为4的链表；  (b)结点大小为l的链表。
    为了便于进行串的操作，当以链表存储串值时，除头指针外还可附设一个尾指针指示链表中的最后一个结点，并给出当前串的长度。称如此定义的串存储结构为块链结构．说明如下：
    ∥：==串的块链存储表示：=…=
    #define CHUNKSIZE 80    ∥可由用户定义的块大小
    tyP|def struct Chunk{
    char  ch[c【zE]；
    8truct Chunk*next：
    }Chunk；
    typed~struct{
    Chunk*．head，*tall；    ∥串的头和尾指针
    int  curlen；    ∥串的当前长度
    }LString；
    由于在一般情况下，对串进行操作时，只需要从头向尾顺序扫描即可，贝t!对串值不必建立双向链表。设尾指针的目的是为了便于进行联结操作，但应注意联结时需处理第一个串尾的无效字符。
    在链式存储方式中，结点大小的选择和顺序存储方式的格式选择一样都很重要，它直接影响着串处理的效率。在各种串的处理系统中，所处理的串往往很长或很多。例如，一本书的几百万个字符，情报资料的成千上万个条目。这要求我们考虑串值的存储密度。
存储密度可定义为
    存储密度：
    显然，存储密度小(如结点大小为1时)，运算处理方便，然而，存储占用量大。如果在串处理过程中需进行内、外存交换的话，则会因为内外存交换操作过多而影响处理的总效率。应该看到，串的字符集的大小也是一个重要因素。一般地，字符集小，则字符的机内编码就短，这也影响串值的存储方式的选取。
    串值的链式存储结构对某些串操作，如联接操作等有一定方便之处，但总的说来不如另外两种存储结构灵活，它占用存储量大且操作复杂。此外，串值在链式存储结构时串操作的实现和线性表在链表存储结构中的操作类似，故在此不作详细讨论。
    4．3  串的模式匹配算法    
    4．3．1求子串位置的定位函数Index(s。T。pos)
    子串的定位操作通常称作串的模式匹配(其中T被称为模式串)。是各种串处理系统中最重要的操作之一。在4．1节中曾借用串的其他基本操作给出了定位函数的一种算法。根据算法4．1的基本思想，采用定长顺序存储结构，可以写出不依赖于其他串操作的匹配算法，如算法4．5所示。
int Index(SString s，SString T，int pos){    
    ∥返回子串T在主串s中第pos个字符之后的位置。若不存在，则函数值为0。
    ∥其中，T非空，1≤pos≤strLength(s)。
    i=pos；    j=1；
    while(1<=sE0]&&j<=T[O]){
    if(s[i]=T[j]){++i；    ++j；}  ∥继续比较后继字符
    ele{i=i―j+2；    j=1；l    ∥指针后退重新开始匹配
    }
    if(j>T[0])return 1-T[0]；
    else return 0：
}∥Index
算法4．5
    在算法4．5的函数过程中，分别利用计数指针i和j指示主串S和模式串T中当前正待比较的字符位置。算法的基本思想是：从主串s的第pos个字符起和模式的第一个字符比较之，若相等，则继续逐个比较后续字符，否则从主串的下一个字符起再重新和模式的字符比较之。依次类推，直至模式T中的每个字符依次和主串S中的一个连续的字符序列相等，则称匹配成功。函数值为和模式T中第一个字符相等的字符在主串s中的序号，否则称匹配不成功，函数值为零。图4．3展示了模式T=’abcac・’和主串S的匹配过程(pos=1)。
    算法4．5的匹配过程易於理解，且在某些应用场合，如文本编辑等，效率也较高，例如，在检查模式’sTING’是否存在於下列主串中时，
    ’A STRING SEARCFIING EXAMPI。E C()NSIS'TING OF SIMPI，E TEXT’
上述算法中的Wt_IILE循环次数(即进行单个字符比较的次数)为41，恰好为(Index+T[0]一1)+4这就是说，除了主串中呈黑体的四个字符，每个字符比较了两次以外，其它字符均只和模式进行一次比较。在这种情况下，此算法的时间复杂度为0(n+m)。其中n和m分别为主串和模式的长度。然而，在有些情况下，该算法的效率却很低。例如，当模式串为“0000000 1’，而主串为’000000000000000000000000000    。“cJ：，0000000000000000000000000l’时，由于模式中前7个字符均为“0”，每趟比较都在模式的最后一个字符出现不等，此时需将指针i回溯到i一6的位置上，并从模式的第一个字符开始重新比较，整个匹配过程中指针i需回溯45次，则 wHILE循环次数为46*8(index*m)。可见，算法4．  在最坏情况下的时间复杂度为0(n*m)。这种情况在只有0、1两种字符的文本串处理中经常出现，因为在主串中可能存在多个和模式串“部分匹配”的子串，因而引起指针i的多次回溯。01串可以用在许多应用之中。比如，一些计算机的图形显示就是把画面表示为一个01串，一页书就是一个几百万个0和l组成的串。在二进位计算机上实际处理的都是01串。一个字符的．ASCII码也可以看成是八个二进位的01串。包括汉字存储在计算机中处理时也是作为一个01串和其它的字符串一样看待。因此在下一节，我们将介绍另一种较好的模式匹配算法。    
4．3．2模式匹配的一种改进算法
    这种改进算法是D．E．Knuth与V．R．Pratt和J．H．Morris同时发现的，因此人们称它为克努特一莫里斯一普拉特操作(简称为KMP算法)。此算法可以在0(n+m)的时第一趟匹配a b    a  b
第二趟匹配a b
‘i=3
a  b  c  a  b  c
C
+j=3
●i一0i=
a  b  c  a  b  c
    a  b  C  a  c
    +-+-j=5
    j=1+i一0i：11
第三趟匹配a b a b c a b c a c b a b
    (a)b  c  a  c
    j=6
    j=2
图4．4改进算法的匹配过程示例
间数量级上完成串的模式匹配操作。其改进在於：每当一趟匹配过程中出现字符比较不等时，不需回溯i指针，而是利用已经得到的“部分匹配”的结果将模式向右“滑动”尽可能远的一段距离后，继续进行比较。下面先从具体例子看起。
    回顾图4．3中的匹配过程示例，在第三趟的匹配中，当i=7、．j=5字符比较不等时，又从净4、．j=1重新开始比较。然后，经仔细观察可发现，在i=4和j=1，卢5和j=l以及i=6和J=1这三次比较都是不必进行的。因为从第三趟部分匹配的结果就可得出，主串中第4、5和6个字符必然是‘b’、‘c’和‘a’(即模式串中第2、3和4个字符)。因为模式中的第一个字符是n，因此它无需再和这三个字符进行比较，而仅需将模式向右滑动三个字符的位置继续进行i=7、j=2时的字符比较即可。同理，在第一趟匹配中出现字符不等时，仅需将模式向右移动二个字符的位置继续进行i=3、J=1时的字符比较。由此，在整个匹配的过程中，i指针没有回溯，如图4．4所示。
　　现在讨论一般情况。假设主串为01 s2…s。’，模式串为’12…p。’，从上例的分析可知，为了实现改进算法，需要解决下述问题：当匹配过程中产生“失配”(即si≠pi)时，模式串“向右滑动”可行的距离多远，换句话说，当主串中第i个字符与模式中第歹个字符“失配”(即比较不等)时，主串中第i字符(i指针不回溯)应与模式中哪个字符再比较?
　　假设此时应与模式中第k(k<j)个字符继续比较，则模式中前k一1个字符的子串必须满足下列关系式(4―2)，且不可能存在k’>k满足下列关系式(4．2)    ’1p2…p^一1’：’^+1 si+2…一1’    (4―2)
而已经得到的“部分匹配”的结果是 ’～^+1^+2…1’=’^+1 si一^+2…5i一1’  (4―3)
由(4．2)和(4―3)推得下列等式  ■12…A1’=一^+1^+2…一1’    (4―4)
反之，若模式串中存在满足式(4．4)的两个子串，则当匹配过程中，主串中第i个字符与模式中第歹个字符比较不等时，仅需将模式向右滑动至模式中第忌个字符和主串中第i个字符对齐，此时，模式中头k-1个字符的子串’12…A一1’必定与主串中第i个字符之前长度为k-1的子串’s，^+1&。+2…s；1。相等，由此，匹配仅需从模式中第k个字符与主串中第i个字符比较起继续进行。
    若令nex￡[j]=，则n￡[j]表明当模式中第j个字符与主串中相应字符“失配”时，在模式中需重新和主串中该字符进行比较的字符的位置。由此可引出模式串的nex￡函数的定义：
    f0    当=1时
    next…：l Max-{kI’<k<j"l’。■Ⅲl…l’}    (4―51
    nem【’J。1    当此集合不空时    “。。“‘    (4―5)
    11    其它情况
由此定义可推出下列模式串的next函数值：在求得模式的next函数之后，匹配可如下进行：假设以指针i和j分别指示主串和模式中正待比较的字符，令i的初值为pos，j的初值为1。若在匹配过程中si=pj，则i和j分别增1，否则，i不变，而j退到n￡[J]的位置再比较，若相等，则指针各自增1，否则j再退到下一个”的位置，依次类推，直至下列两种可能：一种是j退到某个next值时字符比较相等，则指针各自增1继续进行匹配；另一种是j退到值为零(即模式的第一个字符“失配”)，则此时需将模式继续向右滑动一个位置。即从主串的下一个字符si+，起和模式重新开始匹配。图4．5所示正是上述匹配过程的一个例子。
    KMP算法如算法4．6所示，它在形式上和算法4．5极为相似。不同之处仅在於：当
匹配过程中产生“失配”时，指针i不变，指针J退回到next[j]所指示的位置上重新进行比较，并且当指针j退至零时，指针i和指针j需同时增1。即若主串的第i个字符和模式的第1个字符不等，应从主串的第i+1个字符起重新进行匹配。
int Index一硒但(SString S，SString T，in％pos){
    ∥利用模式串T的next函数求T在主串S中第pos个字符之后的位置的
    //KMP算法。其中，T非空，1≤pos≤StrLength(S)。
    i z pos；    J=1；
    ．hile(i<=S[0]&＆J<=T[0]){
    if(J：0 lj s[i]=T[J]){++i；  ++J；}    ∥继续比较后继字符
    else J=next[j]；    ／／模式串向右移动
    }
    if(J>T[0])return i―T[0]
    else return 0；
＼?f Index―KMP
算法4．6
∥匹配成功
    KMP算法是在已知模式串的next函数值的基础上执行的，那么，如何求得模式串的next函数值呢?
    从上述讨论可见，此函数值仅取决于模式串本身而和相匹配的主串无关。我们可从分析其定义出发用递推的方法求得next函数值。
  由定义得知    
    nex[[1]=0    (4―6)
设n~xt[j]=k，这表明在模式串中存在下列关系：
    ≯1…Pl一1’=’岛一^+1…户卜1    (4．7)
其中k为满足l<k<J的某个值，并且不可能存在k’>k满足等式(4―7)。此时next[j+1]=?可能有两种情况：
    (1)若m：p，，则表明在模式串中
    ’p1…p＆’=’夕，一t+1…p}’    (4―8)
并且不可能存在忌’>是满足等式(4―8)，这就是说next[j+1]=k+1，即
next[j+1]：next[j]+1    (4―9)
    (2)若仇≠p，，则表明在模式串中
    ‘pl…p E‘≠‘p卜k+l…pij
此时可把求next函数值的问题看成是一个模式匹配的问题，整个模式串既是主串又是模式串，而当前在匹配的过程中，已有p卜E+1=乡1，p，一^+2=p2，…，1=m一1，则当岛≠以时应将模式向右滑动至以模式中的第next[k]个字符和主串中的第j个字符相比较。若next[k]=k’，且户，=仇，，则说明在主串中第j+1个字符之前存在一个长度为忌‘(即next[k])的最长子串，和模式串中从首字符起长度为是’的子串相等，即    (4―10)
这就是说next[j十1]=k’十1即
    next[j+1]：next[k]+1    (4―11)
同理，若A≠A，，则将模式继续向右滑动直至将模式中第next[k’]个字符和岛对齐，……，依次类推，直至A和模式中某个字符匹配成功或者不存在任何是’(1<足’<j)满足等式(4―10)，则    next[j+1]：1    (4―12)
例如：图4．6中的模式串，已求得前6个字符的next函数值，现求next[7]，因为next．[6]=3，又p6≠3，则需比较p6和p1(因为next[3]=1)，这相当于将子串模式向右滑动。
由于p6≠p1，而且next[1]=0，所以next[7]：1，而因为p7.
    根据上述分析所得结果(式(4-6)、(4．9)、(4-11)和    …(4．12))，仿照KMP算法，可得到求函数值的算法，如算法4．6所示。
l 2 3 4 5 6
 a b a a b c
0 1 1 2 2 3
    (a b a)
7 8
a C
1 2
  void get_next(SString T, int & next[]) 
    ∥求模式串T的函数值并存入数组
    i=1；  next[：1]=0；  j=0；
    ．hile(i<T[0]){
    if(j=0 ll T[i]=T[j])I++i；  ++j；next[i]：j；}
    e18e  j=next[j]；
    }
    }∥get―next
    算法4．7
    算法4．7的时间复杂度为O(n)。通常，模式串的长度m比主串的长度n要小得多，因此，对整个匹配算法来说，所增加的这点时间是值得的。
  最后，要说明两点：
  1)虽然算法4．5的时间复杂度是0(，z*研)，但在一般情况下，其实际的执行时间近似于0(n+m)，因此至今仍被采用。KMP算法仅当模式与主串之间存在许多“部分匹配”的情况下才显得比算法4．5快得多。但是KMP算法的最大特点是指示主串的指针不需回溯，整个匹配过程中，对主串仅需从头至尾扫描一遍，这对处理从外设输入的庞大文件很有效，可以边读入边匹配，而无需回头重读。
    2)前面定义的next函数在某些情况下尚有缺陷。例如模式’a o n n 6’在和主串’a66’匹配时，当i=4，．j=4时s．ch[4]≠t．ch[4]，由next[j]的指示还需进行4、J：3，4、J=2、i=4、j：1等三次比较。实际上，因为模式中第1、2、3个字符和第4个字符都相等，因此不需要再和主串中第4个字符相比较，而可以将模式一气向右滑动4个字符的位置直接进行5，J：1时的字符比较。这就是说，若按上述定义得到next[j]=k，而模式中pj＝pk，则当主串中字符si和pj比较不等时，不需要再和m进行比较，而直接和Pnext[k]进行比较，换句话说，此时的next[j]应和next[k]相同。由此可得计算next．函数修正值的算法如算法4．8所示。此时匹配算法不变。
void get―nextva]．(SString T，int  nextva][]){
    ∥求模式串T的ne】【t函数修正值并存入数组nextval。
    i=l；  nextva]．[1]=0；  j=0；
    while(i<T[0]){
    if(j=0 II T[i]=T[j]){
    ++i；    ++j；
    if(T[i]!=T[j])nextval[i]=j；
    e18e  ne】【tval[i]=ne)【tval[j]；
    }    
    else j=nex：tval[j]；
    }
}∥get―nextval
算法4．8
    4．4串操作应用举例
  4．4．1文本编辑
  文本编辑程序是一个面向用户的系统服务程序，广泛用于源程序的输入和修改，甚至用于报刊和书籍的编辑排版以及办公室的公文书信的起草和润色。文本编辑的实质是修改字符数据的形式或格式。虽然各种文本编辑程序的功能强弱不同，但是其基本操作是一致的，一般都包括串的查找，插入和删除等基本操作。
   为了编辑的方便，用户可以利用换页符和换行符把文本划分为若干页，每页有若干行(当然，也可不分页而把文件直接划成若干行)。我们i,TPl把文本看成是一个字符串，称为文本串。页则是文本串的子串，行又是页的子串。
　　比如有下列一段源程序
　　mai,I(){
    float a，b，max；
    8cf(”％f，％f，＆a，＆b)；
    if a>b max=a：
    elsemax。b：
    }；
我们可以把此程序看成是一个文本串。输入到内存后如图4．7所示。图中“／”为换行符。
　　为了管理文本串的页和行，在进入文本编辑的时候，编辑程序先为文本串建立相应的页表和行表，即建立各子串的存储映象。页表的每一项给出了页号和该页的起始行号。而行表的每一项则指示每一行的行号、起始地址和该行子串的长度。假设图4．7所示文本串只占一页，且起始行号为100，则该文本串的行表如图4．8所示。
　　文本编辑程序中设立页指针、行指针和字符指针，分别指示当前操作的页、行和字符。如果在某行内插入或删除若干字符，则要修改行表中该行的长度。若该行的长度超出了分配给它的存储空间，则要为该行重新分配存储空间，同时还要修改该行的起始位置。如果要插入或删除一行，就要涉及行表的插入或删除。若被删除的行是所在页的起始行，则还要修改页表中相应页的起始行号(修改为下一行的行号)。为了查找方便，行表是按行号递增顺序存储的，因此，对行表进行的插入或删除运算需移动操作位置以后的全部表项。页表的维护与行表类似，在此不再赘述。由于访问是以页表和行表作为索引的，所以在作行和页的删除操作时，可以只对行表和页表作相应的修改，不必删除所涉及的字符。这可以节省不少时间。
    以上概述了文本编辑程序中的基本操作。其具体的算法，读者可在学习本章之后自行编写。
4．4．2建立词索引表
    信息检索是计算机应用的重要领域之一。由于信息检索的主要操作是在大量的存放在磁盘上的信息中查询一个特定的信息，为了提高查询效率，一个重要的问题是建立一个好的索引系统。例如我们在1．1节中提到过的图书馆书目检索系统中有三张索引表，分别可按书名、作者名和分类号编排。在实际系统中，按书名检索并不方便，因为很多内容相似的书籍其书名不一定相同。因此较好的办法是建立“书名关键词索引”。
书号
005
010
023
034
050
067
书名
(~omputer【)ata Structures
Intr(~duction to Data Stnmtures
Fundamentals．of【)ata Structures
The【)esigrl and Analysis of C(~mputer Algorithms
Introduction to NIlmerical Analysis
Numerical Analysis
关键词    书号索引
034．
034，050，067
005，034
005，010，a23
034
023
010．050
050．067
005，010，023
。  图4．9书目文件及其关键词索引表
    (a)书目文件；  (b)关键词索引表。
    例如，与图4．9(a)中书目相应的关键词索引表如图4．9(b)所示，读者很容易从关键词索引表中查询到他所感兴趣的书目。为了便于查询，可设定此索引表为按词典有序的线性表。下面要讨论的是如何从书目文件生成这个有序词表。
    重复下列操作直至文件结束：
    1)从书目文件中读入一个书目串；
    2)从书目串中提取所有关键词插入词表；
    3)对词表中的每一个关键词，在索引表中进行查找并作相应的插入操作。
    为识别从书名串中分离出来的单词是否是关键词，需要一张常用词表(在英文书名中的“常用词”指的是诸如"all'’、“a”、“of”、“the”等词)。顺序扫描书名串，首先分离单词，然后查找常用词表，若不和表中任一词相等，则为关键词，插入临时存放关键词的词表中。
    在索引表中查询关键词时可能出现两种情况：其一是索引表上已有此关键词的索引项，则只要在该项中插入书号索引即可；其二是需在索引表中插入此关键词的索引项，插入应按字典有序原则进行。下面就重点讨论这第三个操作的具体实现。
  首先设定数据结构。
  词表为线性表，只存放一本书的书名中若干关键词，其数量有限，则采用顺序存储结构即可，其中每个词是一个字符串。
    索引表为有序表，虽是动态生成，在生成过程中需频繁进行插入操作，但考虑索引表主要为查找用，为了提高查找效率(采用第九章中将讨论的折半查找)，宜采用顺序存储结构；表中每个索引项包含两个内容：其一是关键词，因索引表为常驻结构，则应考虑节省存储，采用堆分配存储表示的串类型；其二是书号索引，由于书号索引是在索}I表的生成过程中逐个插入，且不同关键词的书号索引个数不等，甚至可能相差很多，则宜采用链表结构的线性表。
#de~Ine MaxBc。Ⅻl】1000    ∥假设只对1000本书建索引表
#defi．e MaeyN_l  2500    ／／索引表的最大容量
#di*a1neL500    ∥书目串的最大长度
#deflne Maorum 10    ∥词表的最大容量
typed6f st~c~l
  *em【]；∥字符串的数组
  int last；    ∥词表的长度
1w“、syj    ／／词表类型(顺序表)
‘yPedit ElemTyPe；∥定义链表的数据元素类型为整型(书号类型
0n“f{m1
  HString key；    ∥关键词
  Lira．List bn~list％∥存放书号索引的链表
}ITerm’yp。；    ∥索引项类型
0fP8tgt1
    IdBrmType 1t【MaxKeyN~+I J；
    i4t lastj
}Id1st’ype；    ∥索引表类型(有序表)
  ∥主要变量
ch^r*huf；    ∥书目串缓冲区
WordListType wdli~t；∥词表
  ∥基本操作
Ⅵid IoitIdxLlat(51xListT~＆idxlist)；
    ∥初始化操作，置索引表idxlist为空表．且在idxlist ie~[O]设一空串
id GetLine(FIf)；
    ∥从文件f读入一个书目信息到书目串缓冲区bur
void ExtractKe~Mord(Ele艘yPe＆bno)；
    ∥从bur中提取书名关键诃到词表wdlist。书号存入bno
S~a~usInsl4XList CIdxListT~e＆ilxllst，m￡me bno)’
    ∥将书号为bn。的书名关键词按词典顺序插入索引表idxli~t
voi4 PUtT~xt(FI％Id1stte[4xlist)；
    ∥将生成的索引表idxlist输出到文件g
void maln()f／／主函数
  if(f。opeaf f。B~okInfo txt‘
    if(g=ope，lf(”Bookl4x t~t
    InltIdx“st fj出113t)i
    while(1feof(f)){
    GetLine(f)；
∥初始化索引表i4xlist为空表
∥从文件f读入一个书目信息f
    }
＼f}main
 ExtractKeyWord(BookNo)；
InsldxList(idxlist，BookNo)；
}
PutText(g，idxlist)；
∥从buf提取关键词到词表，书号存入BookNo
∥将书号为BookNo的关键词插入索引表
∥将生成的索引表idxlist输出到文件g
算法4．9
为实现在索引表上进行插入，要先实现下列操作：
void GetWord(int i，[-']String＆wd)；    ．
    ∥用wd返回词表wdlist中第i个关键词。
int Locate(IdxListType idxlist，  }{String wd，  Boolean＆b)；
    ∥在索引表idxlist中查询是否存在与wd相等的关键词。若存在，则返回其在索引表
    ∥中的位置，且b取值TRUE；否则返回插入位置，且b取值FALSE
void InsertNewKey(IdxListType＆idxlist，  int i，HString wd)0
    ∥在索引表idxlist的第i项上插入新关键词wd，并初始化书号索引的链表为空表
Status InsertBook(IdxListType＆idxlist，  int i，  int bno)；
    ∥在索引表idxlist的第i项中插入书号为bno的索引
由此可得索引表的插入算法如算法4．10所示。
Status InsertldxList(IdxListType&idxlist，  int bno){
    for(i=0；  i<wdlist．1ast；  ++i){
    GetWord(i，wd)；    J=Locate(idxlist，wd，b)；
    if(!b)InsertNewKey(idxlist，J，wd)；    ∥插入新的索引项
    return(InsertBook(ic~list，J，bno))；    ∥  插入书号索引
    }
＼}}InsertIdxList
算法4．10
其中四个操作的具体实现分别如算法4．11，4．12，4．13和4．14所示。
void GetWord(int i，HString&wd){
  P=*(wdlist．item十i)；    ／／取词表中第i个字符串
  StrAssign(wd，P)；    ／／生成关键字字符串
I／／GetWord
算法4．II
int Locate(IdxListType＆idxlist，HString wd，Boolea．＆b){
    for(i=idxlist．1ast一1；
    (m=StrCompare(idxlist．item[i]．key，wd))>0；  --i)；
    if(m==0)  {b=TRUE；  return i；  }    ∥找到
    else lb=FALSE；    return i+1；  }
＼f}Locate
算法4．12
 void InsertNewKey(int i，  strType wd){
  for(J=idxlist．1ast―l；  J>=i；  --J)
    idxlist．item[J+1]=idxlist．item[J]；
  ∥插入新的索引项
  StrCopy(idxlist．item[i]．key，wd)；
  InitList(idxlist．item[i]．bnolist)；
  ++idxlist．1ast：
＼}f Inse~tNewKey
算法4．13
∥后移索引项
∥串赋值    
∥初始化书号索引表为空表
Status InsertBook(IdxListType~idxlist，  in％i，  int bno){
  if(!~keNode(p。bno))return 09Y／h~LOW；    ∥分配失败
  Appand(idxlist．item[i]．bnolist，p)；    ∥插入新的书号索引
  return OK；
＼{f InsertBook
算法4．14
