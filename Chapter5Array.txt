
第5章数组和广义表
    前几章讨论的线性结构中的数据元素都是非结构的原子类型，元素的值是不再分解的。本章讨论的两种数据结构――数组和广义表可以看成是线性表在下述含义上的扩展：表中的数据元素本身也是一个数据结构。
    数组是读者已经很熟悉的一种数据类型，几乎所有的程序设计语言都把数组类型设定为固有类型。本章以抽象数据类型的形式讨论数组的定义和实现，使读者加深对数组类型的理解。
5．1数组的定义
类似于线性表，抽象数据类型数组可形式地定义为：
ADT Array{
  数据对象：Ji=0，…，bi-1，i=I，2．…，n，
    D={a]^j。ln(>O)称为数组的维数，bi是数组第i维的长度，
    Jl是数组元素的第i维下标，a]1]'…]．∈ElemSet}
    数据关系：R={R1，R2，…，Rn}
    Ri“<ajl…・R’ajl・J。+1l”J。>}
    0≤jk≤blc1，  1≤k≤n且k≠i，
    0≤jj≤bi2，
    a91…J：・]。，ajl]，+l_．．]。∈D，i。2，…，n}
    基本操作：
    InitArray(&A，n，boundl，…，boundn)
    操作结果：若维数n和各维长度合法，则构造相应的数组A，并返回0K。
    Destroykrray(＆A)
    操作结果：销毁数组A。
    Value(A，＆e，indexl，…，indexn)    
    初始条件：A是n维数组，e为元素变量，随后是n个下标值。
    操作结果：若各下标不超界，则e赋值为所指定的A的元素值，并返回0K。
    Assign(＆A，e，indexl，…，indexn)
    初始条件：A是n维数组，e为元素变量，随后是n个下标值。
    操作结果：若下标不超界，则将e的值赋给所指定的A的元素，并返回OK。
}ADT~rray
    这是一个C语言风格的定义。从上述定义可见，n维数组中含有Ⅱbi个数据元素，  i=1
每个元素都受着n个关系的约束。在每个关系中，元素aj。j：…，。(0≤ji≤6； 2)都有一个直接后继元素。因此，就其单个关系而言，这”个关系仍是线性关系。和线性表一样，所有的数据元素都必须属于同一数据类型。数组中的每个数据元素都对应于一组下标(j。，j2，…，j。)，每个下标的取值范围是0≤ji≤bi―l，bi称为第i维的长度(i=1，2，…，n)。显然，当n：1时，n维数组就退化为定长的线性表。反之，n维数组也可以看成是线性表的推广。由此，我们也可以从另一个角度来定义n维数组。
    我们可以把二维数组看成是这样一个定长线性表：它的每个数据元素也是一个定长线性表。例如。图5．1(a)所示是一个二维数组，以m行”列的矩阵形式表示。它可以看成是一个线性表    A=(a1，a2，…，an)  (p=m-1或n-1)
其中每个数据元素a，是一个列向量形式的线性表 a。=(alj，。2J，…，)   1≤J≤≤”
(如图5．1(b)所示)或者ai是一个行向量形式的线性表Oli=(ail，ai2，…，)    1≤i≤m
(如图5．1(c)所示)。在C语言中，一个二维数组类型可以定义为其分量类型为一维数组类型的一维数组类型，也就是说，
    typedef ElemType Array2[m][n]；
等价于
    typedef ElemType Arrayl[n]；
    typedef Arrayl  Array2[m]；
同理，一个n维数组类型可以定义为其数据元素n-1维数组类型的一维数组类型。
a11  n12  n13
21    22    n23
nml  nm2  am3
    ()
A。。
Am。=((11n12…n1。)，(n2la22…2。)，…，(nmlm2…mn))
    (c)
    图5．1二维数组图例
  (a)矩薛形式表示；(b)列向量的一维数组；(。)行向量的一维数组。
    数组一旦被定义，它的维数和维界就不再改变。因此，除了结构的初始化和销毁之外，数组只有存取元素和修改元素值的操作。
5．2数组的顺序表示和实现
    由于数组一般不作插入或删除操作，也就是说，一旦建立了数组，则结构中的数据元素个数和元素之间的关系就不再发生变动。因此，采用顺序存储结构表示数组是自然的事了。
　　由于存储单元是一维的结构，而数组是个多维的结构，则用一组连续存储单元存放数组的数据元素就有个次序约定问题。例如图5．1(a)的二维数组可以看成如图5．1(。、)的一维数组，也可看成如图5．1(b)的一维数组。对应地，对二维数组可有两种存储方式：一种以列序为主序(column major order)的存储方式，如图5．2(a)所示；一种是以行序为主序(row major order)的存储方式，如图5．2(b)所示。在扩展BASIC、PL／I、COBOL、PASCAL和c语言中，用的都是以行序为主序的存储结构，而在FORTRAN语言中，用的是以列序为主序的存储结构。
　　LoC：))-LOC(a11)
LoC：))=LOC(a12)
Loc~：5=LOC(a1。)
A’(nI’，2“’，…，：")    4。’f^：¨；¨…：’)
    、    ’    ’    ’  n  ，    ＼J    z    “J
--n,Ji’(lJ，a2j，…amj)
    图5・2二维数组的两种存储方式
    (a)以列序为主序；(b)以行序为主序。
    由此，对于数组，一旦规定了它的维数和各维的长度，便可为它分配存储空间。反之，只要给出一组下标便可求得相应数组元素的存储位置。下面仅用以行序为主序的存储结构为例予以说明。
    假设每个数据元素占L个存储单元，则二维数组A中任一元素ao的存储位置可由下式确定    LOC[i，J]=LOC[O，0]+(b2×i+J)L    (5―1)
式中，LOCI i，J]是a／／的存储位置；LOC[0，0]是口00的存储位置，即二维数组A的起始存储位置，亦称为基地址或基址。
    将式(5―1)推广到一般情况，可得到托维数组的数据元素存储位置的计算公式：
      LOC[j1，J2，…，J。]=LOC[O，0，…，0]+(b2 x…×b。×j1+b3×…×b。×j2
    +…+b。×J。-1+J。)L
    n―l    ≈
    =LOC[O，0，…，0]+(∑Ji 1I b。+J。)L
    i=1  t=i+1
可缩写成
    LOC[j1，2，…，。]：LOC[O，0，…，0]+∑6ii    (5―2)
    i=1
其中  c。：L，c。1=6i×q，  1<i≤Y／。
    式(5―2)称为n维数组的映象函数。容易看出，数组元素的存储位置是其下标的线性函数，一旦确定了数组的各维的长度，ci就是常数。由于计算各个元素存储位置的时间相等，所以存取数组中任一元素的时间也相等。我们称具有这一特点的存储结构为随机存储结构。
    下面是数组的顺序存储表示和实现。
／／…数组的顺序存储表示
#include<stdarq．h>
#define MAX～ARRAY―DIM 8
tdef 8truct{
    ElemType  *base；
    int dim；
    int    *bounds；
    int    *constants；
}Array；
∥标准头文件，提供宏va―start、va，arg和va―end．
∥用于存取变长参数表
∥假设数组维数的最大值为8
∥数组元素基址，由InitArray分配
∥数组维数
∥数组维界基址，由InitArray分配
∥数组映象函数常量基址，由InitArray分配
∥…基本操作的函数原型说明…
Status InitArray(Array＆A，int dim，…)；
    ∥若维数dim和随后的各维长度合法，则构造相应的数组A，并返回0K。
Status DestroyArray(Array&A)；
  ∥销毁数组A。
Status Value(Array A，ElemT!~e&e，…)；
    ∥A是n维数组，e为元素变量，随后是n个下标值。
    ∥若各下标不超界，则e赋值为所指定的A的元素值，并返回OK。
Status Assign(Array＆A，ElemType e，…)；
    ∥A是n维数组，e为元素变量，随后是n个下标值。
    ∥若下标不超界，则将e的值赋给所指定的A的元素，并返回0K。
∥…基本操作的算法描述…
Status InitArray(Array＆A，Jut dim，…){
    ∥若维数dim和各维长度合法，则构造相应的数组A，并返回0K
    if(dim<1 Jl dim>MAX―ARRAY―mM)return ERROR；
    A．dim=dim；
    A．bounds。(int。),anoc(dim*slzeof(int))；
    if(!A．bounds)it(0VERFL0w)；
    ∥若各维长度合法，则存入A．bounds，并求出A的元素总数elemtota’
    elemtotal=I：
va―start(ap，dim)；    ∥ap为va―list类型，是存放变长参数表信息的数组
for(i=0；i<dim；++i){
    A．bounds[i]=va―arg(ap，~nt)；
    if(A．bounds[i]<0)return UNDERFLOW；
    elemtotal*=A．boundsIi J；
I
va―end(ap)；
A．base=(ElemType*)malloc(elemtotal*slzeof(ElemType))；
if(!A．base)exit(O、，|时LOW)；
∥求映象函数的常数Ci，并存入A．constants[i-1]，i=l，…，dim
A．constants=(int*)malloc(dim*sizeof(int))；
if(!A．constants)exit(ow~Lo．)；
A．constants[dim-1]=1；∥L=1，指针的增减以元素的大小为单位
for(i=dim-2；  i>=0；  --i)
  A．constants[i]=A．bounds[i+1]*A．constants[i+1]；
return OK：
Status DestroyArray(Array&A){
  ∥销毁数组A。
  if(!A．base)return ERROR；
  free(A．base)；    A．base=NULL；
  if!(A．bounds)return ERROR；
  free(A．bounds)；    A．bounds：NULL；
  if!(A．constants)  return ERROR；
  free(A．eonstants)；    A．constants=NULL
  return OK；
}
Status Locate(Array A，va―list ap，int&off){
    ∥若ap指示的各下标值合法，则求出该元素在A中相对地址off
    off：0；
    for(i=0；i<A．dim；  ++i){
    ind=va―arg(ap，int)；
    if(ind<0 ll ind>=A．bounds[i])return OVERFLOW；
    off十=A．constants[i]*ind；
    I
    return OK；
I
 Status Value(Array A，ElemType＆e，…){
    ∥A是n维数组，e为元素变量，随后是n个下标值。
    ∥若各下标不超界，则e赋值为所指定的A的元素值，并返回0K。
    va―start(ap，e)；
    if((result=Locate(A，ap，off))<=0)return result；
    e=*(A．base+off)；
    return OK；
・94・
Status Assign(Array＆A，ElemType e，…){
    ∥A是n维数组，e为元素变量，随后是n个下标值。
    ∥若下标不超界，则将e的值赋给所指定的A的元素，并返回0K。
    Va―starlt(ap，e)；
    if((result=Locate(A，ap，off))<=0)return result；
    *(A．base+off)=e；
    zaturn OK
}
5．3矩阵的压缩存储
    矩阵是很多科学与工程计算问题中研究的数学对象。在此，我们感兴趣的不是矩阵本身，而是如何存储矩阵的元从而使矩阵的各种运算能有效地进行。
    通常，用高级语言编制程序时，都是用二维数组来存储矩阵元。有的程序设计语言中还提供了各种矩阵运算，用户使用时都很方便。
    然而，在数值分析中经常出现一些阶数很高的矩阵，同时在矩阵中有许多值相同的元素或者是零元素。有时为了节省存储空间，可以对这类矩阵进行压缩存储。所谓压缩存储是指：为多个值相同的元只分配一个存储空间；对零元不分配空间。
    假若值相同的元素或者零元素在矩阵中的分布有一定规律，则我们称此类矩阵为特殊矩阵；反之，称为稀疏矩阵。下面分别讨论它们的压缩存储。
  5．3．1特殊矩阵
  若n阶矩阵A中的元满足下述性质i    1≤i，≤≤，z
0称为，z阶对称矩阵。
    对于对称矩阵，我们可以为每一对对称元分配一个存储空间，则可将n。个元压缩存储到n(n+1)／2个元的空间中。不失一般性，我们可以行序为主序存储其下三角(包括对角线)中的元。
    假设以一维数组阳[0．．n(n+1)／2]作为n阶对称矩阵A的存储结构，则sa[k]和矩阵元aii之间存在着--对应的关系：对于任意给定一组下标(i，)，均可在m中找到矩阵元aij，反之，对所有的k=1，2，…，都能确定sa[k]中的元在矩阵中的位置(i，j)。由此，称sa[0．．(n+1)／2]为
n阶对称矩阵A的压缩存储(见图5．3)。
    图5．3对称矩阵的压缩存储
    这种压缩存储的方法同样也适用于三角矩阵。所谓下(上)三角矩阵是指矩阵的上(下)三角(不包括对角线)中的元均为常数c或零的n阶矩阵。则除了和对称矩阵一样，只存储其下(上)三角中的元之外，再加一个存储常数c的存储空间即可。
　　在数值分析中经常出现的还有另一类特殊矩阵是对角矩阵。在这种矩阵中，所有的非零元都集中在以主对角线为中心的带状区域中。即除了主对角线上和直接在对角线上、下方若干条对角线上的元之外，所有其它的元皆为零。如图5．4所示。对这种矩阵，我们亦可按某个原则(或以行为主，或以对角线的顺序)将其压缩存储到一维数组上。
对角矩阵
(b)三对角矩阵。
    在所有这些我们统称为特殊矩阵的矩阵中，非零元的分布都有一个明显的规律，从而我们都可将其压缩存储到一维数组中，并找到每个非零元在一维数组中的对应关系。
    然而，在实际应用中我们还经常会遇到另一类矩阵，其非零元较零元少，且分布没有一定规律，我们称之为稀疏矩阵。这类矩阵的压缩存储就要比特殊矩阵复杂。这就是下一节我们要讨论的问题。
    5．3．2稀疏矩阵
    什么是稀疏矩阵?人们无法给出确切的定义，它只是一个凭人们的直觉来了解的概念。假设在m×n的矩阵中，有￡个元素不为零。令a，称a为矩阵的稀疏因子。通常认为a≤0．05时称为稀疏矩阵。矩阵运算的种类很多，在下列抽象数据类型稀疏矩阵的定义中，只列举了几种常见的运算。
    抽象数据类型稀疏矩阵的定义如下：
    AIE SparseMatrix{
    数据对象：D={a。。}i：1，2，…，m；j：l，2，…，n；
    a，。∈ElemSet，m和n分别称为矩阵的行数和列数}
    数据关系：R={Row．Col l
    Row=l<aill．aill+1>1 1≤i≤m，  l≤j≤n―l}
    Col={<ai．。，ai+1。>i l≤i≤m―l，  l≤j≤n I
基本操作：
  CreateSMatr’ix(＆M)；
    操作结果：创建稀疏矩阵M。
  DestroySMatriX(&M)；
    初始条件：稀疏矩阵M存在。
    操作结果：销毁稀疏矩阵M。
  PrintSMatrix(M)；
    初始条件：稀疏矩阵M存在。
    操作结果：输出稀疏矩阵M。
  CopySMatri】c(M，＆T)；
    初始条件：稀疏矩阵M存在。
    操作结果：由稀疏矩阵M复制得到T。
  ．AddSMatrix(M，N，&Q)；    ．
    初始条件：稀疏矩阵M与N的行数和列数对应相等。
    操作结果：求稀疏矩阵的和Q=M+N。
  SubtMatrix(M，N，＆Q)；
    初始条件：稀疏矩阵M与N的行数和列数对应相等。
    操作结果：求稀疏矩阵的差Q=M--N。
  Mul。tSMatz。ix(M，N，＆Q)；
    初始条件：稀疏矩阵M的列数等于N的行数。
    操作结果：求稀疏矩阵乘积Q=MxH。
  TransposeSMatrix(M，＆T)；
    初始条件：稀疏矩阵M存在。
    操作结果：求稀疏矩阵M的转置矩阵T。
  IADT S~seMatr-
    如何进行稀疏矩阵的压缩存储呢?
    按照压缩存储的概念，只存储稀疏矩阵的非零元。因此，除了存储非零元的值之外，还必须同时记下它所在行和列的位置(i，j)。反之，一个三元组(i，j，口“)唯一确定了矩阵A的一个非零元。由此，稀疏矩阵可由表示非零元的三元组及其行列数唯一确定。例如，下列三元组表    ((1，2，12)，(1，3，9)，(3，1，-3)，(3，6，14)，(4，3，24)，(5，2，18)，(6，l，15)，(6，4，
-7))加上(6，7)这一对行、列值便可作为图5．5中矩阵M的另一种描述。而由上述三元组表的不同表示方法可引出稀疏矩阵不同的压缩存储方法。
图5．5稀疏矩阵M和丁
  一、三元组顺序表
  假设以顺序存储结构来表示三元组表，则可得稀疏矩阵的一种压缩存储方式――我们称之为三元组顺序表。
∥…稀疏矩阵的三元组顺序表存储表示…
#define MAXSIZE 12500    ∥假设非零元个数的最大值为12500
type~ef struct{
    iat    i，j；    ∥该非零元的行下标和列下标
    ElelaTxjl~  e：
}Triple；    ‘
er~ef union{
    Triple data[MAX$1ZE+1]；∥非零元三元组表，data[O]未用
    int    Ⅲu，nu，tu；    ∥矩阵的行数、列数和非零元个数
}TSMatrix；
在此，data域中表示非零元的三元组是以行序为主序顺序排列的，从下面的讨论中读者容易看出这样做将有利于进行某些矩阵运算。下面将讨论在这种压缩存储结构下如何实现矩阵的转置运算。
    转置运算是一种最简单的矩阵运算。对于一个m×住的矩阵M，它的转置矩阵T是一个n×m的矩阵，且T(i，J)=M(歹，i)，1≤i≤”，1≤J≤优。例如，图5．5中的矩阵M和T互为转置矩阵。
    显然，一个稀疏矩阵的转置矩阵仍然是稀疏矩阵。假设口和6是’I'SMatrix型的变量，分别表示矩阵M和T。那么，如何由a得到6呢?
    从分析n和6之间的差异可见只要做到：(1)将矩阵的行列值相互交换；(2)将每个三元组中的i和歹相互调换；(3)重排三元组之间的次序便可实现矩阵的转置。前二条是容易做到的，关键是如何实现第三条。即如何使b．data冲的三元组是以T的行(M的列)为主序依次排列的。
6    4
a．data
 J    V
3    ―3
6    15
1    12
5    18
1    9
4    24
6    ―7
3    14
b．data
可以有两种处理方法：
    (1)按照b．data中三元组的次序依次在a．data中找到相应的三元组进行转置。换句话说，按照矩阵M的列序来进行转置。为了找到M的每一列中所有的非零元素，需要对其三元组表a．data从第一行起整个扫描一遍，由于a．data是以M的行序为主序来存放每个非零元的，由此得到的恰是b．data应有的顺序。其具体算法描述如算法5．1所示
Status TransposeSMatrix(TSMa~rix M．TSMatrix&T){
    ／／采用三元组表存储表示，求稀疏矩阵M的转置矩阵T。
    T．mu=M．nu；T．nu。M．mu；T．tu。M．tu；
    if(T．tu){
    q=1；
    far(col=1；col<=M．nu；++c01)
    for(P=I；p<=M．tu；+’p)
    if(M．data[p]．J==c01){
    T．data[q]．i=M．data[p]．J；T．data[q]．J=M．data[p]．i；
    T．data[q]．e=M．data[p]．e；  +’q；I
    }
    return OK；
}∥TransposeSMatrix
    算法5．1
    分析这个算法，主要的工作是在P和col的两重循环中完成的，故算法的时间复杂度为0(nu~tu)①，即和M的列数和非零元的个数的乘积成正比。我们知道，一般矩阵的转置算法为    for(col：1；col<=nu；++c01)
    for(row=1；row~--mu；++row)
    T[c01][row]=M[row][c01]；
其时间复杂度为O(mu×nil)。当非零元的个数tu和mu×nu同数量级时，算法5．1的时间复杂度就为O(mu×nu2)了(例如，假设在100×500的矩阵中有ttl----10000个非零元)，虽然节省了存储空间，但时间复杂度提高了，因此算法5．1仅适于tu<<mu~flu的情况。
    (2)按照a．data中三元组的次序进行转置，并将转置后的三元组置入b中恰当的位置。如果能预先确定矩阵M中每一列(即T中每一行)的第一个非零元在b．data中应有的位置，那么在对a．data中的三元组依次作转置时，便可直接放到b．data中恰当的位置上去。为了确定这些位置，在转置前，应先求得M的每一列中非零元的个数，进而求得每一列的第一个非零元在b．data中应有的位置。
    在此，需要附设num和cpot两个向量。num[c01]表示矩阵M中第col列中非零元的个数，cpot[c01]指示M中第col列的第一个非零元在b．data中的恰当位置。显然有    j cpot[1]=1；    rd、
    I cpot[c01]=cpot[col-1]+num[col-1]    2≤∞l≤a．nu    、。…
例如，对图5．5的矩阵M，Bum和cpot的值如表5．1所示。
表5．1矩阵M的向量elmt的值
①在此，我们将M．nu和M．tu简写成nu和tu，以下同。
这种转置方法称为快速转置，其算法如算法5 2所示。
    Status EasTransp。sentnx(atr】x M，TSHatr~＆T)I
    ∥采用三元组顺序表存储表示，求稀疏矩阵H的转置矩阵T。
    T nm。M nu；T―M mu；Ttu。Mtu；
    if(Ttu)l
    h(∞l=I；coi<-M“；_+c01)nuⅢ[c01]=0；
    f(t=l；t<=Mtu；++t)¨Ⅱ[M data[t]J】；／／求M中每一列含非零元个数
    cpot[I¨_I；
    ∥求第col列中第一个非举元在bdata巾的序号
    fⅡ(∥1 2；c。i<-M“；¨c01)cpot[e01]=cpot[col-【]p n~(col―1]；
    for(p=l；p<=M tu；l’p)l
    col=M data[P]J；  q=cpot[c01]；
    T~ata[q]i=Mdat~[p]]；T da[q】]=M data[p]1；
    T data[q]e=H data[p]。；  1}cpot[c01]；
    l∥for
    l∥，f
    rturIl OK
    l∥EastTransposes№trlx
算法5 2
    这个算法仅比n一个算法多用了两个辅助向量0。从时间上看．算法11_l有四个并列的单循环，循环次数分别ll为nu¨tu，因而总的时问复杂度为0(nu十lu)n在M的非零元个数t。和m。×nu等数量级时，其时间复杂度为0(mu×nu)，和经典算法的时问复杂度相同。
    三元组顺序表又称有序的双下标法，它的特点是，非零元在表中按行序有序存储．因此便于进行依行顺序处理的矩阵运算。然而，若需按行号存取某一行的非零元，则需从头开始进行查找。
  二、行逻辑链接的顺序表
  为r便于随机存取任意一行的非零元，则需知道每一行的第个非零元在三元组表中的位置。为此，可将上节快速转置矩阵的算法中创建的，指示“行”信息的辅助数组cpot固定在稀疏矩阵的存储结构中。称这种“带行链接信息”的三元组表为行逻辑链接时顺序表，其类型描述如下：
typedef 8tn1
  Triple data[MAY~91ZE’
  iIt    rposlMⅪⅡC 1 l
∥非：零元三元组表
∥各行第一个m零元的位置表
∥矩阵的行数、列数和非零元个数
在下面讨论的两个稀疏矩阵相乘例子中，容易看出这种表示方法的优越性：
    两个矩阵相乘的经典算法也是大家所熟悉的。若设
    Q=M×N
其中，M是m1×n1矩阵，N是m2×n2矩阵。当n1=m2时有：
    for(i=1；i<=ml；++i)
    for(j=l；j<=n2；++j){
    Q[i][j]=0；
    for(k=1；k<=n1；++k)Q[i][j]+=M[i][k]*N[k][j]；
    }
此算法的时间复杂度是0(m1×nl×n2)。
    当M和N是稀疏矩阵并用三元组表作存储结构时．就不能套用上述算法。假设M和N分别为 则Q=M×N为
    它们的三元组M．data、N．data和Q．data分别为：
M．data
 3
 5
1
 2
N．data
 2
1
2
 4
 0    2
 1    0
2  4
 0    0
Q．data
6
1
4
(55)
那么如何从M和N求得Q呢?
    (1)乘积矩阵Q中元素
        1≤i≤m，
    Q(i，j)=∑M(i，”×N(，J)    ，，．，‘    (5―6)
    ・    =l    1≮，≮n2
在经典算法中，不论M(i，)和N(，．j)的值是否为零，都要进行一次乘法运算，而实际上，这两者有一个值为零时，其乘积亦为零。因此，在对稀疏矩阵进行运算时，应免去这种无效操作，换句话说，为求Q的值，只需在M．data和N．data中找到相应的各对元素(即M．data中的j值和N．data中的i值相等的各对元素)相乘即可。
    例如，M．data[1]表示的矩阵元(1，1，3)只要和N．data[1]表示的矩阵元(1，2，2)相乘；而M．data[2]表示的矩阵元(1，4，5)则不需和N中任何元素相乘，因为N．data中没有i为4的元素。由此可见，为了得到非零的乘积，只要对M．data[1．．M．tu]中的每个元素
(i，k，M(i，k))(1≤i≤优1，1≤|iI≤，11)，找到N．data中所有相应的元素(，J，N(k，J))
(1≤≤m2，1≤≤，z2)相乘即可，为此需在N．data中寻找矩阵N中第n行的所有非零元。在稀疏矩阵的行逻辑链接的顺序表中，N．rpos为我们提供了有关信息。例如，式(5．5)中的矩阵N的rpos值如表5．2所示：
并且，由于rpos[row]指示矩阵N的第row行中第一个非零元在N．data中的序号，则rpos[row+1]-1指示矩阵N的第tOW行中最后一个非零元在N．data中的序号。而最后一行中最后一个非零元在N．data中的位置显然就是N．tu了。
    (2)稀疏矩阵相乘的基本操作是：对于M中每个元素M．data[P](P=1，2，…，M．tu)，找到N中所有满足条件M．data[p]．j：N．data[q]．i的元素N．data[q】，求得M．data[P]．v和N．data[q]．v的乘积，而从式(5-6)得知，乘积矩阵Q中每个元素的值是个累计和，这个乘积M．data[p]．v×N．data[q]．v只是Q(i，J)中的一部分。为便于操作，应对每个元素设一累计和的变量，其初值为零，然后扫描数组M，求得相应元素的乘积并累加到适当的求累计和的变量上。
    (3)两个稀疏矩阵相乘的乘积不一定是稀疏矩阵。反之，即使式(5．6)中每个分量值M(i，n)×N(k，j)不为零，其累加值Q【i，J]也可能为零。因此乘积矩阵Q中的元素是否为非零元，只有在求得其累加和后才能得知。由于Q中元素的行号和M中元素的行号一致，又M中元素排列是以M的行序为主序的，由此可对Q进行逐行处理，先求得累计求和的中间结果(Q的一行)，然后再压缩存储到Q．data中去。
    由此，两个稀疏矩阵相乘(Q=M×N)的过程可大致描述如下：
Q初始化；
if(Q是非零矩阵){  ∥逐行求积
    for(arow=1；arow<：M．mu；++arow){    ∥处理M的每一行
    ctemp[]=0；    ∥累加器清零
    计算Q中第arow行的积并存入ctemp[]中；
    将ctemp[]中非零元压缩存储到Q．data；
    }／／for-glOW
l／／if
算法．5．3是上述过程求精的结果。
Status MultSMatrix(RLSMatrix M，RLSMatrix N，RLSMatrix＆Q){
    ∥求矩阵乘积Q=M×N，采用行逻辑链接存储表示。
    if(M．nu!=N．mu)玎皇turn ERROR；
    Q．mu=M．mu；Q．rill=N．nu；Q．tu=0；    ∥Q初始化
    if(M．tu*N．tu!=0){  ∥Q是非零矩阵
    for(~LrOW=1；araw<=M．mu；++arow){    ∥处理M的每一行
    ctemp[]=0；    ∥当前行各元素累加器清零
    Q．rpos[arow]：Q．tu+l；
    for(p：M．rpos[arow]；p<M．rpos[arow+1]；十’p){  ∥对当前行中每一个非零元
    brow=M．data[p]．J；    ∥找到对应元在N中的行号
    if(brow<N．nu)t=N．rpos[brow+1]；
    else{t=N．tu+l}
    for(q=N．rpos[brow]；q<t；  +’q){
    ccol=N．data[q]．J；    ∥乘积元素在Q中列号
    ctemp[cc01]+=M．data[p]．e*N．data[q]．e；
    f∥for q
    }∥求得Q中第crow(=arow)行的非零元
    for(ccol=l；ccol<=e．nu；++cc01)    ∥压缩存储该行非零元
    if(ctemp[cc01]){
    if(++O．tu>MAXSIZE)return ERROR；
    e．data[Q．tu]={arow，ccol，ctemp[cc01]I；
    }∥if
    ＼f}for arow
    }∥if
    return OK；
、f，MultSMatrix
算法5．3
    分析上述算法的时间复杂度有如下结果：累加器ctemp初始化的时间复杂度为0
(M．mu×N．nu)，求Q的所有非零元的时间复杂度为0(M．tu×N．tu／N．mu)，进行压缩
存储的时间复杂度为O(M．mux N．nil)，因此，总的时间复杂度就是0(M．mu×N．D_H+
M．tu×N．tu／N．mu)。
    若M是m行扎列的稀疏矩阵，N是n行m列的稀疏矩阵，则M中非零元的个数M．tu=8M×m×n，N中非零元的个数N．tu=×i1×P，此时算法5．3的时间复杂度就是O(m×p×(1+nM“))，当％<0．05和氐<0．05及扎<1000时，算法5．3的时间复杂度就相当于O(m×P)，显然，这是一个相当理想的结果。
    如果事先能估算出所求乘积矩阵Q不再是稀疏矩阵，则以二维数组表示Q。相乘的算法也就更简单了。
  三、十字链表
  当矩阵的非零元个数和位置在操作过程中变化较大时，就不宜采用顺序存储结构来表示三元组的线性表。例如，在作“将矩阵B加到矩阵A上”的操作时，由于非零元的插入或删除将会引起A．data中元素的移动。为此，对这种类型的矩阵，采用链式存储结构表示三元组的线性表更为恰当。
    在链表中，每个非零元可用一个含五个域的结点表示，其中i，J和。三个域分别表示该非零元所在的行、列和非零元的值，向右域right用以链接同一行中下一个非零元，向下域down用以链接同一列中下一个非零元。同一行的非零元通过right域链接成一个线性链表，同一列的非零元通过down域链接成一个线性链表，每个非零元既是某个行链表中的一个结点，又是某个列链表中的一个结点，整个矩阵构成了一个十字交叉的链表，故称这样的存储结构为十字链表，可用两个分别存储行链表的头指针和列链表的头指针的一维数组表示之。例如：式(5―5)中的矩阵M的十字链表如图5．6所示。
M．chead
    图5．6稀疏矩阵M的十字链表
算法5．4是稀疏矩阵的十字链表表示和建立十字链表的算法。
    ∥…稀疏矩阵的十字链表存储表示…
typedef steer Oa{
    int    i。J；    ／／该非零元的行和列下标
    ElemType    e；
    struct 0LNode*right，*down；  ／／该非零元所在行表和列表的后继链域
IOLNode；  *OLink；
typede~struct{
    OLink*rhead。*chead；
    int    mu，nu，tu；
}CrossList；
∥行和列链表头指针向量基址由CreateSMatrix分配
∥稀疏矩阵的行数、列数和非零元个数
Status CreateSMatrix―OL(CrossList&M){
    ∥创建稀疏矩阵M。采用十字链表存储表示。
    if(M)fr∞(M)；
    scanf(&m，&n，&t)；    ∥输入M的行数、列数和非零元个数
    M．mu：=m；  M．nH：=n；  M．tu：=t；
    if(!(M．rhead=(OLink*)lloc((m+1)*sizeo~(OLink))))exlt(OVERFLOW)；
    if(!(M．chead=(OLink*)110c((n+1)’sizeof(OLink))))exit(OVERFLOW)；
    M．rhead[]：M．chead【]=LL；   ∥初始化行列头指针向量；各行列链表为空链表
    for(scanf(&i，aj，&e)；i!=0；scanf(＆i，&j，＆e)){∥按任意次序输入非零元
    if(!(P=(OLNode*)Hlloc(si-eof(OLNode))))ex／t(OVERFLOW)；
    p->i=i；P->J=J；P->e=e；    ／／生成结点
    if(M．rhead[i]==)M．rhead【i]：p；
    else{    ∥寻查在行表中的插入位置
    for(q=M．rhead[i]；(q->right)＆＆q->right～>J<J；q=q->right；)
    P->right=q->right；  q->right=p；    I  ∥完成行插入
  if(M．chead【j]==HUuI)M．chead[j]：p；
  else I    ∥寻查在列表中的插入位置
    for(q=M．chead[J J；(q->down)＆&q->down->i<i；  q：q->down；)
    P->down=q->down；q->down=p；    }    ∥完成列插入
  }
  retttrn OK；
}∥Creat：eSMatriX-OL
算法5．4
　　对于m行m列且有￡个非零元的稀疏矩阵，算法5．4的执行时间为0(￡×s)，s=max{m，n}这是因为每建立一个非零元的结点时都要寻查它在行表和列表中的插入位置，此算法对非零元输入的先后次序没任何要求。反之，若按以行序为主序的次序依次输入三元组，则可将建立十字链表的算法改写成()(￡)数量级的(￡为非零元的个数)。
　　下面我们讨论在十字链表表示稀疏矩阵时，如何实现“将矩阵B加到矩阵A上”的运算。
    两个矩阵相加和第二章中讨论的两个一元多项式相加极为相似，所不同的是一元多项式中只有一个变元(即指数项)，而矩阵中每个非零元有两个变元(行值和列值)，每个结点既在行表中又在列表中，致使插入和删除时指针的修改稍为复杂，故需更多的辅助指针。
    假设两个矩阵相加后的结果为A’，则和矩阵A’中的非零元％’只可能有三种情况。它或者是。“+6，或者是i，(6d=0时)；或者是6i，(i，=0时)。由此，当将B加到A上去时，对A矩阵的十字链表来说，或者是改变结点的val域值(ni-6if≠0)，或者不变(6i，=0)，或者插入一个新结点(‰=0)。还有一种可能的情况是：和A矩阵中的某个非零元相对应，和矩阵A’中是零元，即对A的操作是删除一个结点(ai+6：i：0)。由此，整个运算过程可从矩阵的第一行起逐行进行。对每一行都从行表头出发分别找到A和B在该行中的第一个非零元结点后开始比较，然后按上述四种不同情况分别处理之。
    假设非空指针pa和pb分别指向矩阵A和B中行值相同的两个结点：抛：：NULI。表明矩阵A在该行中没有非零元，则上述四种情况的处理过程为：
    (1)若pa=：NULI．或pa～>j>pb->j，则需要在A矩阵的链表中插入一个值为bij的结点。此时，需改变同一行中前一结点的right域值，以及同一列中前一结点的down域值。
    (2)若pa->j<pb->j，则只要将pa指针往右推进一步。
    (3)若pa->j==pb->j且pa->e+pb->e!=0，则只要将a，j+b“的值送到pa所
指结点的e域即可，其它所有域的值都不变。
    (4)若pa->j==pb->j且pa->e+pb->e==0，则需要在A矩阵的链表中删除pa所指的结点。此时，需改变同一行中前一结点的right域值，以及同一列中前一结点的down域值。
    为了便于插入和删除结点，还需要设立一些辅助指针。其一是，在A的行链表上设pre指针，指示pa所指结点的前驱结点；其二是，在A的每一列的链表上设一个指针hl[j]，它的初值和列链表的头指针相同，即hl[j]=chead[j]。
    下面对将矩阵B加到矩阵A上的操作过程作一个概要的描述。
    (1)初始，令pa和pb分别指向A和B的第一行的第一个非零元素的结点，即    pa=A．rhead[1]；pb=B．rhead[1]；pre=NULL；
且令hl初始化
    for(．j=1；j<=A．nu；++J)hl[j]=A．cheadEj]；
    (2)重复本步骤，依次处理本行结点，直到B的本行中无非零元素的结点，即pb==
NULL为止：    
    ①若pa==NULL或pa->j>pb->j(即A的这一行中非零元素已处理完)，则需在A中插入一个pb所指结点的复制结点。假设新结点的地址为P，则A的行表中的指针作如下变化：
if(pre==NULL)A．；head[p->i]=p；
else{pre->right．：p；}
P->right=pa；pre=p；
A的列链表中的指针也要作相应的改变。首先需从hl[p->j]开始找到新结点在同一列中的前驱结点，并让hl[p->j]指向它，然后在列链表中插入新结点：
  if(A．chead[p->J]：=NuLL)  {A．chead[P->J]=p；P->down=NULL；}
  else{P->down=hl[P->J]->down；hX[p->J]->down=p；}
  hl【P->J J=P；
②若pa!=NULL且pa->J<pb->J，则令pa指向本行下一个非零元结点，即
  pre。pa；pa：pa->right：
③若pa->j==pb->j，则将B中当前结点的值加到A中当前结点上，即
  pa->e+：pb->e；
此时若pa->e!=0，则指针不变，否则删除A中该结点，即行表中指针变为
if(pre==NULL)A．rhead[pa->i]=pa->right；
else lpre->right=pa->right；}
p=pa；pa=pa->right；
同时，为了改变列表中的指针，需要先找到同一列中的前驱结点，且让hl[pa->j]指向该结点，然后如下修改相应指针：   
    if(A．chead[p->J]==p)  A．chead[p->J]=m[p->J]=P->down；
    else Im[p->j]->down=P->down；}
    free(p)；
    (3)若本行不是最后一行，则令pa和pb指向下一行的第一个非零元结点，转(2)；否则结束。
    通过对这个算法的分析可以得出下述结论：从一个结点来看，进行比较、修改指针所需的时间是一个常数；整个运算过程在于对A和B的十字链表逐行扫描，其循环次数主要取决于A和B矩阵中非零元素的个数ta和tb；由此算法的时间复杂度为O(ta+tb)。
5．4广义表的定义
顾名思义，广义表是线性表的推广。也有人称其为列表(Lists，用复数形式以示与统称的表list的区别)。广泛地用于人工智能等领域的表处理语言LISP语言，把广义表作为基本的数据结构，就连程序也表示为一系列的广义表。
    抽象数据类型广义表的定义如下：
    ADT GLis％{
    数据对象：D={eiI i=1，2，…，n；  n≥0；  ei∈AtomSet或ei∈GList，
    AtomSet为某个数据对象  }
    数据关系：R1=l<ei―l，ei>Iei―1．ei∈D，  2≤i≤n l
    基本操作：
    InitGList(＆L)；
    操作结果：创建空的广义表L。
    CreateGiist(&L，s)；
    初始条件：s是广义表的书写形式串。
    操作结果：由s创建广义表L。
    DestroyGLJ．st(＆L)；
    初始条件：广义表L存在。
    操作结果：销毁广义表L。
    copist(＆T，L)；
    初始条件：广义表L存在。
    操作结果：由广义表L复制得到广义表T。
    GLJ．stLength(L)；
    初始条件：广义表L存在。
    操作结果：求广义表L的长度，即元素个数。
    GL5．stDepth(L)；
    初始条件：广义表L存在。
    操作结果：求广义表L的深度。
    GLi．stEmpty(L)；
    初始条件：广义表L存在。
    操作结果：判定广义表L是否为空。
    GetHead(L)；
    初始条件：广义表L存在。
    操作结果：取广义表L的头。
    GetTail(L)；
    初始条件：广义表L存在。
    操作结果：取广义表L的尾。
    InsertFirst-GL(＆L，e)；
    初始条件：广义表L存在。
    操作结果：插入元素e作为广义表L的第一元素。
    De]eteFirst-GL(＆L，&e)；
    初始条件：广义表L存在。
    操作结果：删除广义表L的第一元素，并用e返回其值。
    Traverse―GL(L，Visit())；
    初始条件：广义表L存在。
    操作结果：遍历广义表L，用函数v-sit处理每个元素。
    IAGList
    广义表一般记作
    LS=(。l，。2，…，。)
其中，Ls是广义表(al，a2，…，a。)的名称，”是它的长度。在线性表的定义中，。(1≤i≤
”)只限于是单个元素。而在广义表的定义中，a。可以是单个元素，也可以是广义表，分别称为广义表LS的原子和子表。习惯上，用大写字母表示广义表的名称，用小写字母表示原子。当广义表LS非空时，称第一个元素．为Ls的表头(}lead)，称其余元素组成的表(2，a3，…，。)是LS的表尾(Tail)。
    显然，广义表的定义是一个递归的定义，因为在描述广义表时又用到了广义表的概念。下面列举一些广义表的例子。
    (1)A=(．)――A是一个空表，它的长度为零。
    (2)B=(P)列表B只有-／}、原F r，B的长度为l。
    (3)C=(“，(6，c，d))列表(’的长度为2，两个元素分别为原子n和子表(6，r，
d)?
    (4)D=(A，B，C)列表D的长度为3，三个元素都是列表。显然，将子表的值代入后，则有D=(()，(P)，(“，(6√，d)))，
    (5)E：(n，E)――这是一个递归的表，它的长度为2。j E相当于一个无限的列表￡=(Ⅱ，(，(“，…)))。
    从上述定义和例子可推出列表的三个重要结论：
    (1)列表的元素可以是子表，而子表的元素还可以是子表，…。由此，列表是一个多层次的结构，可以用图形象地表示。例如图5．7表示的是列表D。图中以圆圈表示列表，以方块表示原子。
    (2)列表可为其它列表所共享。例如在上述例子中，列表A、B和C为D的子表，则在D中可以不必列出子表的值，而是通过子表的名称来引用。
    (3)列表可以是一个递归的表，即列表也可以是其本身的一个子表。例如列表E就是一个递归的表。
    根据前述对表头、表尾的定义可知：任何--个非空列表其表头可能是原子，也可能是列表，而其表尾必定为列表。例如：
    Get}lead(B)=e．    GetTall(B)=()，
    GetHead(D)=A，    GetTail(D)=(B。C)，
由于(B，C)为非空列表，则可继续分解得到：
图5．7列表的图形表示
    GetHead((B，C))=B，    GetTail((B，C))=(C)，
值得提醒的是列表()和(())不同。前者为空表，长度n=0；后者长度”=l，可分解得到其表头、表尾均为空表()：
    5．5广义表的存储结构
    由于广义表(a。，a2，…，a。)中的数据元素可以具有不同的结构，(或是原子，或是列表)，因此难以用顺序存储结构表示，通常采用链式存储结构，每个数据元素可用一个结点表示。
    表结点

    原子结点
图5．8列表的链表结点结构
    如何设定结点的结构?由于列表中的数据元素可
能为原子或列表，由此需要两种结构的结点：一种是表结点，用以表示列表；一种是原子结点，用以表示原子。
从上节得知：若列表不空，则可分解成表头和表昆；反之，一对确定的表头和表尾可唯一确定列表。由此，一个表结点可由三个域组成：标志域、指示表头的指针域和指示表尾的指针域；而原子结点只需两个域：标志域和值域(如图5．8所示)。其形式定义说明如下：
∥…广义表的头尾链表存储表求…
tn~d-f enuIn{ATOM，LISq’fElemTag；∥ATOM：=O：原子，LIST==1：子表
typedef struct GLNode}
    ElemTag tag；    ∥公共部分，用于区分原子结点和表结点
    union{    j原了结点和表结点的联合部分
    AtomType atom；    ／／atom是原子结点的值域，AtomType由用卢定义
    5truI{strut％GLNode  *，1p，  *tp；}ptr；
    √ptr是表结点的指针域，ptr．hp和ptr．p分别指向表头和表尾i；
}*GList；    ∥广义表类型
图5．9广义表的存储结构示例
上节中曾列举了广义表的例子，它们的存储结构如图5．9所示。在这种存储结构中有几种情况：(1)除空表的表头指针为空外，对任何非空列表，其表头指针均指向一个表结点，且该结点中的hp域指示列表表头(或为原子结点，或为表结点)，tp域指向列表表尾(除非表尾为空，则指针为空，否则必为表结点)；(2)容易分清列表中原子和子表所在层次。
如在列表D中，原子a和e在同一层次上，而6、c和d在同一层次且比口和e低一层，B和c是同一层的子表；(3)最高层的表结点个数即为列表的长度。以上三个特点在某种程度上给列表的操作带来方便。也可采用另一种结点结构的链表表示列表，如图5．10和图5．11所示。其形式定义说明如下：
∥…广义表的扩展线性链表存储表示…
tylw~Qf enum IATOM，LIST}ElemTag；∥ATOM=：0：原子。LIST==1：子表
typedef struct GT／qode{
    E1emTag tag；    ／／公共部分，用于区分原子结点和表结点
    union{    ∥原子结点和表结点的联合部分
    AtomType    atom；  ∥原子结点的值域
    struct GLNode  *hp；  ∥表结点的表头指针
    }；
    struot GlSode
I*GList；
*tp；  ∥相当于线性链表的next，指向下一个元素结点
    ∥广义表类型GList是一种扩展的线性链表
对于列表的这两种存储结构，读者只要根据自己的习惯掌握其中一种结构即可。
    表结点
A
1 tag=0  I atom l tp  i
    原子结点
图5．10列表的另一种结点结构
图5．11列表的另一种链表表示
5．6m元多项式的表示
    在一般情况下使用的广义表多数既非是递归表，也不为其它表所共享。对广义表可以这样来理解，广义表中的一个数据元素可以是另一个广义表，一个m元多项式的表示就是广义表的这种应用的典型实例。
    在第2章中，我们曾作为线性表的应用实例讨论了一元多项式，一个一元多项式可以一个长度为m且每个数据元素有两个数据项(系数项和指数项)的线性表来表示。
    这里，我们将讨论如何表示m元多项式。一个m元多项式的每一项，最多有m个变元。如果用线性表来表示，则每个数据元素需要m+1个数据项，以存储一个系数值和m个指数值。这将产生两个问题：一是无论多项式中各项的变元数是多是少，若都按m个变元分配存储空间，则将造成浪费；反之，若按各项实际的变元数分配存储空间，就会造成结点的大小不匀，给操作带来不便；二是对优值不同的多项式，线性表中的结点大小也不同，这同样会引起存储管理的不便。因此，由于仇元多项式中每一项的变化数目的不均匀性和变元信息的重要性，故不适于用线性表表示。例如三元多项式    P(z，y，2)=z如y322+226y322+3z。31222+z4y4z+623y4z+2yz+15
其中各项的变元数目不尽相同，而y。、z。等因子又多次出现。如若改写为 
(z，y，z)=((z’o+226)y。+325∥2)z2+((z4+6z。)y4+2y)z+15
情况就不同了。现在，我们再来看这个多项式P，它是变元z的多项式，即．Az2+＆+
15z。，只是其中A和B本身又是一个(z，y)的二元多项式，15是z的零次项的系数。进一步考察A(z，y)，又可把它看成是y的多项式。回。+Dy。，而其中C和D为x的一元多项式。循此以往，每个多项式都可看作是由一个变量加上若干个系数指数偶对组成。
    任何一个m元多项式都可如此做：先分解出一个主变元，随后再分解出第二个变元，等等。由此，一个m元的多项式首先是它的主变元的多项式，而其系数又是第二变元的多项式，由此可用广义表来表示m元多项式。例如上述三元多项式可用式(5―7)的广义表表示，广义表的深度即为变元个数。
    P=z((A，2)，(B，1)，(15，O))①    (5―7)
其中A=y((C，3)，(D，2))
    C=z((1，10)，(2，6))
    D：z((3，5))
    B=3'((E，4)，(F，1))
    E=z((1，4))，(6，3))
    F=z((2，0))
可类似于广义表的第二种存储结构来定义表示m元多项式的广义表的存储结构。
链表的结点结构为：
    exp hp
    表结点
  1 exp tp
    原子结点
其中exp为指数域，coef’为系数域，hp指向其系数子表，tp指向同一层的下一结点。其形式定义说明如下：
ted．struet MPNode{
ElemTag tag；    ∥区分原子结点和表结点
int    exp；  ∥指数域
①  我们在广义表的括弧之前加一个变元，以示各层的变元。
 union l
    float    coef；
    struct MPNode*hp；
  l；
  struct MPNode    *tp；
}*MPList；
∥系数域
∥表结点的表头指针
∥相当于线性链表的next，指向下一个元素结点
∥m元多项式广义表类型
式(5―7)的广义表的存储结构如图5．12所示，在每一层上增设一个表头结点并利用exp指示该层的变元，可用一维数组存储多项式中所有变元，故exp域存储的是该变元在一维数组中的下标。头指针p所指表结点中exp的值3为多项式中变元的个数。可见，这种存储结构可表示任何元的多项式。
图5．12三元多项式户(T，y，2)的存储结构示意图
5．7广义表的递归算法
    在第三章中曾提及，递归函数结构清晰、程序易读、且容易证明正确性，因此是程序设计的有力工具，但有时递归函数的执行效率很低，因此使用递归应扬长避短。在程序设计的过程中，我们并不一味追求递归。如果一个问题的求解过程有明显的递推规律，我们也很容易写出它的递推过程(如求阶乘函数()=n!的值)，则不必要使用“递归”；反之，在对问题进行分解、求解的过程中得到的是和原问题性质相同的子问题(如Hanoi塔问题)，由此自然得到一个递归算法，且它比利用栈实现的非递归算法更符合人们的思维逻辑，因而更易于理解。但是要熟练掌握递归算法的设计方法也不是件轻而易举的事情。
在本节中，我们不打算全面讨论如何设计递归算法，只是以广义表为例，讨论如何利用“分治法”(【)ivide and Conquer)进行递归算法设计的方法。
    对这类问题设计递归算法时，通常可以先写出问题求解的递归定义。和第二数学归纳法类似，递归定义由基本项和归纳项两部分组成。
    递归定义的基本项描述了一个或几个递归过程的终结状态。虽然一个有限的递归(且无明显的叠代)可以描述一个无限的计算过程，但任何实际应用的递归过程，除错误情况外，必定能经过有限层次的递归而终止。所谓终结状态指的是不需要继续递归而可直接求解的状态。如例3―3的”阶Hanoi塔问题，在n=1时可以直接求得解，即将圆盘从x塔座移动到z塔座上。一般情况下，若递归参数为n，则递归的终结状态为”=0或”：1等。
    递归定义的归纳项描述了如何实现从当前状态到终结状态的转化。递归设计的实质是：当一个复杂的问题可以分解成若干子问题来处理时，其中某些子问题与原问题有相同的特征属性，则可利用和原问题相同的分析处理方法；反之，这些子问题解决了，原问题也就迎刃而解了。递归定义的归纳项就是描述这种原问题和子问题之间的转化关系。仍以Hanoi塔问题为例。原问题是将n个圆盘从x塔座移至z塔座上，可以把它分解成三个子问题：(1)将编号为1至，z―l的”一1个圆盘从x塔座移至Y塔座；(2)将编号为”的圆盘从x塔座移至z塔座；(3)将编号为1至”一1的圆盘从Y塔座移至z塔座。其中(1)和(3)的子问题和原问题特征属性相同。只是参数(”一1和n)不同，由此实现了递归，，    
    由于递归函数的设计用的是归纳思维的方法，则在设计递归函数时，成注意：(1)首先应书写函数的首部和规格说明，严格定义函数的功能和接口(递归调用的界面)，对求精函数中所得的和原问题性质相同的子问题，只要接口一致，便可进行递归调用；(2)对函数中的每一个递归调用都看成只是一个简单的操作，只要接口一致，必能实现规格说明中定义的功能，切忌想得太深太远。正如用第二数学归纳法证明命题时，由归纳假设进行归纳证明时绝不能怀疑归纳假设是否正确。
    下面讨论广义表的三种操作。首先约定所讨论的广义表都是非递归表且无共享子表。
    5．7．1求广义表的深度
　　广义表的深度定义为广义表中括弧的重数，是广义表的一种量度。例如：多元多项式广义表的深度为多项式中变元的个数。
　　  设非空广义表为
    LS=(。l，“2，…，a。)
其中a。(i=1，2，…，”)或为原子或为LS的子表，则求LS的深度可分解为”个子问题，每个子问题为求口i的深度，若a。是原子，则由定义其深度为零，若a，是广义表，则和上述一样处理，而Ls的深度为各a：(i=1，2，…，”)的深度中最大值加1。空表也是广义表，并由定义可知空表的深度为1。
    由此可见，求广义表的深度的递归算法有两个终结状态：空表和原子，且只要求得。．(i：1，2，…，n)的深度，广义表的深度就容易求得了。显然，它应比子表深度的最大值多1。
    广义表
    LS：(al，a2，…，a。)
的深度DEPTH(LS)的递归定义为
    ・  1 1 3  ・
基本项：DEPTH(LS)=l  当LS为空表时
    DEPTH(LS)=0  当LS为原子时
归纳项：DEPTH(LS)=1+Max{DEPTH(a；)}  n≥l
    l≤t≤”
由此定义容易写出求深度的递归函数。假设L是GList型的变量，则L=NULL表明广义表为空表，L->tag=0表明是原子。反之，L指向表结点，该结点中的hp指针指向表头，即为L的第一个子表，而结点中的tp指针所指表尾结点中的hp指针指向L的第二个子表。在第一层中由tp相连的所有尾结点中的hp指针均指向L的子表。由此，求广义表深度的递归函数如算法5．5所示。
int GListDepth(GList L){
    ∥采用头尾链表存储结构，求广义表L的深度。
    if(!L)return 1；    ∥空表深度为l
    if(L->tag==ATOM)return 0；    ∥原子深度为0
    for(ma】【=0，PP=L；PP；PP=PP->ptr．tp){
    dep=GListDepth(pp->ptr．hp)；∥求以PP->ptr．hp为头指针的子表深度
    if(dep>max)max=dep；
    }
    return max+1；    ∥非空表的深度是各元素的深度的最大值加1
＼ft GListDepth
算法5．5
    上述算法的执行过程实质上是遍历广义表的过程，在遍历中首先求得各子表的深度，然后综合得到广义表的深度。例如：图5．13展示了求广义表D的深度的过程。图中用虚线示意遍历过程中指针L的变化状况，在指向结点的虚线旁标记的是将要遍历的子表，而在从结点射出的虚线旁标记的数字是刚求得的子表的深度，从图中可见广义表D=(A，B，C)=(()，(e)，(n，(b，C，d)))的深度为3。若按递归定义分析广义表D的深度，则有：
    D|Pm(D)=1+Max IDa(A)，DBFI~(B)，DEPTH(C)}
    DEPTH(A)=1；
    DEPTH(B)=1十Max{DF2TH(e)}=I+0=1；
    DEPTH(C)=1+Max{DEPTH(a)，DI：阿I((b，C，d))}=2
    I(a)=0
    DEPTH((b，C，d))=l+Max ID~WH(a)，DF2TH(B)，DEPTH(c)}
    =1+0=1
由此，DEPTH(D)：1+Max{1，1，2}=3。
5．7．2复制广义表
    在5．5节中曾提及，任何一个非空广义表均可分解成表头和表尾，反之，一对确定的表头和表尾可唯一确定一个广义表。由此，复制一个广义表只要分别复制其表头和表尾，然后合成即可。假设LS是原表，NEWLS是复制表，则复制操作的递归定义为：
基本项：IIlitGList(NEwLs){置空表}，当Ls为空表时。
归纳项：cOPY(GetHead(Ls)->GetHead(NEWLS))  {复制表头}
    图5．13求广义表D的深度的过程-
    cOPY(＆tTail(Ls)  >GetTail(NEWLS))  {复制表尾}
若原表以图5．9的链表表示，则复制表的操作便是建立相应的链表。只要建立和原表中的结点--对应的新结点，便可得到复制表的新链表。由此可写出复制广义表的递归算法如算法5．6所示。
Status CopyGList(GList&T，GList L){
    ∥采用头尾链表存储结构，由广义表L复制得到广义表T。
    if(!L)T：NULL；  ∥复制空表
    else{
    if(!(T=(GList)malloc(sizeof(Gt／~ode))))旺北(0VERFl0W)；  ∥建表结点
    T->tag=L->tag；
    if(L->tag==A∞M)T->atom=L->atom；  ∥复制单原子
    else jCopyGList(T->ptr．hp，L->ptr．hp)；
    ∥复制广义表L->ptr．hp的一个副本T->ptr．hp
    CopyGList(T->ptr．tp，L->ptr．tp)；
    ∥复制广义表L->ptr．tp的一个副本T->ptr．tp
    I／／else
    }∥else
    return OK；
}∥CopyGList
算法5．6
注意，这里使用了变参，使得这个递归函数简单明了，直截了当地反映出广义表的复制过程，读者可试以广义表c为例循序察看过程，以便得到更深刻的了解。
5．7．3建立广义表的存储结构
    从上述两种广义表操作的递归算法的讨论中可以发现：在对广义表进行的操作下递归定义时，可有两种分析方法。一种是把广义表分解成表头和表尾两部分；另一种是把广义表看成是含有”个并列子表(假设原子也视作子表)的表。在讨论建立广义表的存储结构时，这两种分析方法均可。
    假设把广义表的书写形式看成是一个字符串S，则当S为非空白串时广义表非空。此时可以利用5．4节中定义的取列表表头Get}lead和取列表表尾GetTail两个函数建立广义表的链表存储结构。这个递归算法和复制的递归算法极为相似，读者可自行试之。
下面就第二种分析方法进行讨论。
    广义表字符串S可能有两种情况：(1)S=‘()’(带括弧的空白串)；(2)S=(a1，a 2，…，a。)，其中a=1，2，…，n)是s的子串。对应于第一种情况s的广义表为空表，对应于第二种情况S的广义表中含有n个子表，每个子表的书写形式即为子串ai(1，2，…，n)。此时可类似于求广义表的深度，分析由s建立的广义表和由a，(i=l，2，…，”)建立的子表之间的关系。假设按图5．8所示结点结构来建立广义表的存储结构，则含有”个子表的广义表中有n个表结点序列。第i(i=1，2，…，”-1)个表结点中的表尾指针指向第H 1个表结点。第n个表结点的表尾指针为NuuL，并且，如果把原子也看成是子表的话，则第i个表结点的表头指针hp指向由ai建立的子表(i=1，2，…，”)。由此，由S建广义表的问题可转化为由a：(江1，2，…，”)建子表的问题。又，ai可能有三种情况：(1)带括弧的空白串；(2)长度为1的单字符串；(3)长度>l的字符串。显然，前两种情况为递归的终结状态，子表为空表或只含一个原子结点，后一种情况为递归调用。
由此，在不考虑输入字符串可能出错的前提下，可得下列建立广义表链表存储结构的递归定义。
基本项：
  置空广义表    当S为空表串时
  建原子结点的子表    当S为单字符串时
归纳项：假设sub为脱去S中最外层括弧的子串，记为’sl's2，…，s。’，其中si(i=1，2，…，  ”)为非空字符串。对每一个si建立一个表结点，并令其矗p域的指针为由s，建立的子表的头指针，除最后建立的表结点的尾指针为NuuL外，其余表结点的尾指针均指向在它之后建立的表结点。
    假定函数sever(str，hstr)的功能为，从字符串str中取出第一个“，”之前的子串赋给hstr，并使str成为删去子串hstr和‘，’之后的剩余串，若串str中没有字符‘，’，则操作后的hstr即为操作前的str，而操作后的str为空串NULL。根据上述递归定义可得到建广义表存储结构的递归函数如算法5．7所示。函数sever如算法5．8所示。
Status CreateGList(GList&L，SString s)l
    ∥采用头尾链表存储结构，由广义表的书写形式串s创建广义表L。设emp=”()”    if(strCompare(s，emp))L=MOLL；∥创建空表
    else J
    if(!(L：(GList)malfoe(sizeof(GLNode))))exit(OVERFIZW)；∥建表结点
    if(strLength(s)==1){L->tag=ATOM；  L->atom=s}  ∥创建单原子广义表
    else{
    L->tag=L工ST；  p=L；
    subSt．ring(sub．s，2，strLength(s)-2)；    ∥脱外层括号
    do{  ∥重复建n个子表
    sever(sub，hsub)；∥从sub中分离出表头串hsub
    CreateGList(P->P．hp，hsub)；q=p；
    if(!StrEmpty(sub)){    ∥表尾不空
    if(!(P：(GLNode*)malloc(sizeof(GLNode))))
    exit(OVEI~LOW)；
    P->tag=LIST；  q->p．tp=p；
    }∥if
    }while(!StrEmpty(sub))；
    q->p．tp=lULL；
    }else
    }∥else
    return OK；
}／／CreateGList
算法S．7
Status sever(SString＆str，SString＆hstr){
    ∥将非空串str分割成两部分：hsub为第一个’，’之前的子串，str为之后的子串
    n=StrLength(str)；  i=1；k=0；∥k记尚未配对的左括号个数
    for(i=I，k=0；i<：n＆＆ch!：’，‘l_k!=0；  ++i){    ．
    ∥搜索最外层的第一个逗号
    SubString(ch，str，i，1)；
    if(ch==’(’)    ++k；
    else if(ch==’)’)  --k：
    f／／for
    if(i<=n)
    {SubString(hstr，str，1．I-2)；SubString(str，
  else{StrCopy(hstr，str)；ClearString(str)}
}／／sever
算法5．8
