
第2章线性表
　　从第2章至第4章将讨论线性结构。线性结构的特点是：在数据元素的非空有限集中，(1)存在唯一的一个被称做“第一个”的数据元素；(2)存在唯一的一个被称做“最后一个”的数据元素；(3)除第一个之外，集合中的每个数据元素均只有一个前驱；(4)除最后一个之外，集合中每个数据元素均只有一个后继。
　　2．1线性表的类型定义
    线性表(Linear―List)是最常用且最简单的一种数据结构。简言之，一个线性表是个数据元素的有限序列。至于每个数据元素的具体含义，在不同的情况下各不相同，它可以是一个数、或一个符号，也可以是一页书，甚至其它更复杂的信息。例如，26个英文字母的字母表：
    (A，B，C，．．．…，Z)
是一个线性表，表中的数据元素是单个字母字符。又如，某校从1978年到1983年各种型号的计算机拥有量的变化情况，可以用线性表的形式给出：
    (6，17，28，50，92，188)
表中的数据元素是整数。
    在稍复杂的线性表中，一个数据元素可以由若干个数据项(Item)组成。在这种情况下，常把数据元素称为记录(Record)，含有大量记录的线性表又称文件(File)。
    例如，一个学校的学生健康情况登记表如图2．1所示，表中每个学生的情况为一个记录，它由姓名、学号、性别、年龄、班级和健康状况等六个数据项组成。
图2．1学生健康情况登记表
    综合上述三个例子可见，线性表中的数据元素可以是各种各样的，但同一线性表中的元素必定具有相同特性，即属同一数据对象，相邻数据元素之间存在着序偶关系。若将线性表记为
    (a1,a2,…,ai,…,an)    (2―1)
则表中ai-1领先于ai，ai领先于ai+1。，称ai-1是ai的直接前驱元素，ai+1是ai的直接后继元素。当i=1，2，…，n一1时，ni有且仅有一个直接后继，当i=2，3，…，n时，ai有且仅有一个直接前驱。
    线性表中元素的个数n(n≥0)定义为线性表的长度，n=0时称为空表。在非空表中的每个数据元素都有一个确定的位置，如a1是第一个数据元素，an是最后一个数据元素,ai是第i个数据元素，称i为数据元素ai在线性表中的位序。
    线性表是一个相当灵活的数据结构，它的长度可根据需要增长或缩短，即对线性表的数据元素不仅可以进行访问，还可进行插入和删除等。
    抽象数据类型线性表的定义如下：
ADT List j
  数据对象：D={ail ai∈ElemSet，i=1，2，…，n，n≥0}
  数据关系：R1={<ai一1，ai>lai一1，ai∈D，i=2…．，n}
  基本操作：
    InitList(&L)
    操作结果：构造一个空的线性表L。
    DestroyList(＆L)
    初始条件：线性表L已存在。
    操作结果：销毁线性表L。
    CIearList(&L)
    初始条件：线性表L已存在。
    操作结果：将L重置为空表。
    ListEmpty(L)
    初始条件：线性表L已存在。
    操作结果：若L为空表，则返回TRUE，否则返回FALSE。
    ListLength(L)
    初始条件：线性表L已存在。
    操作结果：返回L中数据元素个数。
    GetElem(L，i，＆e)
    初始条件：线性表L已存在，1≤i≤ListLength(L)。
    操作结果：用e返回L中第i数据个元素的值。
    LocateElem(L，e，compare())
    初始条件：线性表L已存在，compare()是数据元素判定函数。
    操作结果：返回L中第1个与e满足关系compare()的数据元素的位序。若这样的数据元素不存在，则返回值为0。
    PriorElem(L，cur_e，&pre_e)
    初始条件：线性表L已存在。
    操作结果：若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱，否则操作失败，pre_e无定义。
    NextElem(L，cur_e，next_e)
    初始条件：线性表L已存在。
    操作结果：若cur_e是L的数据元素，且不是最后一个，则用next_e返回它的后继，否则操作失败，next_e无定义。
    ListInsert(＆L，I, e)
    初始条件：线性表L已存在，l≤i≤ListLength(L)+1。
    操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1。
    ListDelete(＆L，i，&e)
  初始条件：线性表L已存在且非空，1≤i≤ListLengtb(L)。
  操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1。
  ListTravel(L，visit())
  初始条件：线性表L已存在。
  操作结果：依次对L的每个数据元素调用函数visit()。一旦visit()失败，则操作失败。
}ADTList
    对上述定义的抽象数据类型线性表，还可进行一些更复杂的操作。如：将两个或两个以上的线性表合并成一个线性表；把一个线性表拆开成两个或两个以上的线性表；重新复制一个线性表等等。
    例2―1假设利用两个线性表LA和LB分别表示两个集合A和B(即：线性表中的数据元素即为集合中的成员)，现要求一个新的集合A=A U B。这就要求对线性表作如下操作：扩大线性表LA，将存在于线性表LB中而不存在于线性表LA中的数据元素插入到线性表．LA中去。只要从线性表LB中依次取得每个数据元素，并依值在线性表LA中进行查访，若不存在，则插入之。上述操作过程可用下列算法描述之。
void union(List&La，List Lb)l
  ∥将所有在线性表Lb中但不在La中的数据元素插入到La中
  La―len=ListLength(La)；Lb―lea=ListLength(Lb)；∥求线性表的长度
  for(i：1；i<=Lb―len；i++){
  GetElem(Lb，i，e)；    ∥取Lb中第i个数据元素赋给e
  if(!LocateElem(La，e，equa]．))ListInsert(La，  ++La―lend。e)；
    ∥La中不存在和e相同的数据元素，则插入之
}
}//union
算法2．1
    例2．2  已知线性表LA和LB中的数据元素按值非递减有序排列，现要求将LA和
LB归并为一个新的线性表Lc，且Lc中的数据元素仍按值非递减有序排列。例如，设
    LA=(3，5，8，11)
    LB=(2，6，8，9，11，15，20)
则
    LC=(2，3，5，6，8，8，9，11，11，15，20)
    从上述问题要求可知，LC中的数据元素或是LA中的数据元素，或是LB中的数据元素，则只要先设Lc为空表，然后将LA或LB中的元素逐个插入到Lc中即可。为使Lc中元素按值非递减有序排列，可设两个指针i和J分别指向LA和LB中某个元素，若设i当前所指的元素为a，j当前所指的元素为b，则当前应插入到LC中的元素c为。
显然，指针i和J的初值均为1，在所指元素插入LC之后，在LA或LB中顺序后移。上述归并算法如算法2．2所示。
void MergeList(List La，List Lb，List&Lc){
    ∥已知线性表La和Lb中的数据元素按值非递减排列。
    ∥归并La和Lb得到新的线性表Lc，Lc的数据元素也按值非递减排列。
    InitList(Lc)；
    i=J=1；k=0；
    La―len=ListLength(La)；Lb―len=ListLength(Lb)；
    ．bile((i<=La―fen)&＆(J<=Lb―len)){∥La和Lb均非空
    GetElem(La，i，ai)；GetElem(Lb，J，bj)；
    if(ai<：bj)  lListlnsert(Lc，++k，a1)；++i；}
    else{ListInsert(Lc，++k，bj)；++j；}
    }
    while(i<=La―len)I
    GetElem(La，i++，ai)；Listlnsert(Lc，++k，ai)；
    }
    while(J<=Lb―fen)l
    GetElem(Lb，j++，bj)；ListInsert(Lc，++k，bj)；
    }
}∥MergeList
算法2．2
    上述两个算法的时间复杂度取决于抽象数据类型List定义中基本操作的执行时间。假如GetElem和Listlnsert这两个操作的执行时间和表长无关，LocateElem的执行时间和表长成正比，则算法2．1的时间复杂度为O(ListLength(LA)×ListLength(LB))，算法2．2的时间复杂度则为O(ListLength(LA)+ListLength(LB))。虽然算法2．2中含三个(while)循环语句，但只有当i和j均指向表中实际存在的数据元素时，才能取得数据元素的值并进行相互比较；并且当其中一个线性表的数据元素均已插入到线性表LC中后，只要将另外一个线性表中的剩余元素依次插入即可。因此，对于每一组具体的输入(LA和LB)，后两个(while)循环语句只执行一个循环体。
2．2线性表的顺序表示和实现
    线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素。    假设线性表的每个元素需占用z个存储单元，并以所占的第一个单元的存储地址作为数据元素的存储位置。则线性表中第i+1个数据元素的存储位置LOC(ai+1)和第i个数据元素的存储位置LOC(ai)之间满足下列关系：
    LOC(ai+1)=LOC(ai)+l
一般来说，线性表的第i个数据元素ai的存储位置为
    LOC(ai)=LOC(a1)+(i一1)*Z    (2―2)
式中LOC(a1)是线性表的第一个数据元素a1的存储位置，通常称做线性表的起始位置或基地址。
    线性表的这种机内表示称做线性表的顺序存储结构或顺序映象(Sequential Maping)，通常，称这种存储结构的线性表为顺序表。它的特点是，为表中相邻的元索ai和ai+1赋以相邻的存储位置LOC(ai)和LOC(ai+1)。换句话说，以元素在计算机内“物理位置相邻”来表示线性表中数据元素之间的逻辑关系。每一个数据元素的存储位置都和线性表的起始位置相差一个和数据元素在线性表中的位序成正比的常数（见图2.2）。由此，只要确定了存储线性表的起始位置，线性表中任一数据元素都可随机存取，所以线性表的顺序存储结构是一种随机存取的存储结构。
    由于高级程序设计语言中的数组类型也有随机存取的特性，因此，通常都用数组来描述数据结构中的顺序存储结构。在此，由于线性表的长度可变，且所需最大存储空间随问题不同而不同，则在C语言中可用动态分配的一维数组，如下描述。
    ∥  …    线性表的动态分配顺序存储结构～…
    #define LIST、INIT SIZE 100  //线性表存储空间的初始分配量}
    #define LISTIN~    10      //线性表存储空间的分配增量
typedef struct {
ElemType  *elem; ∥存储空间基址
Int  length；∥当前长度
Int listsize; ∥当前分配的存储容量
}SqList；
    在上述定义中．数组指针elem指示线性表的基地址，length指示线性表的当前长度。
顺序表的初始化操作就是为顺序表分配一个予定义大小的数组空问，并将线性表的当前长度设为”0”(参见算法2 3)。Listsize指示顺序表当前分配的存储空间大小，一旦因插入元素而空间不足时，可进行再分配，即为顺序表增加一个大小为存储LISTINCREMENT个数据元素的空间。
    在这种存储结构中，容易实现线性表的某些操作，入随机存取第i个数据元素等。只是要特别注意的是，C语言中数组的下标从”0”开始，因此，若L是SqList类型的顺序表，则表中第i个数据元素是L.elem[i-1]。下面重点讨论线性表的插入和删除两种操作在顺序存储表示时的实现方法。
　　如2.1节中所述，线性表的插入操作时指在线性表的第i-1个数据元素和第i个数据元素之间插入一个新的数据元素，就是要使长度为n的线性表
　　(a1,…ai-1,ai,…,an)
变为长度为n+1的线性表
　　(a1,…ai-1,b,ai,…,an)
数据元素ai-1和ai之间的逻辑关系发生了变化。在线性表的顺序存储结构中，由于逻辑上相邻的数据元素在物理位置上也是相邻的，因此，除非i=n+1，否则必须移动元素才能反映这个逻辑关系的变化。
    例如，图2．3表示一个线性表在进行插入操作的前、后，其数据元素在存储空间中的位置变化。为了在线性表的第4和第5个元素之间插入一个值为25的数据元素，则需将第5个至第8个数据元素依次往后移动一个位置。
    一般情况下，在第i(1≤i≤n)个元素之前插入一个元素时，需将第n至第i(共n-i+1)个元素向后移动一个位置，如算法2．4所示。
Status Listlnsert Sq(SqList＆L，Jut i，ElemType e){
    ∥在顺序线性表L中第i个位置之前插入新的元素e，
    ∥i的合法值为1≤i≤ListLength―Sq(L)+1
    if(i<1 0 i>L．1ength十1)return ERROR；  ∥i值不合法
    if(L．1ength>=L．1istsize){    ∥当前存储空间已满，增加分配
    newbase=(ElemType*)realloc(L．elem，
    (L．1istsize+LISTINCREMENT)*sizeof(ElemType))；
    if(!newbase)exit(0VERFLOW)；    ∥存储分配失败
    L．elem：newbase；    ∥新基址
    L．1istsize+=LISTINCREMENT；  ∥增加存储容量
    }  
    q：&(L．elem[i一1])；    ∥q为插入位置
    for(p：＆(L．elem[L．1ength―1])；P>=q；--P)*(P+1)：。p；
    ∥插入位置及之后的元素右移
    *q=e；    ∥插入e
    ++L．1ength；    ∥表长增l
    return OK；
}∥Listlnsert―Sq
算法2．4
    反之，线性表的删除操作是使长度为n的线性表
    (a1，…，ai- 1，ai，ai+l，…，an)
变成长度为n-1的线性表
    (a1，…，ai-1，ai+1，…，an)
数据元素ai-1。ai和ai+l之间的逻辑关系发生变化，为了在存储结构上反映这个变化，同样需要移动元素。如图2．4所示，为了删除第4个数据元素，必须将从第5个至第8个元素都依次往前移动一个位置。
    一般情况下，删除第i(1≤i≤n)个元素时需将从第i+1至第n个元素依次向前移动一个位置，如算法2．5所示。
  Status ListDelete―sq(SqList&L，int i，ElemType＆e){
    ∥在顺序线性表L中删除第i个元素，并用e返回其值
    ∥i的合法值为1≤i≤ListLength―Sq(L)
    if((i<1)j J(i>L．1ength))return ERROR；  ∥i值不合法
    P。&(L．elem[i一1])；    ∥P为被删除元素的位置
    e。*p；    ∥被删除元素的值赋给e
    q。L．elem+L．1ength一1；    ∥表尾元素的位置
    for(+’p；P<。q；+’p)*(P一1)=*p；    ∥被删除元素之后的元素左移
・24・
    --L．1ength：
    return OK；
}∥ListDelete―sq
∥表长减1
算法2．5    ．
    从算法2．4和2．5可见，当在顺序存储结构的线性表中某个位置上插入或删除一个数据元素时，其时间主要耗费在移动元素上(换句话说，移动元素的操作为预估算法时间复杂度的基本操作)，而移动元素的个数取决于插入或删除元素的位置。
    假设A是在第i个元素之前插入一个元素的概率，则在长度为n的线性表中插入一个元素时所需移动元素次数的期望值(平均次数)为
    Eis=∑pi(n-i+1)    (2―3)
    假设qi是删除第i个元素的概率，则在长度为n的线性表中删除一个元素时所需移动元素次数的期望值(平均次数)为
    EdI=∑qi(n-i)    (2―4)
不失一般性，我们可以假定在线性表的任何位置上插入或删除元素都是等概率的，即
则式(2―3)和(2―4)可分别简化为式(2．5)和(2―6)：
    由式(2．5)和(2-6)可见，在顺序存储结构的线性表中插入或删除一个数据元素，平均约移动表中一半元素。若表长为n，则算法L,istInserlt_sq和ListDelete―Sq的时间复杂度为0(n)。
    现在我们来讨论2．1节中例2―1和例2―2的操作在顺序存储结构的线性表中的实现方法和时间复杂度的分析。容易看出，顺序表的“求表长”和“取第i个数据元素的时间复杂度均为0(1)，又这两个例子中进行的“插入”操作均在表尾进行，则不需要移动元素。因此，算法2．1的执行时间主要取决于查找函数Lx~cateElem的执行时间。在顺序表L中查访是否存在和e相同的数据元素的最简便的方法是，令e和L中的数据元素逐个比较之，如算法2．6所示。从算法2．6中可见。基本操作是“进行两个元素之间的比较”，若L中存在和e相同的元素ni，则比较次数为i(1≤i≤L．1ength)，否则为L．1ength，即算法LocateElem-Sq的时间复杂度为o(L．1ength)。由此，对于顺序表k和L6而言，union的时间复杂度为O(La．1ength×Lb．1ength)。
    int LocateElem―Sq(SqLJ．st L，ElemType
    St：~ttg(*compare)(ElemType，ElemType)){
    ∥在顺序线性表L中查找第1个值与e满足compare()的元素的位序
    ∥若找到，则返回其在L中的位序，否则返回0
    i=I；    ∥i的初值为第1个元素的位序
    P=L．elem；    ∥p的初值为第1个元素的存储位置
    while(i<：L．1ength＆&!(*compare)(’p++，e))++i；
    if(i<=L．1ength)return i；
    else return 0；
算法2．6
　　对于“顺序表的合并”，则从算法2．2可直接写出形式上极其相似的算法2．7。显然，算法2．7中的基本操作为“元素赋值”，算法的时间复杂度为O(La．1ength十Lb．1ength)。
　　void Merge_List―Sq(SqList La，SqList Lb，SqList＆Lc){
    ∥已知顺序线性表La和Lb的元素按值非递减排列
    ∥归并La和Lb得到新的顺序线性表Lc，Lc的元素也按值非递减排列
    pa=La．elem；pb=Lb．elem；
    Lc．1istsize：Lc．1ength：La．1ength+Lb．1ength：
    pc：Lc．elem：(ElemType*)ulloc(nc．1istsize*sizeof(ElemType))；
    if(!Lc．elem)exit(OVERFLOW)；∥存储分配失败
    pa―last：La．elem+La．1ength一1：
    pb―last=Lb．elem+Lb．1ength一1：
    while(pa<=pa―last＆＆pb<=pb―last){    ∥归并
    if(*pa<=  *pb)*pc十+：*pa十+；
    else*pc++=*pb++；
    1
    while(pa<=pa―last)。pc++=”pa+’；    ∥插入La的剩余元素
    while(pb<=pb―last)。pc++=*pb+’；    ∥插入Lb的剩余元素
＼  ?{MergeList，Sq
算法2．7
　　若对算法2．7中第一个循环语句的循环体作如下修改：以“开关语句”代替“条件语句”，即分出元素比较的第三种情况，当*pa=*pb时，只将两者中之一插入Lc，则该算法完成的操作和算法union完全相同，而时间复杂度却不同。算法2．7之所以有线性的时间复杂度，其原因有二：1)由于La和Lb中元素依值递增(同一集合中元素不等)，则对Lb中每个元素，不需要在La中从表头至表尾进行全程搜索；2)由于用新表Lc表示“并集”，则插入操作实际上是借助“复制”操作来完成的①。为得到元素依值递增(或递减)的有序表，可利用10．3节讨论的快速排序，其时间复杂度为0(nlogn)(其中n为待排序的元素个数)。由此可见，若以线性表表示集合并进行集合的各种运算，应先对表中元素进行排序。
2．3线性表的链式表示和实现
    从上一节的讨论中可见，线性表的顺序存储结构的特点是逻辑关系上相邻的两个元素在物理位置上也相邻，因此可以随机存取表中任一元素，它的存储位置可用一个简单、直观的公式来表示。然而，从另一方面来看，这个特点也铸成了这种存储结构的弱点：在作插入或删除操作时，需移动大量元素。本节我们将讨论线性表的另一种表示方法――链式存储结构，由于它不要求逻辑上相邻的元素在物理位置上也相邻，因此它没有顺序存储结构所具有的弱点，但同时也失去了顺序表可随机存取的优点。
    2．3．1线性链表
    线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素(这组存储单元可以是连续的，也可以是不连续的)。因此，为了表示每个数据元素。i与其直接后继数据元素ai+，之间的逻辑关系，对数据元素ai来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息(即直接后继的存储位置)。这两部分信息组成数据元素ai的存储映象，称为结点(Node)。它包括两个域：其中存储数据元素信息的域称为数据域；存储直接后继存储位置的域称为指针域。指针域中存储的信息称做指针或链。n个结点(ai(1≤i≤n)的存储映象)链结成一个链表，即为线性表
　　(a1，a2，…，an)    
　　的链式存储结构。又由于此链表的每个结点中只包含一个指针域，故又称线性链表或单链表。
    例如，图2．5所示为线性表
    (ZHAO，QIAN，SUN，LI，ZHOU，WU，ZHENG，WANG)
的线性链表存储结构，整个链表的存取必须从头指针开始进行，头指针指示链表中第一个结点(即第一个数据元素的存储映象)的存储位置。同时，由于最后一个数据元素没有直接后继，则线性链表中最后一个结点的指针为“空”(NULL)。
    存储地址    数据域    指针域
    l    LI    43
    7    QIAN    13
头指针H    13    SUN    1
19WANG    NuLL
25    WU    37
    3l    ZHAo    7
    37    ZHENG    19
    43    ZH()U    25
    图2 5线性链表示例
    用线性链表表示线性表时，数据元素之间的逻辑关系是由结点中的指针指示的。换句话说，指针为数据元素之间的逻辑关系的映象，则逻辑上相邻的两个数据元素其存储的物理位置不要求紧邻，由此，这种存储结构为非顺序映象或链式映象。
    通常我们把链表画成用箭头相链接的结点的序列，结点之间的箭头表示链域中的指针。如图2．5的线性链表可画成如图2．6所示的形式，这是因为在使用链表时，关心的只是它所表示的线性表中数据元素之间的逻辑顺序，而不是每个数据元素在存储器中的实际位置。
    图2．6线性链表的逻辑状态
由上述可见，单链表可由头指针唯一确定，在c语言中可用“结构指针”来描述。
    ∥--线性表的单链表存储结构---
typedef struct Node{
    ElemType data：
    struct LNode    *next：
}IA~ode，*LinkLlst；
    假设L是LinkIist型的变量，则L为单链表的头指针，它指向表中第一个结点。若L为“空”(L=NuLL)，则所表示的线性表为“空”表，其长度n为“零”。有时．我们在单链表的第一个结点之前附设一个结点，称之为头结点。头结点的数据域可以不存储任何信息，也可存储如线性表的长度等类的附加信息，头结点的指针域存储指向第一个结点的指针(即第一个元素结点的存储位置)。如图2．7(a)所示，此时，单链表的头指针指向头结点。若线性表为空表，则头结点的指针域为“空”，如图2．7(b)所示。
图2．7带头结点的单链表
  (a)非空表；(b)空表。
　　在线性表的顺序存储结构中，由于逻辑上相邻的两个元素在物理位置上紧邻，则每个元素的存储位置都可从线性表的起始位置计算得到。而在单链表中，任何两个元素的存储位置之间没有固定的联系。然而，每个元素的存储位置都包含在其直接前驱结点的信息之中。假设p是指向线性表中第i个数据元素(结点ai)
　　①的指针，则p->next是指    ①结点ai指其数据域为ai的结点，而p结点则指指针p所指向的结点(即其存储位置存放在p中的结点)。以后均类同。
向第i+1个数据元素(结点ai+1)的指针。换句话说，若p->data=ai，则p->next->data=ai+1。由此，在单链表中，取得第i个数据元素必须从头指针出发寻找，因此，单链表是非随机存取的存储结构。下面我们看函数GetElem在单链表中的实现。
Staru8 GetElem―L(LinkList L，int i，ElemType＆e)l
    ∥L为带头结点的单链表的头指针。
    ∥当第i个元素存在时，其值赋给e并返回0K，否则返回ERROR
    p=L->next；j=1；    ∥初始化，p指向第一个结点，j为计数器
    while(p&&j<i){    ∥顺指针向后查找，直到p指向第i个元素或p为空
    p=p->next；++j；
    }
    if(!p¨>i)return ERROR；  ∥第i个元素不存在
    e=p->data；    ∥取第i个元素
    return OK：
I∥GetElem L
算法2．8
    算法2．8的基本操作是比较i和i并后移指针，while循环体中的语句频度与被查元素在表中位置有关，若1≤i≤表长挖，则频度为i一1，否则频度为n，因此算法2．8的时间复杂度为0(n)。
　　在单链表中，又如何实现“插入”和“删除”操作呢?
    假设我们要在线性表的两个数据元素a和b之间插入一个数据元素x，已知p为其单链表存储结构中指向结点。    图2．8在单链表中插入结点时指针变化状况的指针。如图2．8(a)所示。    (a)插入前；(b)插入后。
    为插入数据元素x，首先要生成一个数据域为x的结点，然后插入在单链表中。根据插入操作的逻辑定义，还需要修改结点a中的指针域，令其指向结点x，而结点x中的指针域应指向结点b，从而实现三个元素a，b和x之间逻辑关系的变化。插入后的单链表如图2．8(b)所示。假设s为指向结点x的指针，则上述指针修改用语句描述即为：
    s->next=p->next；  p->next=s；
    反之，如图2．9所示在线性表中删除元素b时，为在单链表中实现元素a、b和c之间    逻辑关系的变化，仅需修改结点a中的指针域即可。假设p为指向结点a的指针，则修改指针的语句为：
    p->next：=p->next->next；
　　图2．9在单链表中删除结点时指针    
　　可见，在已知链表中元素插入或删除的确切位置变化状况的情况下，在单链表中插入或删除一个结点时，仅需修改指针而不需要移动元素。算法2．9和算法2．10分别为ListInsert和ListDelete在单链表中的实现。
    starus ListInsert―L(LinkList&L，int i，ElemType e){
    ∥在带头结点的单链线性表L中第i个位置之前插入元素e
    P=L；  J：0；
    while(p&&J<i一1){P=P->next；十+J；}  ∥寻找第i一1个结点
    if(!P ll J>i一1)return ERROR；    ∥i小于1或者大于表长
    s=(LinkList)mallo=(sizeof(LNode))；    ∥生成新结点
    S->data=e；s->next=P->next；    ∥插入L中
    P->next=s：
    return OK；
    }∥I．instlnsert―L
算法2．9
Status ListDelete―L(LinkList＆L，int i，ElemType＆e){
    ∥在带头结点的单链线性表L中，删除第i个元素，并由e返回其值
    P=L；j=0；
    while(P->next＆＆J<i一1){  ∥寻找第i个结点，并令P指向其前趋
    P=P->next；  ++J；
    }
    if(!(p->next)f1 j>i一1)return ERROR；∥删除位置不合理
    q=P->next；P->next=q->next；    ∥删除并释放结点
    e=q->data；free(q)；
    return OK：  ‘
l∥ListDelete-L
    算法2．10
    容易看出，算法2．9和算法2．10的时间复杂度均为o(n)。这是因为，为在第i个结点之前插入一个新结点或删除第i个结点，都必须首先找到第i一1个结点，即需修改指针的结点，从算法2．8的讨论中，我们已经得知，它的时间复杂度为O(n)。
    在算法2．9和2．10中，我们还分别引用了C语言中的两个标准函数malloc和free。通常，在设有“指针”数据类型的高级语言中均存在与其相应的过程或函数。假设P和q是LinkList型的变量，则执行P=(LinkList)malloe(sizeof(LNode))的作用是由系统生成一个LNode型的结点，同时将该结点的起始位置赋给指针变量p；反之，执行fr~(q)的作用是由系统回收一个LNode型的结点，回收后的空间可以备作再次生成结点时用。因此，单链表和顺序存储结构不同，它是一种动态结构。整个可用存储空间可为多个链表共同享用，每个链表占用的空间不需预先分配划定，而是可以由系统应需求即时生成。因此，建立线性表的链式存储结构的过程就是一个动态生成链表的过程。即从“空表”的初始状态起，依次建立各元素结点，并逐个插入链表。算法2．11是一个从表尾到表头逆向建立单链表的算法，其时间复杂度为0(n)。
void CreateList―L(LinkList&L，imt n){
    ∥逆位序输入n个元素的值，建立带表头结点的单链线性表L。
    L：(LinkList)malloc(slzeof(LNode))；
・  30・
  L->，aext=NULL；    ∥先建立一个带头结点的单链表
  for(i=n；i>0；--i){
    p=(LinkList)malfoe(sizeof(LNode))；  ∥生成新结点
    8canf(&p->data)；    ∥输入元素值
    p->next=L->next；L->next=p；    ∥插入到表头
  I
}∥CreateList―L
算法2．1l
    下面讨论如何将两个有序链表并为一个有序链表?
　　假设头指针为La和Lb的单链表分别为线性表LA和LB的存储结构，现要归并La和Lb得到单链表Lc，按照2．1节中算法MergeI．ist的思想，需设立三个指针pa、pb和pc，其中pa和pb分别指向La表和Lb表中当前待比较插入的结点，而pc指向Lc表中当前最后一个结点，若pa->data≤pb->data，则将pa所指结点链接到pc所指结点之后，否则将pb所指结点链接到pc所指结点之后。显然，指针的初始状态为：当LA和LB为非空表时，pa和pb分别指向La和Lb表中第一个结点，否则为空；pc指向空表Lc中的头结点。由于链表的长度为隐含的，则第一个循环执行的条件是pa和pb皆非空，当其中一个为空时，说明有一个表的元素已归并完，则只要将另一个表的剩余段链接在pc所指结点之后即可。由此得到归并两个单链表的算法，如算法2．12所示。
　　void MergeList―L(LinkList&La，LinkList&Lb，LinkList＆Lc){
    ∥已知单链线性表La和Lb的元素按值非递减排列。
    ∥归并La和Lb得到新的单链线性表【Jc，k的元素也按值非递减排列。
　　pa=La->next；  pb=I．b->next；
　　Lc=pc=La；    ∥用La的头结点作为Lc的头结点
    while(pa＆&pb){
    if(pa->data<=pb->data)j
    pc->next。pa；pc。pa；pa=pa->next；
    }
    else{pc->NeAt=pb；pc=pb：pb=pb->next；}  ．
    I
    pc->next=pa?pa：pb
    free(Lb)；
}∥MergeLi8t―L
∥插入剩余段
∥释放Lb的头结点
    算法2．12
    读者容易看出，算法2．12的时间复杂度和算法2．7相同，但空间复杂度不同。在归并两个链表为一个链表时，不需要另建新表的结点空间，而只需将原来两个链表中结点之间的关系解除，重新按元素值非递减的关系将所有结点链接成一个链表即可。
    有时，也可借用一维数组来描述线性链表，其类型说明，如下所示：
    ∥--…线性表的静态单链表存储结构-…-
    #defi∞MAXSIZE 1000  ∥链表的最大长度
    typ|def struct{
    ElemType data;
    int    cur；
    }component，SLinklist[MAXSIZE]；
这种描述方法便于在不设“指针”类型的高级程序设计语言中使用链表结构。在如上描述的链表中，数组的一个分量表示一个结点，同时用游标(指示器cur)代替指针指示结点在数组中的相对位置。数组的第零分量可看成头结点，其指针域指示链表的第一个结点。例如图2．10(a)中所示为和图2．6相同的线性表。这种存储结构仍需要预先分配一个较大的空间，但在作线性表的插入和删除操作时不需移动元素，仅需修改指针，故仍具有链式存储结构的主要优点。例如，图2．10(b)展示了图2．10(a)所示线性表在插入数据元素“SHI”和删除数据元素“ZHENG"之后的状况。为了和指针型描述的线性链表相区别，我们给这种用数组描述的链表起名叫静态链表。
    图2．10静态链表示例
(a)修改前的状态；(b)修改后的状态。
    假设s为SLinkList型变量，则s[0]．cur指示第一个结点在数组中的位置，若设i=s[0]．cur，则s[i]．data存储线性表的第一个数据元素，且s[i]．cur指示第二个结点在数组中的位置。一般情况，若第j个分量表示链表的第七个结点，则s[i]．cur指示第k+1个结点的位置。因此在静态链表中实现线性表的操作和动态链表相似，以整型游标i代替动态指针p，i=s[i]．cur的操作实为指针后移(类似于p=p->next)，例如，在静态链表中实现的定位函数LocateElem如算法2．13所示。
int LocateElem―sL(SLinkLJ．st s，El~Type e){    ，
    ∥在静态单链线性表L中查找第1个值为e的元素。
    ∥若找到，则返回它在L中的位序。否则返回0。
    i=s[0]．Cttr；    ∥i指示表中第一个结点
    曲ile(i&&s[i]．data!=e)i=s[i]．cur-；    ∥在表中顺链查找
    return  i；
l∥LocateEl锄一sL
    算法2．13
    类似地可写出在静态链表中实现插入和删除操作的算法。从图2j 10的例子可见，指针修改的操作和前面描述的单链表中的插入和删除的算法2．9，2．10类似，所不同的是，需由用户自己实现mall~和free这两个函数。为了辨明数组中哪些分量未被使用，解决的办法是将所有未被使用过以及被删除的分量用游标链成一个备用的链表，每当进行插入时便可从备用链表上取得第一个结点作为待插入的新结点；反之，在删除时将从链表中删除下来的结点链接到备用链表上。
    现以集合运算(A―B)U(B―A)为例来讨论静态链表的算法。
    例2．3假设由终端输入集合元素，先建立表示集合A的静态链表s，而后在输入集合B的元素的同时查找s表，若存在和B相同的元素，则从s表中删除之，否则将此元素插入S表。
    为使算法清晰起见，我们先给出三个过程：1)将整个数组空间初始化成一个链表；2)从备用空间取得一个结点；3)将空闲结点链结到备用链表上，分别如算法2．14，2．15和2．16所示。
void InitSpace―sL(sLir~List~space){
    ∥将一维数组space中各分量链成一个备用链表，space[O]．cur为头指针，
    ∥“0”表示空指针
    for(i=O；i<MAXSIZE一1；  ++i)space[1]．cur=i+1；
    space[MAXSIZE一1j．cur=0；
I∥InitSpace―SL
    算法2．14
    int Malloc―SL(SLinkList~space)l
    ∥若备用空间链表非空，则返回分配的结点下标，否则返回0
    i=space[0 J．cur；
    if(space[O]．cur)space[0]．cur=space[i]．cur；
    return i；
}∥Ma]．10c―sL
算法2．15
void Free―sL(sLinkList&space，int k){
    ∥将下标为k的空闲结点回收到备用链表
    space[k]．cur=space[0]．cur。；space[O]．cur：k；
l∥Free―sL
算法2．16
vold difference(SLinkList&space，int&s){
    ∥依次输入集合A和B的元素，在一维数组space中建立表示集合(A―B)U(B―A)
    ∥的静态链表，s为其头指针。假设备用空间足够大，space[0]．cur为其头指针。
    InitSpace―sL(space)；    ∥初始化备用空间
    s：Malloc―sL(space)；    ∥生成s的头结点
    r。s；    ∥r指向s的当前最后结点
    scanf(m，n)；    ∥输入A和B的元素个数
    for(j=1；j<=m；++j){    ∥建立集合A的链表
    i=Malloc―sL(space)；    ∥分配结点
    ・33  ・
  mzanf(space【i]．data)；
  space[r]．cur=i；r：i；
、}}for
space[r]．cur=0；
for(J=1；J<=n；++J)I
∥输入A的元素值
∥插入到表尾
∥尾结点的指针为空
∥依次输入B的元素，若不在当前表中，则插入，否则删除
    scanf(b)；P=s；k：space[S]．cur；∥k指向集合A中第一个结点
    wh／le(k!=space[r]．cur＆&space[k]．data!=b){∥在当前表中查找
    P=k；k=space[k]．cur；
    }∥while
    if(k==space[r]．cur){    ∥当前表中不存在该元素，插入在r所指结点之后，且r
    ∥的位置不变
    i=Malloc―sL(space)；
    space[i]．data=b；
    space[i]．cur=space[r]．cur；
    space[r]．cur=i；
    }∥if
    else{    ∥该元素已在表中，删除之
    space[p]．cur=space[k]．cur；
    Free―sL(space，k)；
    if(r s=k)r：p；    //若删除的是尾元素，则需修改尾指针
    }∥else
  }∥for
}//difference
算法2．17
    在算法2．17中，只有一个处于双重循环中的循环体(在集合A中查找依次输入的6)，其最大循环次数为：外循环n次，内循环m次，故算法2．17的时间复杂度为O(m・n)。
   图2．11运算前后的静态链表
    (a)表示A的链表s；  (b)表示(A―B)U(B―A)的链表s。
    图2．1l是算法2．17执行的示意图。假设集合A：(c，6，g，g，f，d)，B=(a，6，n，f)，则图2．1l(a)所示为输入集合A的元素之后建成的链表S和备用空间链表的状况，图2．11(b)所示为逐个输入集合B的元素并在链表s中依次插入n，删除6、插入n、删除后的状况。space[0]．cur为备用链表的头指针，r的值为7。
  2．3．2循环链表 
  循环链表((2ircular Linked I．ist)是另一种形式的链式存储结构。它的特点是表中最后一个结点的指针域指向头结点，整个链表形成一个环。由此，从表中任一结点出发均可找到表中其它结点，如图2．12所示为单链的循环链表。类似地，还可以有多重链的循环链表。
图2．12单循环链表
(a)非空表；(b)空表。
    循环链表的操作和线性链表基本一致，差别仅在于算法中的循环条件不是p或p->next是否为空，而是它们是否等于头指针。但有的时候，若在循环链表中设立尾指针而不设头指针(如图2．13(a)所示)，可使某些操作简化。例如将两个线性表合并成一个表时，仅需将一个表的表尾和另一个表的表头相接。当线性表以图2．13(a)的循环链表作存储结构时，这个操作仅需改变两个指针值即可，运算时间为O(1)。合并后的表如图2．13(b)所示。
2．3．3双向链表
图2．13仅设尾指针的循环链表
(a)两个链表；  (b)合并后的表。
　　以上讨论的链式存储结构的结点中只有一个指示直接后继的指针域，由此，从某个结点出发只能顺指针往后寻查其它结点。若要寻查结点的直接前趋，则需从表头指针出发。换句话说，在单链表中，NextElem的执行时间为0(1)，而PriorElem的执行时间为O(n)。为克服单链表这种单向性的缺点，可利用双向链表(I)ouble Linked L,ist)。
　　顾名思义，在双向链表的结点中有两个指针域，其一指向直接后继，另一指向直接前趋，在c语言中可描述如下：
    ∥----一线性表的双向链表存储结构…--
txr~,aee 8truct DuLNode{
    ElemType data：
    struct DuLNode    。prior；
    struct DuLNode    *next；
    I DuL~ode，*DuLinkList；
　　和单链的循环表类似，双向链表也可以有循环表，如图2．14(c)所示，链表中存有两个环，图2．14(b)所示为只有一个表头结点的空表。在双向链表中，若d为指向表中某一
    图2．14双向链表示例
    (a)结点结构；  (b)空的双向循环链表；  (c)非空的双向循环链表。
结点的指针(即：d为DuLinkI．ist型变量)，则显然有  d->next->priou=d->priou->next=d这个表示式恰当地反映了这种结构的特性。
    在双向链表中，有些操作如：ListLength、GetElem和LocateElem等仅需涉及一个方向的指针，则它们的算法描述和线性链表的操作相同，但在插入、删除时有很大的不同，在双向链表中需同时修改两个方向上的指针，图2．15和图2．16分别显示了删除和插入结点时指针修改的情况。它们的算法分别如算法2．19和2．18所示，两者的时间复杂度均为O(n)。
图2．15在双向链表中删除结点时指针变化状况
图2．16在双向链表中插入一个结点时指针的变化状况
Status Listlnsert―DuL(DuLinkList＆L，int i，ElemType e)l
    ∥在带头结点的双链循环线性表L中第i个位置之前插入元素e，
    ∥i的合法值为1≤i≤表长+l。
    if(!(P=GetElemP―DuL(L，i)))∥在L中确定第i个元素的位置指针P
    return ERROR；    ／／P=NULL，即第i个元素不存在
    if(!(S：(DuLinkList)malloc(sizeof(DuLNode))))return ERROR；
    S->data=e：
    s->prior=P->prior；P->prior->next=S：
    ￡->next=p；P->prior：S；
    return OK；
}Listlnsert―DuL
   ・    算法2．18
Status ListDelete―DuL(DuLinkList&L，int i，ElemType＆e){
    ∥删除带头结点的双链循环线性表L的第i个元素，i的合法值为1≤i≤表长
    if(!(P=GetElemP―D、1L(L，i)))∥在L中确定第i个元素的位置指针P
    return ERROR；    ∥P=NUlL，即第i个元素不存在
    e：P->data：
    P->prior->next=P->next；
    P->next->prior：P->prior：
    ~ree(p)；  return OK；
}ListDelete―DuL
算法2．19
    从本节(2．3)的讨论中可见，由于链表在空间的合理利用上和插入、删除时不需要移动等的优点，因此在很多场合下，它是线性表的首选存储结构。然而，它也存在着实现某些基本操作如求线性表的长度时不如顺序存储结构的缺点；另一方面，由于在链表中，结点之间的关系用指针来表示，则数据元素在线性表中的“位序”的概念已淡化，而被数据元素在线性链表中的“位置”所代替。为此，从实际应用角度出发重新定义线性链表及其基本操作。
    一个带头结点的线性链表类型定义如下：
    tn~de~struct LNode{∥结点类型
    ElemType data；
    struct LNode    *next；
    I*Link，*Position；
tn~4e~struct{    ∥链表类型
    Link head，tail；  ∥分别指向线性链表中的头结点和最后一个结点
    int len；    ∥指示线性链表中数据元素的个数
}LinkList；
Status MakeNode(Link＆p，ElemType e)；
    ∥分配由P指向的值为e的结点，并返回OK；若分配失败，则返回ERROR
voi4 FreeNode(Link&p)；
    ∥释放P所指结点    、
Status InitList(LinkList&L)；
    ∥构造一个空的线性链表L
Status DestroyList(LinkList&L)；
    ∥销毁线性链表L，L不再存在
Status ClearList(LiakList&L)；
    ∥将线性链表L重置为空表，并释放原链表的结点空间
Status InsFirst(Link h，Link s)；
    ∥已知h指向线性链表的头结点，将s所指结点插入在第一个结点之前
Status DelFirst(Link h，L／nk&q)；
    ∥已知h指向线性链表的头结点，删除链表中的第一个结点并以q返回
Status Append(LinkList＆L，Link s)；
    ∥将指针s所指(彼此以指针相链)的一串结点链接在线性链表L的最后一个结点
    ∥之后，并改变链表L的尾指针指向新的尾结点
    Status Remove(LinkList&L，Link&q)；
    ∥删除线性链表L中的尾结点并以q返回，改变链表L的尾指针指向新的尾结点
    Status InsBefore(LinkList&L，Link&P，Link s)；
    ∥已知P指向线性链表L中的一个结点，将s所指结点插入在P所指结点之前，
    ∥并修改指针p指向新插入的结点    ’
    Status InsAfter(LinkList&L，Link&p，Link s)；
    ∥已知P指向线性链表L中的一个结点，将s所指结点插入在P所指结点之后，
    ∥并修改指针P指向新插入的结点
    Status SetCurElem(Li咄＆P，ElemType e)；
    ∥已知P指向线性链表中的一个结点，用e更新P所指结点中数据元素的值
    ElaTn~GetCurElem(Link P)；
    ∥已知P指向线性链表中的一个结点．返回P所指结点中数据元素的值
    Status ListEmpty(LinkList L)；
    ∥若线性链表L为空表，则返回TRUE，否则返回FALSE
    int ListLength(LinkList L)；
    ∥返回线性链表L中元素个数
    Position GetHead(LinkList L)；
    ∥返回线性链表L中头结点的位置
    Position GetLast(LinkList L)；
    ∥返回线性链表L中最后一个结点的位置
    Position PriorPos(LinkList L，Link P)；
    ∥已知p指向线性链表L中的一个结点，返回p所指结点的直接前驱的位置，
    ∥若无前驱，则返回NULL
    Position NextPos(LinkList L，Link P)；
    ∥已知P指向线性链表L中的一个结点，返回p所指结点的直接后继的位置。
    ∥若无后继，则返回NULL
    Status LocatePos(LinkList L，int i，Link＆P)；
    ∥返回P指示线性链表L中第i个结点的位置并返回0K，i值不合法时返回ERROR
    Position LocateElem(LinkList L，ElemType e，Status(*compare)(ElemType，ElemType))；
    ∥返回线性链表L中第1个与e满足函数compare()判定关系的元素的位置，
    ∥若不存在这样的元素，则返回NULL
    Status ListTraverse(LinkList L，Status(*visit)())；
    ∥依次对L的每个元素调用函数visit()。一旦visit()失败，则操作失败。
    在上述定义的线性链表的基本操作中，除了DestroyList，ClearList，Remove，InsBefore，PriorPos，LocatePos，LocateElem和ListTraverse的时间复杂度和表长成正比之外，其它操作的时间复杂度都和表长无关，Append操作的时间复杂度则和插入的结点数成正比。利用这些基本操作，容易实现诸如在第i个元素之前插入元素或删除第i个元素或合并两个线性表等操作，如算法2．20和2．21所示。
Status ListInsert―L(LinkList＆L，int i，ElemType e){
    ∥在带头结点的单链线性表L的第i个元素之前插入元素e
    if(!LocatePos(L，i一1，h))return ERROR；∥i值不合法
    if(!MakeNode(s，e))return ERROR；    ／／结点存储分配失败
    InsFirst(h，s)；  ∥对于从第i个结点开始的链表，第i一1个结点是它的头结点
    return OK；
算法2 20
Status MergeList(LinkList &La, LinkList &Lb, LinkList &Lc)
    ∥已知单链线性表b和Lb的元素按值非递减排列。
    ∥归并La和Lb得到新的单链线性表Lc，c的元索也按值非递减排列。
    if(!InitList(Lc))  return ERROR；    ∥存储空间分配失败
    ha=GetHead(La)；hb=GetHead(Lb)；∥ha和hb分别指向La和Lb的头结点
    pa=Nexts(h，ha)；pb=NextPos(Lb，11b)；∥pa和pb分别指向b和Lb中当前结点
    while(pa&＆pb){    ∥a和b均非空
    a=GetCurElm(pa)；b=etrBl(pb)；∥a和b为两表cp当前比较元素
    if((…pe)(a，b)<=0){／／≤b
  DelFirst(ha，q)；
eLse{    ∥a>b
  DelFirst(hb，q)；
／／while
Append(k，q)；pa：NextPoS(La．
Append(Lc．q)；pb=NexLPes(Lb，pb
  if(paj Append(k，a)．
  else^ppld(k，pb)；
  FreeNode(ha)；  F…0de(hb
∥MergeList L
∥链接La中剩余结点
∥链接Lb中剩余结点
∥释放h和Lb的头结点
    算法2、2l
    算法2 20和算法2 21分别为算法2 9和算法2 12的改写形式．它们的时间复杂度和前面讨论相同。
2 4一元多项式的表示及相加
    符号多项式的操作，已经成为表处理的典型用例。在数学上，一个一元多项式P。(。)
可按升幂写成：
    P(x)=p0+p1x+…+pnxx
它由n+1个系数唯一确定。因此，在计算机里，它可用一个线性表P来表示：
    P=(p0，pl，p2，  ，p。)
每一项的指数t隐含在其系数A的序号里。
    假设0。(z)是一元m次多项式，同样可用线性表Q来表示
    P=(ql JI ql，g2，  ，q。)
不失一般性，设m<n，则两个多项式相加的结果R。(。)：P。(z)+Q，。(z)可用线性表R表示：
    显然，我们可以对P、Q和R采用顺序存储结构，使得多项式相加的算法定义十分简洁。至此，一元多项式的表示及相加问题似乎已经解决了。然而，在通常的应用中，多项式的次数可能很高且变化很大，使得顺序存储结构的最大长度很难确定。特别是在处理形如    S(z)=1+3zi0000+2．／：20000的多项式时，就要用一长度为20001的线性表来表示，表中仅有三个非零元素，这种对内存空间的浪费是应当避免的，但是如果只存储非零系数项则显然必须同时存储相应的指数。
    一般情况下的一元n次多项式可写成
其中，A是指数为q的项的非零系数，且满足
若用一个长度为m且每个元素有两个数据项(系数项和指数项)的线性表
    ((p1，e1)，(p2，P2)，…，(p。，P。))    (2―8)
便可唯一确定多项式P。(z)。在最坏情况下，n+1(：m)个系数都不为零。则比只存储每项系数的方案要多存储一倍的数据。但是，对于s(z)类的多项式，这种表示将大大节省空间。
    对应于线性表的两种存储结构，由式(2．8)定义的一元多项式也可以有两种存储表示方法。在实际的应用程序中取用哪一种，则要视多项式作何种运算而定。若只对多项式进行“求值”等不改变多项式的系数和指数的运算，则采用类似于顺序表的顺序存储结构即可，否则应采用链式存储表示。本节中将主要讨论如何利用线性链表的基本操作来实现一元多项式的运算。
  抽象数据类型一元多项式的定义如下：
ADT Polynomial{
    数据对象：D={ail ai∈TermSet，i=1．2，…，m，  m≥0
    TermSet中的每个元素包含一个表示系数的实数和表示指数的整数}
    数据关系：R1={<ai一1，ai>Iai一1，ai∈D，且ai―l中的指数值<ai中的指数值，i=2，…，n}
    基本操作：
    creatPoyn(＆P，m)
    操作结果：输入m项的系数和指数，建立一元多项式P。
    DestroyPolyn(＆P)
    初始条件：一元多项式P已存在。
    操作结果：销毁一元多项式P。
    PrintPolyn(P)
    初始条件：一元多项式P已存在。
    操作结果：打印输出一元多项式P。
    Po]y~Length(P)
    初始条件：一元多项式P已存在。
    操作结果：返回一元多项式P中的项数。
    AddPolyn(＆Pa，&Pb)
    初始条件：一元多项式Pa和Pb已存在。
  操作结果：完成多项式相加运算，即：Pa=Pa+Pb，并销毁一元多项式Pb。
    SubtractPolyn(&Pa，&Pb)
  初始条件：一元多项式Pa和Pb已存在。
  操作结果：完成多项式相减运算，即：Pa=Pa―Pb，并销毁一元多项式Pb。
    Mul’tiplyPolyn(&Pa，＆Pb)
  初始条件：一元多项式Pa和Pb已存在。
  操作结果：完成多项式相乘运算，即：Pa=Pa×Pb，并销毁一元多项式Pb。
}KDT Polynomial
    实现上述定义的一元多项式，显然应采用链式存储结构。例如，图2．17中的两个线性链表分别表示一元多项式A17(z)=7+3z+9z。+5z"和一元多项式B8(z)=8z+9z。。从图中可见，每个结点表示多项式中的一项。
图2．17多项式表的单链存储结构
    如何实现用这种线性链表表示的多相式的加法运算?
    根据一元多项式相加的运算规则：对于两个一元多项式中所有指数相同的项，对应指数相加，若其和不为零，则构成“和多项式”中的一项；对于两个一元多项式中所有指数不相同的项，则分别复抄到“和多项式”中去。
    在此，按照上述抽象数据类型Polynomial中基本操作的定义，“和多项式”链表中的结点无需另生成，而应该从两个多项式的链表中摘取。其运算规则如下：假设指针qa和qb分别指向多项式A和多项式B中当前进行比较的某个结点，则比较两个结点中的指数项，有下列三种情况：1)指针qa所指结点的指数值<指针qb所指结点的指数值，则应摘取qa指针所指结点插入到“和多项式”链表中去；2)指针qa所指结点的指数值>指针qb所指结点的指数值，则应摘取指针qb所指结点插入到“和多项式”链表中去；3)指针qa所指结点的指数值=指针qb所指结点的指数值，则将两个结点中的系数相加，若和数不为零，则修改qa所指结点的系数值，同时释放qb所指结点；反之，从多项式A的链表中删除相应结点，并释放指针qa和qb所指结点。例如，由图2．17中的两个链表表示的多项式相加得到的“和多项式”链表如图2．18所示，图中的长方框表示已被释放的结点。
    图2．18相加得到的和多项式
    上述多项式的相加过程和上一节讨论的归并两个有序表的过程极其类似，不同之处仅在于，后者在比较数据元素时只出现两种情况。因此，多项式相加的过程亦完全可以利用线性链表的基本操作来完成。
    需要附加说明的是，在2．3节末定义的线性链表类型适用于一般的线性表，而表示一元多项式的应该是有序链表。有序链表的基本操作定义与线性链表有两处不同，一是LocateElem的职能不同，二是需增加按有序关系进行插入的操作Orderlnsert，现说明如下：
st|tua LocateRlem(LinkList L，ElemTy~e e，Position・&q，
    int(*compare)(ElemType，El))；
    ∥若有序链表L中存在与e满足判定函数colnpare()取值为0的元素，则q指示L中第一个//值为e的结点的位置，并返回。rR【『E；否则q指示第一个与e满足判定函数compare()取    ∥值>0的元素的前驱的位置，并返回FALSE
Status OrderInsert(LinkList＆L，ElemType e，int(*compare)(ElemType，ElemType))；
    ∥按有序判定函数compare()的约定，将值为e的结点插入到有序链表L的适当位置上
例2-4抽象数据类型Polynomial的实现。
Typedef struct{  ∥项的表示，多项式的项作为LinkList的数据元素
    float coef；    ∥系数
    int  expn；    ∥指数
}term，ElemType；  ∥两个类型名：term用于本ADT，ElemType为LinkList的数据对象名
typedef LinkList polynomial；    ∥用带表头结点的有序链表表示多项式
    ∥-…-基本操作的函数原型说明-…-
void CreatPolyn(polynomail＆P，int m)；
    ∥输入m项的系数和指数，建立表示一元多项式的有序链表P
 void DestroyPolyn(polynomail＆P)；
    ∥销毁一元多项式P
 void PrintPolyn(polynomail P)；
    ∥打印输出一元多项式P
int PolynLength(polynomail P)；    
    ∥返回一元多项式P中的项数
void AddPolyn(polynomail＆Pa．polynomail&Pb)；
    ∥完成多项式相加运算，即：Pa=Pa+Pb，并销毁一元多项式Pb
 void SubtractPolyn(polynomail aPa，polynomail＆)；
    ∥完成多项式相减运算，即：Pa=Pa―Pb，并销毁一元多项式
void MultiplyPolyn(polynomail＆Pa，polynomail&Pb)；
    ∥完成多项式相乘运算，即：Pa=Pax Pb，并销毁一元多项式Pb
    ∥…--基本操作的算法描述(部分)----一
int cmp(term a，term b)；
    ∥依a的指数值<(或=)(或>)b的指数值，分别返回一1、0和+1
 void CreatPolyn(polyno,．all&P，int m)l
    ∥输入m项的系数和指数，建立表示一元多项式的有序链表P
    InitList(P)；h=GetHead(P)；
    e．coef=0．0；e．expn=一1；SetCurElem(h，e)；∥设置头结点的数据元素
    for(i：i；i<=m；++i)l  ∥依次输入m个非零项
    somsf(e．coef，e．expn)；
    if(!LocateElem(P，e，q，(*cmp)()))I  ∥当前链表中不存在该指数项
・42・
    if(MakeNode(s，e))InsFirst(q，S)；  ∥生成结点并插入链表
    }
    l
、ff CreatPolyn
算法2．22
void AddPolyn(polynomial＆Pa，polynomial&Ph)  I
    ∥多项式加法：Pa=Pa+Pb，利用两个多项式的结点构成“和多项式”。
    ha=GetHead(Pa)；hb=GetHead(Pb)；∥ha和hb分别指向Pa和Pb的头结点
    qa=NextPos(ha)；qb=NextPos(hb)；  ∥qa和qb分别指向Pa和Pb中当前结点
    while(!Empty(Pa)＆＆!Empty(Pb))j  ∥Pa和Pb均非空
    a=GetCurElem(qa)；b=GetCurElem(qb)；∥a和b为两表中当前比较元素
    switch(*cap(a，b)){
 ∥多项式PA中当前结点的指数值小
    ha。qa；qa=NextPos(Pa，qa)；hruk；    、
    case 0：    ∥两者的指数值相等
    sum。a．coef+b．coef：
    if(sum!=0．0){  ∥修改多项式PA中当前结点的系数值
    SetCurElem(qa，s11m)；ha=qa；  }
    el∞{∥删除多项式PA中当前结点
    DelFirst(ha，qa)；FreeNode(qa)；  I
    DelFirst(hb，qh)；Freeaode(qb)；qb=NextPos(Pb，hb)；
    qa=NextPos(Pa，ha)；break；
    ca∞1：    ∥多项式PB中当前结点的指数值小
    DelFirst(hb，qb)；  InsFirst(ha。qb)；
    qb=NextPos(Pb，hb)；    break；
    l∥switch
    }∥while
    if(!Empty(Pb))Append(Pa，qa)；    ∥链接Pb中剩余结点
    FreeNode(hb)：∥释放Pb的头结点
、?}AddPolyn
算法2．23
    两个一元多项式相乘的算法，可以利用两个一元多项式相加的算法来实现，因为乘法运算可以分解为一系列的加法运算。假设A(z)和B(z)为式(2―7)的多项式，则    M(z)：A(z)×B(z)    =A(z)×[b xz。1+b2z。2+…+6，其中，每一项都是一个一元多项式。