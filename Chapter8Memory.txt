
第8章动态存储管理
8．1  概  述
    在前面各章的讨论中，对每一种数据结构虽都介绍了它们在内存储器中的映象，但只是借助高级语言中的变量说明加以描述，并没涉及具体的存储分配。而实际上，结构中的每个数据元素都占有一定的内存位置，在程序执行的过程中，数据元素的存取是通过对应的存储单元来进行的。在早期的计算机上，这个存储管理的工作是由程序员自己来完成的。在程序执行之前，首先需将用机器语言或汇编语言编写的程序输送到内存的某个固定区域上，并预先给变量和数据分配好对应的内存地址(绝对地址或相对地址)。在有了高级语言之后，程序员不需要直接和内存地址打交道，程序中使用的存储单元都由逻辑变量(标识符)来表示，它们对应的内存地址都是由编译程序在编译或执行时进行分配。
    另一方面，当计算机是被单个用户使用时，那末整个内存除操作系统占用一部分之外，都归这个用户的程序使用(如PDP一1I／03的内存为32K字，系统占用4K，用户程序可用28K)。但在多用户分时并发系统中，多个用户程序共享一个内存区域，此时每个用户程序使用的内存就由操作系统来进行分配了。并且，在总的内存不够使用时，还可采用自动覆盖技术。
　　对操作系统和编译程序来说，存储管理都是一个复杂而又重要的问题。不同语言的编译程序和不同的操作系统可以采用不同的存储管理方法。它们采用的具体做法，读者将在后续课程――编译原理和操作系统中学习。本课程仅就动态存储管理中涉及的一些基本技术进行讨论。
　　动态存储管理的基本问题是系统如何应用户提出的“请求”分配内存?又如何回收那些用户不再使用而“释放”的内存，以备新的“请求”产生时重新进行分配?提出请求的用户可能是进入系统的一个作业，也可能是程序执行过程中的一个动态变量。因此，在不同的动态存储管理系统中，请求分配的内存量大小不同。通常在编译程序中是一个或几个字，而在系统中则是几千、几万，甚至是几十万。然而，系统每次分配给用户(不论大小)都是一个地址连续的内存区。为了叙述方便起见，在下面的讨论中，将统称已分配给用户使用的地址连续的内存区为“占用块”，称未曾分配的地址连续的内存区为“可利用空间块”或“空闲块”。
    显然，不管什么样的动态存储管理系统，在刚开工时，整个内存区是一个“空闲块”(在编译程序中称之为“堆”)。随着用户进入系统，先后提出存储请求，系统则依次进行分配。因此，在系统运行的初期，整个内存区基本上分隔成两大部分：低地址区包含若干占用块；高地址区(即分配后的剩余部分)是一个“空闲块”。例如图8．1(a)所示为依次给8个用户进行分配后的系统的内存状态。经过一段时间以后，有的用户运行结束，它所占用的内存区变成空闲块，这就使整个内存区呈现出占用块和空闲块犬牙交错的状态。如图8．1
    ・  1 93  ・
(b)所示。
    图8．1  动态存储分配过程中的内存状态
    (a)系统运行初期；  (b)系统运行若干时间之后
    假如此时又有新的用户进入系统请求分配内存，那么，系统将如何做呢?
    通常有两种做法：一种策略是系统继续从高地址的空闲块中进行分配，而不理会已分配给用户的内存区是否已空闲，直到分配无法进行(即剩余的空闲块不能满足分配的请求)时，系统才去回收所有用户不再使用的空闲块，并且重新组织内存，将所有空闲的内存区连接在一起成为一个大的空闲块。另一种策略是用户一旦运行结束，便将它所占内存区释放成为空闲块，同时，每当新的用户请求分配内存时，系统需要巡视整’。r内存区中所有空闲块，并从中找出一个“合适”的空闲块分配之。由此，系统需建立一张记录所有空闲块的“可利用空间表”，此表的结构可以是“目录表”，也可以是“链表”。如图8．2所示为某    25 000    39 000
O  10 000    31 000    59 000    99 999
    (a)
起始地址    内存块大小    使用情况
┏━━━━━━┳━━━━━━┳━━━━━┓
┃    10．000 ┃    15．000 ┃    空闲  ┃
┣━━━━━━╋━━━━━━╋━━━━━┫
┃    31．000 ┃    8．000  ┃    空闲  ┃
┣━━━━━━╋━━━━━━╋━━━━━┫
┃    59．000 ┃    41．000 ┃    空闲  ┃
┗━━━━━━┻━━━━━━┻━━━━━┛
    图8．2动态存储管理过程中的内存状态和可利用空间表
    (a)内存状态；(b)目录表；(c)链表。
系统运行过程中的内存状态及其两种结构的可利用空间表。其中图8．2(b)是目录表，表中每个表目包括三项信息：初始地址、空闲块大小和使用情况。图8．2(c)是链表，表中一个结点表示一个空闲块，系统每次进行分配或回收即为在可利用空间表中删除或插入一个结点。
    ・  】94・
下面将分别讨论利用不同策略进行动态存储管理的方法。
    8．2可利用空间表及分配方法
    这一节主要讨论利用可利用空间表进行动态存储分配的方法。目录表的情况比较简单，这类系统将在操作系统课程中作详细介绍，在此仅就链表的情况进行讨论。
    如上所述，可利用空间表中包含所有可分配的空闲块，每一块是链表中的一个结点。当用户请求分配时，系统从可利用空间表中删除一个结点分配之；当用户释放其所占内存时，系统即回收并将它插入到可利用空间表中。因此，可利用空间表亦称作“存储池”。根据系统运行的不同情况，可利用空间表可以有下列三种不同的结构形式：
    第一种情况是系统运行期间所有用户请求分配的存储量大小相同。对此类系统，通常的做法是，在系统开始运行时将归它使用的内存区按所需大小分割成若干大小相同的块，然后用指针链接成一个可利用空间表。由于表中结点大小相同，则分配时无需查找，只要将第一个结点分配给用户即可；同样，当用户释放内存时，系统只要将用户释放的空闲块插入在表头即可。可见，这种情况下的可利用空间表实质上是一个链栈。这是一种最简单的动态存储管理的方式，如第2章的“2．3．1线性链表”中的静态链表就是一例。
    第二种情况，系统运行期间用户请求分配的存储量有若干种大小的规格。对此类系统，一般情况下是建立若干个可利用空间表，同一链表中的结点大小相同。例如，某动态存储管理系统中的用户将请求分配2个字、4个字或8个字的内存块，则系统建立三个结点大小分别为3个字、5个字和9个字的链表，它们的表头指针分别为av2、av4和av8。如图8．3所示，每个结点中的第一个字设有链域(1ink)、标志域(tag)和结点类型域(type)。
其中：类型域为区别三种大小不同的结点而设，type的值为“0”、“1”或“2”，分别表示结点大小为2个字、4个字或8个字；标志域tag为“0”或“1”分别表示结点为空闲块或占用块；链域中存储指向同一链表中下一结点的指针，而结点中的值域是其大小分别为2、4和8个字的连续空间。此时的分配和回收的方法在很大程度上和第一种情况类似，只是当结
点大小和请求分配的量相同的链表为空时，需查询结点较大的链表，并从中取出一个结点，将其中一部分内存分配给用户，而将剩余部分插入到相应大小的链表中。回收时，也只要将释放的空闲块插入到相应大小的链表的表头中去即可。然而，这种情况的系统还有一个特殊的问题要处理：即当结点与请求相符的链表和结点更大的链表均为空时，分配不能进行，而实际上内存空间并不一定不存在所需大小的连续空间，只是由于在系统运行过程中，频繁出现小块的分配和回收，使得大结点链表中的空闲块被分隔成小块后插入在小结点的链表中，此时若要使系统能继续运行，就必须重新组织内存，即执行“存储紧缩”的操作。除此之外，上述这个系统本身的分配和回收的算法都比较简单，读者可自行写出。
    第三种情况，系统在运行期间分配给用户的内存块的大小不固定，可以随请求而变。因此，可利用空间表中的结点即空闲块的大小也是随意的。通常，操作系统中的可利用空间表属这种类型。
    系统刚开始工作时，整个内存空间是一个空闲块，即可利用空间表中只有一个大小为整个内存区的结点，随着分配和回收的进行，可利用空间表中的结点大小和个数也随之而变，上述图8．2(c)中的链表即为这种情况的可利用空间表。
    10空闲块
ng。{1占用块
    f0结点大小为2个字
type=<1结点大小为4个字
    12结点大小为8个字
    (a)
av2
av4
…
    图8．3有三种大小结点的可利用空间表
    ．，  (a)结点结构；  (b)可利用空间表。
    由于链表中结点大小不同，则结点的结构与前两种情况也有所不同，结点中除标志域和链域之外，尚需有一个结点大小域(size)，以指示空闲块的存储量，如图8．4所示。结点中的space域是一个地址连续的内存空间。
    I O空闲块
妇g。{1占用块
的大小随意的结点结构
    由于可利用空间表中的结点大小不同，则在分配时就有一个如何分配的问题。假设某用户需大小为n的内存，而可利用空间表中仅有一块大小为”的空闲块，则只需将其中大小为n的一部分分配给申请分配的用户，同时将剩余大小为m-n的部分作为一个结点留在链表中即可。然而，若可利用空间表中有若干个不小于”的空闲块时，该分配哪一块呢?通常，可有三种不同的分配策略：
    (1)首次拟合法。从表头指针开始查找可利用空间表，将找到的第一个大小不小于n的空闲块的一部分分配给用户。可利用空间表本身既不按结点的初始地址有序，也不按结点的大小有序。则在回收时，只要将释放的空闲块插入在链表的表头即可。例如，在图8．2(c)的状态时有用户U9进入系统并申请7K的内存，系统在可利用空间表中进行查询，发现第一个空闲块即满足要求，则将此块中大小为7K的一部分分配之，剩余8K的空闲块仍在链表中，如图8．5(a)所示。图8．5(d)为分配给用户的占用块。
　　(2)最佳拟合法。将可利用空间表中一个不小于咒且最接近n的空闲块的一部分分配给用户。则系统在分配前首先要对可利用空间表从头到尾扫视一遍，然后从中找出一块不小于n且最接近扎的空闲块进行分配。显然，在图8．2(c)的状态时，系统就应该将第二个空闲块的一部分分配给用户u。，分配后的可利用空间表如图8．5(b)所示。在用最佳拟合法进行分配时，为了避免每次分配都要扫视整个链表。通常，预先设定可利用空间表的结构按空间块的大小自小至大有序，由此，只需找到第一块大于，z的空闲块即可进行分配，但在回收时，必须将释放的空闲块插入到合适的位置上去。
    图8．5’结点大小随意的可利用空间表(a)按首次拟合原则进行分配；(b)按最佳拟合原则进行分配  (c)按最差拟合原则进行分配；(d)分配给用户的占用块：
    (3)最差拟合法。将可利用空间表中不小于咒且是链表中最大的空闲块的一部分分配给用户。例如在图8．2(c)的状态时，就应将大小为41K的空闲块中的一部分分配给用户，分配后的可利用空间表如图8．5(c)所示。显然，为了节省时间，此时的可利用空间表的结构应按空闲块的大小自大至小有序。这样，每次分配无需查找，只需从链表中删除第一个结点，并将其中一部分分配给用户，而剩余部分作为一个新的结点插入到可利用空间表的适当位置上去。当然，在回收时亦需将释放的空闲块插入到链表的适当位置上去。
    上述三种分配策略各有所长。一般来说，最佳拟合法适用于请求分配的内存大小范围较广的系统。因为按最佳拟合的原则进行分配时，总是找大小最接近请求的空闲块，由此系统中可能产生一些存储量甚小而无法利用的小片内存，同时也保留那些很大的内存块以备响应后面将发生的内存量特大的请求，从而使整个链表趋向于结点大小差别甚远的状态。反之，由于最差拟合每次都从内存量最大的结点中进行分配，从而使链表中的结点大小趋于均匀，因此它适用于请求分配的内存大小范围较窄的系统。而首次拟合法的分配是随机的，因此它介于两者之间，通常适用于系统事先不掌握运行期间可能出现的请求分配和释放的信息的情况。从时间上来比较，首次拟合在分配时需查询可利用空间表，而回收时仅需插入在表头即可；最差拟合恰相反，分配时无需查询链表，而回收时为将新的“空闲块”插入在链表中适当的位置上，需先进行查找；最佳拟合无论分配和回收，均需查找链表，因此最费时间。
    因此，不同的情景需采用不同的方法，通常在选择时需考虑下列因素：用户的逻辑要求；请求分配量的大小分布；分配和释放的频率以及效率对系统的重要性等等。
    在实际使用的系统中回收空闲块时还需考虑一个“结点合并”的问题。这是因为系统在不断进行分配和回收的过程中，大的空闲块逐渐被分割成小的占用块，在它们重又成为空闲块回收之后，即使是地址相邻的两个空闲块也只是作为两个结点插入到可利用空间表中，以致使得后来出现的大容量的请求分配无法进行，为了更有效地利用内存，就要求系统在回收时应考虑将地址相邻的空闲块合并成尽可能大的结点。换句话说，在回收空闲块时，首先应检查地址与它相邻的内存是否是空闲块。具体实现的方法将在下面两节中讨论的动态存储管理系统中加以详细说明。
8．3边界标识法
    边界标识法(boundary tag method)是操作系统中用以进行动态分区分配的一种存储管理方法，它属于上一节讨论中的第三种情况。系统将所有的空闲块链接在一个双重循环链表结构的可利用空间表中；分配可按首次拟合进行，也可按最佳拟合进行。系统的特点在于：在每个内存区的头部和底部两个边界上分别设有标识，以标识该区域为占用块或空闲块，使得在回收用户释放的空闲块时易于判别在物理位置上与其相邻的内存区域是否为空闲块，以便将所有地址连续的空闲存储区组合成一个尽可能大的空闲块。下面分别就系统的可利用空间表的结构及其分配和回收的算法进行讨论。
8．3．1可利用空间表的结构
可利用空间表中的结点结构如下所示
・  198・
它表示一个空闲块。整个结点由三部分组成。其中space为一组地址连续的存储单元，是可以分配给用户使用的内存区域，它的大小由head中的size域指示，并以头部head和底部foot作为它的两个边界；在head和foot中分别设有标志域tag，且设定空闲块中tag的值为“0”，占用块中tag的值为“1”；foot位于结点底部，因此它的地址是随结点中space空间的大小而变的。为讨论简便起见，我们假定内存块的大小以“字”为单位来计，地址也以“字”为单位来计，结点头部中的si‘ze域的值为整个结点的大小，包括头部head和底部foot所占空间，并假设head和foot各占一个字的空间，但在分配时忽略不计。
借助c语言，在此将可利用空间表的结点结构定义为如下说明的数据类型：
trpedef stz'uct WORD{    ∥WORD：内存字类型
  ur,ion{  ∥head和foot分别是结点的第一个字和最后的字
    WORD    *llink；    ∥头部域，指向前驱结点
    WORD    *uplill】c；    ∥底部域，指向本结点头部
  f；
  int tag；
  int    size；
  WORD    。rlink：
  0the―Type other；  -
}WORD，head，foot，*Space；
∥块标志，0：空闲，1：占用，头部和尾部均有。
∥头部域，块大小
∥头部域，指向后继结点
∥字的其它部分
∥*Space：可利用空间指针类型
    #define FootLoc(p)p’p一>size―l  ∥指向p所指结点的底部
    可利用空间表设为双重循环链表。head中的llink和rlink分别指向前驱结点和后继结点。表中不设表头结点，表头指针pav可以指向表中任一结点，即任何一个结点都可看成是链表中的第一个结点；表头指针为空，则表明可利用空间表为空。foot中的uplink域也为指针，它指向本结点，它的值即为该空闲块的首地址。例如图8．6(a)是一个占有100K内存空间的系统在运行开始时的可利用空间表。
8．3．2分配算法
    分配的算法比较简单，假设我们采用首次拟合法进行分配，则只要从表头指针pav所指结点起，在可利用空间表中进行查找，找到第一个容量不小于请求分配的存储量(，z)的空闲块时，即可进行分配。为了使整个系统更有效地运行，在边界标识法中还作了如下两条约定：
    (1)假设找到的此块待分配的空闲块的容量为仇个字(包括头部和底部)，若每次分配只是从中分配n个字给用户，剩余优一，z个字大小的结点仍留在链表中，则在若干次分配之后，链表中会出现一些容量极小总也分配不出去的空闲块，这就大大减慢了分配(查找)的速度。弥补的办法是：选定一个适当的常量e，当以≤e时，就将容量为m的空闲块整块分配给用户；反之，只分配其中咒个字的内存块。同时，为了避免修改指针，约定将该结点中的高地址部分分配给用户。
    (2)如果每次分配都从同一个结点开始查找的话，势必造成存储量小的结点密集在头指针pay所指结点附近，这同样会增加查询较大空闲块的时间。反之，如果每次分配从    图8．6某系统的可利用空间表
(a)初始状态；(b)运行若干时间后的状态；(c)进行再分配后的状态。
不同的结点开始进行查找，使分配后剩余的小块均匀地分布在链表中，则可避免上述弊病。实现的方法是，在每次分配之后，令指针pav指向刚进行过分配的结点的后继结点。
    例如，图8．6(b)所示可利用空间表在进行分配之后的状态如图8．6(c)所示。
    算法8．1是上述分配策略的算法描述。  ‘
    sP蛳e AllocBoundTag(space&pav，Ant n){
    ∥若有不小于n的空闲块，则分配相应的存储块，并返回其首地址；否则返回    ∥NULL。若分配后可利用空间表不空，则pay指向表中刚分配过的结点的后继    n锗蒹
    for(p=pav；p＆＆p～>size<n＆＆p一>rlink!：pay；
    p=p一>rlink)；    ∥查找不小于n的空闲块
    if(!p 1I p一>size<n)return NULL；    ∥找不到，返回空指针
    el的{    ∥p指向找到的空闲块
    f。FootLoc(p)；    ∥指向底部
    pay。p一>rlink；    ∥pay指向*p结点的后继结点。
    if(p一>size―n<=e){    ∥整块分配，不保留<=e的剩余量
    if(paV=p)pay=~PULL；    ∥可利用空间表变为空表
    else{    ∥在表中删除分配的结点
    pay一>llink=p一>llink；  p一>llink一>rlink=pav；
    }∥if
∥修改分配结点的头部和底部标志
田L
：
明
t
>
一
f
=
∞
七
>
一  f
p肚
    O
    O
    2
else{
  f一>tag=1：
  p一>size一=n；
  f=Footr~c(p)：
    f一>tag=0：
    p；f+1；
    p一>tag=1；
    l
  return p；
  }∥else
}∥AuocBoundTag
f一>uplink=p；
∥分配该块的后n个宇
∥修改分配块的底部标志
∥置剩余块大小
∥指向剩余块底部
∥设置剩余块底部
∥指向分配块头部
∥设置分配块头部
∥返回分配块首地址
算法8．1
    8．3．3回收算法
    一旦用户释放占用块，系统需立即回收以备新的请求产生时进行再分配。为了使物理地址毗邻的空闲块结合成一个尽可能大的结点，则首先需要检查刚释放的占用块的左、右紧邻是否为空闲块。由于本系统在每个内存区(无论是占用块或空闲块)的边界上都设有标志值，则很容易辨明这一点。
    假设用户释放的内存区的头部地址为p，则与其低地址紧邻的内存区的底部地址为p一1；与其高地址紧邻的内存区的头部地址为p+p>size，它们中的标志域就表明了这两个邻区的使用状况：若(p1)>tag：O；则表明其左邻为空闲块，若(p+p>size)>。tag=0；则表明其右邻为空闲块。
    若释放块的左、右邻区均为占用块，则处理最为简单，只要将此新的空闲块作为一个结点插入到可利用空闲表中即可；若只有左邻区是空闲块，则应与左邻区合并成一个结点；若只有右邻区是空闲块，则应与右邻区合并成一个结点；若左、右邻区都是空闲块，则应将三块合起来成为一个结点留在可利用空间表中，下面我们就这四种情况分别描述它们的算法：
    (1)释放块的左、右邻区均为占用块。此时只要作简单插入即可。由于边界标识法在按首次拟合进行分配时对可利用空间表的结构没有任何要求，则新的空闲块插入在表中任何位置均可。简单的做法就是插入在pay指针所指结点之前(或之后)，可描述如下：    p>’tag=0；  FootLoc(p)>uplink：p；  Foo~oc(p)>tag=0；
    if(!pav)pav=p>llink=p>rlink=p；
    else{q=pay>llink；
    p>rlink=pay；  p一>llink=q；
    q>rlink=payllink：p；
    pay=p；    ∥令刚释放的结点为下次分配时的最先查询的结点
    }
    (2)释放块的左邻区为空闲块，而右邻区为占用块。由于释放块的头部和左邻空闲块的底部毗邻，因此只要改变左邻空闲块的结点：增加结点的size域的值且重新设置结点的底部即可。描述如下：
∥释放块的大小
    ・201・
    s：(p1)>uplink；    ∥左邻空闲块的头部地址
    s>size+=n；    ∥设置新的空闲块大小
    f=p+n1；  f>uplink=s；  f>tag=0；    ∥设置新的空闲块底部
    (3)释放块的右邻区为空闲块，而左邻区为占用块。由于释放块的底部和右邻空闲块的头部毗邻，因此，当表中结点由原来的右邻空闲块变成合并后的大空闲块时，结点的底部位置不变，但头部要变，由此，链表中的指针也要变。描述如下：
t=p’p一>size；    ∥右邻空闲块的头部地址
p一>tag=0；    ∥p为合并后的结点头部地址
q=t一>ui呔；    ∥q为*t结点在可利用空间表中的前驱结点的头部地址
p一>uin】c：q；  q一>rlink=p；    ∥q指向”p的前驱
q1=t一>rlink；    ∥q1为*t结点在可利用空间表中的后继结点的头部地址
p一>rlink=q1；  q1一>llink=p；    ∥ql指向。p的后继
p一>size+=t一>size；    ∥新的空闲块的大小
FootLoc(t)一>uplink=p；    ∥底部指针指向新结点的头部
    图8．7  回收存储块后的可利用空间表
(a)释放的存储块；    (b)左邻区是空闲块的情况；
(c)右邻区是空闲块的情况；(d)左、右邻区均是空闲块的情况。
    (4)释放块的左、右邻区均为空闲块。为使三个空闲块连接在一起成为一个大结点留在可利用空间表中，只要增加左邻空闲块的space容量，同时在链表中删去右邻空闲块结点即可。所作改变可描述如下：
n=p>size
・202・
∥释放块的大小
s=(p1)>uplink；
t=p+p>size；
s>size+：n+t>size：
q=t>llink；    q1=t>rlink；
q>rlink：q1；  q1>llink：q；
FootLoc(t)>upliI=s；
∥指向左邻块
∥指向右邻块
∥设置新结点的大小
∥q!=ql
∥删去右邻空闲块结点
∥新结点底部指针指向其头部
    总之，边界标识法由于在每个结点的头部和底部设立了标识域，使得在回收用户释放的内存块时，很容易判别与它毗邻的内存区是否是空闲块，且不需要查询整个可利用空间表便能找到毗邻的空闲块与其合并之；再者，由于可利用空间表上结点既不需依结点大小有序，也不需依结点地址有序，则释放块插入时也不需查找链表。由此，不管是哪一种情况，回收空闲块的时间都是个常量，和可利用空间表的大小无关。唯一的缺点是增加了结点底部所占的存储量。
    在上述后三种情况下，可利用空间表的变化如图8．7所示。
8．4伙伴系统
    伙伴系统(Imddy system)是操作系统中用到的另一种动态存储管理方法。它和边界标识法类似，在用户提出申请时，分配一块大小“恰当”的内存区给用户；反之，在用户释放内存区时即回收。所不同的是：在伙伴系统中，无论是占用块或空闲块，其大小均为2的走次幂(志为某个正整数)。例如；当用户申请咒个字的内存区时，分配的占用块大小为2‘个字(2卜’<n≤2‘)。由此，在可利用空间表中的空闲块大小也只能是2的n次幂。若总的可利用内存容量为2”个字，则空闲块的大小只可能为20、2’、…、2”。下面我们仍和上节一样，分三个问题来介绍这个系统。
8．4．1可利用空间表的结构
    假设系统的可利用内存空间容量为2”个字(地址从0到2”一1)，则在开始运行时，整个内存区是一个大小为2”的空闲块，在运行了一段时间之后，被分隔成若干占用块和空闲块。为了再分配时查找方便起见，我们将所有大小相同的空闲块建于一张子表中。每个子表是一个双重链表，这样的链表可能有m+1个，将这优+1个表头指针用向量结构组织成一个表，这就是伙伴系统中的可利用空间表。
    双重链表中的结点结构如图8．8(a)所示，其中head为结点头部，是一个由四个域组成的记录，其中的11ink域和rlink域分别指向同一链表中的前驱和后继结点；tag域为值取“0”“1”的标志域，kval域的值为2的幂次忌；space是一个大小为2‘一1个字的连续内存空间(和前面类似，仍假设head占一个字的空间)。
可利用空间表的初始状态如图8―8(b)所示，其中优个子表都为空表，只有大小为2m的链表中有一个结点，即整个存储空间。表头向量的每个分量由两个域组成，除指针域外另设nodesize域表示该链表中空闲块的大小，以便分配时查找方便。此可利用空间表的数据类型，示意描述如下：
#define m 16
∥可利用空间总容量64K字的2的幂次，子表的个数为m+1
    ・203・
typed・f struct'唧IlD{
  WORD  *llink；    ∥指向前驱结点
  int tag；    ∥块标志，0：空闲，1：占用。
  int    kval；    ∥块大小，值为2的幂次k
  WORD    *rlink；    ∥头部域。指向后继结点
  ~herType other；    ∥字的其它部分
}WORD，head；    ∥WORD：内存字类型，结点的第一个字也称为head
tlqpe~f 8．zllctH_．d奠od・{
  int  nodesize；    ∥该链表的空闲块的大小
  WORD  *first；    ∥该链表的表头指针
IFreeList[m+1]；    ∥表头向量类型
    图8．8伙伴系统中的可利用空间表
(a)空闲块的结点结构；(b)表的初始状态；(c)分配前的表；(d》分配后的表。
8．4．2分配算法
    当用户提出大小为咒的内存请求时，首先在可利用表上寻找结点大小与n相匹配的子表，若此子表非空，则将子表中任意一个结点分配之即可；若此子表为空，则需从结点更大的非空子表中去查找，直至找到一个空闲块，则将其中一部分分配给用户，而将剩余部分插入相应的子表中。
    假设分配前的可利用空间表的状态如图8．8(c)所示。若2k一。<，z≤2‘一1，又第k+1个子表不空，则只要删除此链表中第一个结点并分配给用户即可；若
2卜。<”≤2。I，此时由于结点大小为2。的子表为空，则需从结点大小为2k的子表  ・204・
中取出一块，将其中一半分配给用户，测余的一半作为    p一个新结点插入在结点大小为2卜’的子表中，如图8 8  
(d)所示。．若2。0<”≤2。1(z为小于^的整  卅步
数)，并H所有结点小于2‘的子裘均为空，则同样需从  结点大小为20的子表中取出一块，其中2“。的一小部分分配给用户，剩余部分分割成若干个结点分别插入大小为2’、2‘、、2‘的中。假设从第}1个子表中删除的结点的起始地址为p，且假设分配给用户的r用块的初始地址为p(占用块为该空闲块的低地址区)，则插入上述子表的新结点们起始地址分划为p}2‘、p’2…、  、p+2‘，如右圈所示(翻中i=3)。
    FmiJ=『]语言：
WORD b*A11。cBuday(FreeList＆avail，打E n)1
  ∥avail[0 m]为可利用空问袁，n为申请分配盟．若有不小于n的空闭块，
  ∥则分配的存储块，并返回其首地址；否则退回
  fo=(k=0，k<=m＆＆(avail[k]nodesize<n+1 l J!avail[k]first)；
    l}k)，    ∥查找满足分配要求的于采
  if(k>m)ret~n NULL；    ∥分配失败，返回Nul』l
  else{    ∥进行分配
    pa=avail[k]first；    ∥指向可分配子表的第一个结点
    pre=pa一>111nk……pa>rlink；∥分目4指向前驱和后继
    1f(pa…uc)avail[k]first=NULL；  ∥分配后该子表变成空表
    else f    ∥从子表删去*pa结点
   ∥将剩余块插人相应于表
8 4 3回收算法
算法8 2
  用户释放不冉使用的占用用块时，系统需将这新的空闲块插人到可利用空间表中去。这里,同样有一个地址相邻的空闲块归并成大块的问题。但是在伙伴系统中仅考虑互为“伙伴”的删个空闲块的归并。
  何谓”伙伴”如前所述，在分配时经常需要将一个大的空闲块分裂成两个大小相等的存储区，这两个由同一大块分裂出来的小块就称之“互为伙伴”。侧如：假设p为大小为2‘空闲块的初始地址：MOD 2“。’=0，则初始地址为p和pI 2‘的两个空闲块互为伙伴。在伙伴系统-…m收空闲块时，只当其伙伴为空闲块时才¨并成大块。也就是说，若有两个空闲块，即使大小相同且地址相邻，但不是由同一大块分裂出来的，也不归并在一起。例如图中的A、B两个空闲块不是伙伴。
    由此，在回收空闲块时，应首先判别其伙伴是否为空闲块，若否，则只要将释放的空闲块简单插入在相应子表中即可；若是，则需在相应子表中找到其伙伴并删除之，然后再判别合并后的空闲块的伙伴是否是空闲块。依此重复，直到归并所得空闲块的伙伴不是空闲块时，再插入到相应的子表中去。
    起始地址为m，大小为2‘的内存块，其伙伴块的起始地址为：
例如，假设整个可利用内存区大小为2如=1024(地址从0到1023)，则大小为2。，起始地址为512的伙伴块的起始地址为’768；大小为2’，起始地址为384的伙伴块的起始地址为.
    整个释放算法在此不再详细列出，请读者自行补充。
    总之，伙伴系统的优点是算法简单、速度快；缺点是由于只归并伙伴而容易产生碎片。
8．5无用单元收集
    以上三节讨论的问题都是如何利用可利用空间表来进行动态存储管理。它的特点是：在用户请求存储时进行分配；在用户释放存储时进行回收，即系统是应用户的需求来进行存储分配和回收的。因此，在这类存储管理系统中，用户必须明确给出“请求”和“释放”的信息。如在多用户分时并发的操作系统中，当用户程序进入系统时即请求分配存储区；反之，当用户程序执行完毕退出系统时即释放所占存储。又如，在使用c语言编写程序时，用户是通过malloc和free两个函数来表示请求分配和释放存储的。但有时会因为用户的疏漏或结构本身的原因致使系统在不恰当的时候或没有进行回收而产生“无用单元”或“悬挂访问”的问题。
    “无用单元”是指那些用户不再使用而系统没有回收的结构和变量。例如下列c程序段
p：maltoe(size)；
p：NJI~；
执行的结果，是使执行p=malloc(size)为用户分配的结点成为无用单元，无法得到利用；而下列程序段p。Ⅻlloc(size)；
q=p；
・206・
执行的结果使指针变量q悬空，如果所释放的结点被再分配而继续访问指针q所指结点，则称这种访问为“悬挂访问”，并且由此引起的恶劣后果是可想而知的。
    另一方面，由于结构本身的某些特性，也会产生同上类似问题。
    例如在某用户程序中有三个广义表结构，如图8．9所示，L，、L2和L3分别为它们的表头指针，L4是L，和k共享的子表，b本身又为k共享，则L5为三个广义表所共享。
图8．9含有共享子表的广义表
在这种情况下，表结点的释放就成为一个问题。假设表L，不再使用，而表k和L3尚在使用，若释放表L】，即自L】指针起，顺链将所有结点回收到可利用空间表中(包括子表L4和L，上所有结点)，这就破坏了表k和L3，从而产生“悬挂访问”；反之，若不将表L。中结点释放，则当k和L3两个表也不被使用时，这些结点由于未曾“释放”无法被再分配而成为“无用单元”。
    如何解决这个问题?有两条途径：
    (1)使用访问计数器：在所有子表或广义表上增加一个表头结点，并设立一个“计数域”，它的值为指向该子表或广义表的指针数目。只有当该计数域的值为零时，此子表或广义表中结点才被释放。
    (2)收集无用单元：在程序运行的过程中，对所有的链表结点，不管它是否还有用，都不回收，直到整个可利用空间表为空。此时才暂时中断执行程序，将所有当前不被使用的结点链接在一起，成为一个新的可利用空间表，而后程序再继续执行。显然，在一般情况下，是无法辨别哪些结点是当前未被使用的。然而，对于一个正在运行的程序，哪些结点正在使用是容易查明的，这只要从所有当前正在工作的指针变量出发，顺链遍历，那末，所有链结在这些链上的结点都是占用的。反之，可利用存储空间中的其余结点就都是无用的了。
    由此，收集无用单元应分两步进行：第一步是对所有占用结点加上标志。回顾第五章的广义表的存储结构可在每个结点上再加设一个标志(mark)域，假设在无用单元收集之前所有结点的标志域均置为“0”，则加上标志就是将结点的标志域置为“1”；第二步是对整个可利用存储空间顺序扫描一遍，将所有标志域为“0”的结点链接成一个新的可利用空间表。值得注意的是：上述第二步是容易进行的，而第一步是在极其困难的条件(即可利用存储几乎耗用殆尽)下进行的，因此，人们的精力主要集中在研究标志算法上。下面我们介绍三种标志算法。
    (1)递归算法从上面所述可知，加标志的操作实质上是遍历广义表，将广义表中所有结点的标志域赋值“1”。我们可写出遍历(加标志)算法的递归定义如下：
    若列表为空，则无需遍历；若是一个数据元素，则标志元素结点；反之，则列表非空，先标志表结点；然后分别遍历表头和表尾。
    这个算法很简单，易于用允许递归的高级语言描述之。但是，它需要一个较大的实现递归用的栈的辅助内存，这部分内存不能用于动态分配。并且，由于列表的层次不定，使得栈的容量不易确定，除非是在内存区中开辟一个相当大的区域留作栈，否则就有可能由于在标志过程中因栈的溢出而使系统瘫痪。
    (2)非递归算法程序中附设栈(或队列)实现广义表的遍历。从广义表的存储结构来看，表中有两种结点：一种是元素结点，结点中没有指针域；另一种是表结点，结点中包含两个指针域：表头指针和表尾指针，则它很类似于二叉树的二叉链表。列表中的元素结点相当于二叉树中的叶子结点，可以类似于遍历二叉树写出遍历表的非递归算法，只是在算法中应尽量减少栈的容量。
    例如，类似于二叉树的前序遍历，对广义表则为：当表非空时，在对表结点加标志后，先顺表头指针逐层向下对表头加标志，同时将同层非空且未加标志的表尾指针依次入栈，直到表头为空表或为元素结点时停止，然后退栈取出上一层的表尾指针。反复上述进行过程，直到栈空为止。这个过程也可以称作深度优先搜索遍历。因为它和图的深度优先搜索遍历很相似。
    显然，还可以类似于图的广度优先搜索遍历，对列表进行广度优先搜索遍历，或者说是对列表按层次遍历。同样，为实现这个遍历需附设一个队列(这两个算法和二叉树或图的遍历极为相似，故在此不作详细描述，读者完全可以自己写出)。在这两种非递归算法中，虽然附设的栈或队列的容量比递归算法中的栈的容量小，但和递归算法有同样的问题仍需要一个不确定量的附加存储，因此也不是理想的方法。
    (3)利用表结点本身的指针域标记遍历路径的算法无论是在递归算法中还是在深度优先搜索的非递归算法中，不难看出，设栈的目的都是为了记下遍历时指针所走的路径，以便在遍历表头之后可以沿原路退回，继而对表尾进行遍历。如果我们能用别的方法记下指针所走路径，则可以免除附设栈。在下面介绍的算法中就是利用已经标志过的表结点中的tag、hp和tp域来代替栈记录遍历过程中的路径。例如：对图8．10中的广义表加标志。假设在递归算法中指针p指向刚加上标志的b结点，则：①当指针p由b移向表头c之前需将b入栈(此时a已在栈中)；②在表头标志之后需退栈，然后指针p在由b移向表尾f时需再次将b入栈；③在b的表尾标志完之后应连续两次退栈，使p重又指向a。与此对应，在本算法中不设栈。而是当指针p由b移向c之前，先将b结点中的hp域的值改为指向a，并将b结点中的tag域的值改为“0”；而当指针p由b移向f之前，则先将b结点中的tp域的值改为指向a，tag域的值改为“1”。
    下面详细叙述算法的基本思想(注：假设图8．10中的广义表L’已加上标志)。8．10待遍历的广义表
    算法中设定了三个互相关联的指针：当p指向某个表结点时；t指向p的母表结点；q
指向p的表头或表尾。如图8．11中(a)和(b)所示。
    当q指向p的表头结点时，可能有三种情况出现：①设p的表头只是一个元素结点，则遍历表头仅需对该表头结点打上标志后即令q指向p的表尾；②设p的表头为空表或是已加上标志的子表，则无需遍历表头只要令q指向p的表尾即可；③设p的表头为未加标志的子表，则需先遍历表头子表，即p应赋q的值，t相应往下移动改赋p的值。为了记下t指针移动的路径，以便在p退回原结点时同时能找到p的母表结点(即使t退回到原来的值)，则在修改这个指针的值之前，应先记下t移动的路径，即令p所指结点的hp域的值为t，且tag域的值为“O”。
    另一方面，当q指向p的表尾时，也可能有两种情况出现：①p的表尾为未加标志的子表，则需遍历表尾的子表，同样队t指针要作相应的移动。为了记下当前表结点的母表结点，同样要在改动p、t指针的值之前先记下路径；即令p所指结点的tp域的值改为t，然后令t赋值p，p赋值q；②p的表尾为“空”或是已加上标志的子表，此时表明p所指的表已加上标志，则p应退回到其母表结点即t所指结点，相应地t也应后退一步，即退到t结点的母表结点。综上所述可知，t的移动路径已记录在t结点的hp域或tp域中，究竟是哪一个?则要由辨别tag域的值来定。它不仅指示t应按哪个指针所指路径退回，而且指示了下一步应做什么。若t结点是其母表表头，则应继续遍历其母表的表尾。若t结点是其母表的表尾，则应继续找更高一层的母表结点。整个算法大致描述如下：(GL为广义表的头指针)
t=NULL；  p=GL；  finished=FALSE
Hrhile(!finished){
∥若表头是未经遍历的非空子表，则修改指针记录路径，
∥且pI指向表头；否则p不变
    if(q＆&q>mark：=0)MarkTa~．1(p)；  ∥修改指针记录路径，且p指向表尾
    else BackTrack(finished)；∥若从表尾回溯到第一个结点，则finished为TRUE
    I    ’
求精后的广义表遍历算法如算法8．3所示。
・209・
=
M    =
    图8．
(a)指针初始化。q指向表头；
(b)和(C)指针向表头方向推进一步；
(d)对元素结点加标志后指针后退，q指向表尾；
(e)指针向表尾方向推进一步，q指向表头；
11遍历广义表
(f)指针后退一步；
(g)指针继续后退，q指向表尾；
(h)指针向表尾方向推进一步，q指向表尾(表头为空表)
(i)指针继续向表尾方向推进一步，q指向表头。
void MarkList(~List GL){
    ∥遍历非空广义表GL(GL!=NULL且GL一>mark==0)，对表中所有未加标志的结点加标志。
    t：NULL；P=GL；  finished=FALSE；  ∥t指示P的母表
    while(!finished){
    while(P一>mark==0){
    P一>mark=1：
    ∥MarkHead(p)的细化：
    q=P一>P．hp；  ∥q指向“P的表头
    if(q&&q一>mark==0){
・210・
    ∥A|IDM，表头为原子结点
t=p；p=q；}    ∥继续遍历子表
    }  ∥完成对表头的标志
    q=p>p．tp；    ∥q指向*p的表尾
    if(q＆＆q>mark==O){p>p．tp=t；t=p；p=q；I    ∥继续遍历表尾
    else{  ∥Bacl(|rrack(flnished)的细化：
    曲ile(t&&t>tag=：1){  ∥L上sT，表结点，从表尾回溯
    }
    if(!t)finished：‘tRUE；  ∥结束
    else{  ∥从表头回溯
    }  ∥继续遍历表尾
    }
  }
f∥MarkList
    算法8．3
    图8．11展示对图8．10中的广义表进行遍历加标志时各指针的变化状况。(a)为算法8．3开始执行时的状态。(b)和(c)为指针向表头方向移动并改变结点的hp域指针的情形。(d)表示当表头遍历完成将对表尾进行标志时的指针变化情况。从(e)和(f)读者可看到指针回溯的情形。在此省略了继续遍历时的指针变化状况，有兴趣的读者可试之补充。
    比较上述三种算法各有利弊。第三种算法在标志时不需要附加存储，使动态分配的可利用空间得到充分利用，但是由于在算法中，几乎是每个表结点的指针域的值都要作两次改变，因此时间上的开销相当大，而且，一旦发生中断，整个系统瘫痪，无法重新启动运行。而非递归算法操作简单，时间上要比第三种算法省得多，然而它需要占有一定空间，使动态分配所用的存储量减少。总之，无用单元收集是很费时间的，不能在实时处理的情况下应用。
    通常，无用单元的收集工作是由编译程序中的专用系统来完成的，它也可以作为一个标准函数由用户自行调用(类似于free函数的使用)。不论哪一种情况，系统都要求用户建立一个初始变量表登录用户程序中所有链表的表头指针，以便从这些指针出发进行标志。
　　下面我们可以对无用单元收集算法作某种定量估计。如上所述，整个算法分两步进行：第一步对占用结点加标志，不管用哪一种算法，其所用时间都和结点数成正比。假设总的占用结点数为N，则标志过程所需时间为c。N(其中c。为某个常数)；第二步是从可用空间的第一个结点起，顺序扫描，将所有未加标志的结点链结在一起。假设可用空间总共含有M个结点，则所需时间为c2M(其中c2为某个常数)。由此，收集算法总的时间为f1N+c2M，同时收集到的无用结点个数为M
显然，无用单元收集这项工作的效率和最后能收集到的可以重新分配的无用结点数有关。我们用收集一个无用结点所需的平均时间(clN+r2M)／(M―N)来度量这个效率。假设以ID=N／M表示内存使用的密度，则上述平均时间为(c-lD+c2)／(1～lD)。当内存中3／4的结点为无用结点，即10：1／4时，收集一个结点所需平均时间为1／3cl+4／3c2。反之，当内存中1／4的结点为无用结点，即ID=3／4时，收集一个结点所需平均时间为3c，+4c：。由此可见，可利用内存区中只有少量的结点为无用结点时，收集无用单元的操作的效率很低。不仅如此，而且当系统重又恢复运行时，这些结点又很快被消耗掉，导致另一次无用单元的收集。如此下去有可能造成恶性循环，以至最后整个系统瘫痪。解决的办法可以由系统事先确定一个常数志，当收集到的无用单元数为愚或更少时系统就不再运行下去。
8．6存储紧缩
　　前面几节中讨论的动态存储管理方法都有一个共同的特点，即建立一个“空闲块”或“无用结点”组成的可利用空间表，这个可利用空间表采用链表结构，其结点大小可以相同，也可以不同。
    图8．12堆存储管理示意图
　　    (a)堆空间；(b)串的存储映象；(c)紧缩后的堆；(d)修改后的存储映象。
    这一节将要介绍另一种结构的动态存储管理方法。在整个动态存储管理过程中，不管哪个时刻，可利用空间都是一个地址连续的存储区，在编译程序中称之为“堆”，每次分配都是从这个可利用空间中划出一块。其实现办法是：设立一个指针，称之为堆指针，始终指向堆的最低(或最高)地址。当用户申请N个单位的存储块时，堆指针向高地址(或低地址)移动N个存储单位，而移动之前的堆指针的值就是分配给用户的占用块的初始地址。回顾第四章中提及的串值存储空间的动态分配就是用的这种堆的存储管理。例如，某个串处理系统中有A、B、C、D四个串，其串值长度分别为12、6、10和8。假设堆指针free的初值为零，则分配给这四个串值的存储空间的初始地址分别为0、12、18和28，如图8．12(a)和(b)所示，分配后的堆指针的值为36。因此，这种堆结构的存储管理的分配算法非常简单。反之，回收用户释放的空闲块就比较麻烦。由于系统的可利用空间始终是一个地址连续的存储块，因此回收时必须将所释放的空闲块合并到整个堆上去才能重新使用，这就是“存储紧缩”的任务。通常，有两种做法：一种是一旦有用户释放存储块即进行回收紧缩，例如，图8．12(a)的堆，在c串释放存储块时即回收紧缩成为图8．12(c)的堆，同时修改串的存储映象成图8．12(d)的状态；另一种是在程序执行过程中不回收用户随时释放的存储块，直到可利用空间不够分配或堆指针指向最高地址时才进行存储紧缩。此时紧缩的目的是将堆中所有的空闲块连成一片，即将所有的占用块都集中到可利用空间的低地址区，而剩余的高地址区成为一整个地址连续的空闲块，如图8．13所示，其中(a)为紧缩前的状态，(b)为紧缩后的状态。
    图8．13紧缩前后的堆(存储空间)
    (a)紧缩前；  (b)紧缩后。
    和上节讨论的无用单元收集类似，为实现存储紧缩，首先要对占用块进行“标志”，标志算法和上节类同(存储块的结构可能不同)；其次需进行下列四步操作：
    (1)计算占用块的新地址。从最低地址始巡查整个存储空间，对每一个占用块找到它在紧缩后的新地址。为此，需设立两个指针随巡查向前移动，这两个指针分别指示占用块在紧缩之前和之后的原地址和新地址。因此，在每个占用块的第一个存储单位中，除了设立长度域(存储该占用块的大小)和标志域(存储区别该存储块是占用块或空闲块的标志)之外，还需设立一个新地址域，以存储占用块在紧缩后应有的新地址，即建立一张新、旧地址的对照表。
    (2)修改用户的初始变量表，以便在存储紧缩后用户程序能继续正常运行。
    (3)检查每个占用块中存储的数据。若有指向其它存储块的指针，则需作相应修改。    (4)将所有占用块迁移到新地址去。这实质上是作传送数据的工作。
    至此，完成了存储紧缩的操作。最后，将堆指针赋以新值(即紧缩后的空闲存储区的最低地址)。
　　可见，存储紧缩法比无用单元收集法更为复杂，前者不仅要传送数据(进行占用块迁移)，而且要修改所有占用块中的指针值。因此，存储紧缩也是一个系统操作，且非不得已就不用。
