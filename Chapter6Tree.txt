第6章树和二叉树
    树型结构是一类重要的非线性数据结构。其中以树和二叉树最为常用，直观看来，树是以分支关系定义的层次结构。树结构在客观世界中广泛存在，如人类社会的族谱和各种社会组织机构都可用树来形象表示。树在计算机领域中也得到广泛应用，如在编译程序中，可用树来表示源程序的语法结构。又如在数据库系统中，树形结构也是信息的重要组织形式之一。本章重点讨论二叉树的存储结构及其各种操作，并研究树和森林与二叉树的转换关系，最后介绍几个应用例子。    
6．1树的定义和基本术语
树(Tree)是n(n≥0)个结点的有限集。在任意一棵非空树中：(1)有且仅有一个特定的称为根(Root，)的结点；(2)当，z>l时，其余结点可分为优(优>0)个互不相交的有限集丁l，T2，…，T。，其中每一个集合本身又是一棵树，并且称为根的子树(SubTree)。例如，在图6．1中，(a)是只有一个根结点的树；(b)是有13个结点的树，其中A是根，其余结点分成三个互不相交的子集：T，={B，E，F，K，L}，T2={C，G}，T3={D，H，J，- ，M}； 1、T2和T3都是根A的子树，且本身也是一棵树。例如
④
  (a)
    图6．1树的示例
(a)只有根结点的树；  (b)一般的树。
T-，其根为B，其余结点分为两个互不相交的子集；T。，={E，K，L}，。2={F}。T。。和T。2都是B的子树。而T。。中E是根，{K}和{L}是E的两棵互不相交的子树，其本身又是只有一个根结点的树。
    上述树的结构定义加上树的一组基本操作就构成了抽象数据类型树的定义。
．ADT Tree{
  数据对象D：D是具有相同特性的数据元素的集合。
  数据关系R：若D为空集，则称为空树；
    若D仅含一个数据元素，则R为空集，否则R={H}，H是如下二元关系：
    (1)在D中存在唯一的称为根的数据元素root，它在关系H下无前驱；
    (2)若D－{root}≠垂，则存在D－{root．}的－／r划分D1，D2，…，珥(m>0)，对任意j≠k(1≤j，k≤m)有D]n Dl【：巾，且对任意的i(1≤i≤m)，唯一存在数据元素x：∈D。，
    <root，x。>∈H；
　　(3)对应于D一{root}的划分，H一{<root：，x1>，…，<root，】(m>}有唯一的一个划分H1，H2，…，Ha(re>O)，对任意j≠k(1≤j，k≤m)有n=，且对任意i(1≤i≤m)，Hi是Di上的二元关系，(Di，{H。})是一棵符合本定义的树，称为根root的子树。
　　基本操作P：
  InitTree(＆T)；
  操作结果：构造空树T。
DestroyTree(＆T)；
  初始条件：树T存在。
  操作结果：销毁树To
  CreateTree(＆T。definition)；
    初始条件：definition给出树T的定义。
    操作结果：按definition构造树T。
ClearTree(＆T)；
  初始条件：树T存在。
  操作结果：将树T清为空树。
  TreeEmpty(T)；
  初始条件：树T存在。
  操作结果：若T为空树，则返回TRUE，否则FALSE。
TreeDepth(T)；    ．
  初始条件：树T存在。
  操作结果：返回T的深度。    ．
  Root(T)；
  初始条件：树T存在。
  操作结果：返回T的根。
  Value(T，cur．e)；
    初始条件：树T存在，cure是T中某个结点。
    操作结果：返回cure的值。
  Assign(T，cure，value)；
    初始条件：树T存在，cure是T中某个结点。
    操作结果：结点cure赋值为value。
Parent(T，cure)；
    初始条件：树T存在，cue是T中某个结点。
    操作结果：若cure是T的非根结点，则返回它的双亲，否则函数值为“空”。
LeftChild(T，cure)；
    初始条件：树T存在，Cure是T中某个结点。
    操作结果：若cure是T的非叶子结点，则返回它的最左孩子，否则返回“空”。
  RightSibling(T，cure)；
    初始条件：树T存在，Cure是T中某个结点。
    操作结果：若cur．e有右兄弟，则返回它的右兄弟，否则函数值为“空”。
  InsertChild(&T，＆P，i。c)；
    初始条件：树T存在，P指向T中某个结点，1≤i≤p所指结点的度+1，非空树c与T不相交。
    操作结果：插入C为T中P指结点的第i棵子树。
DeleteChild(＆T，&P，i)；
    初始条件：树T存在，P指向T中某个结点，1≤i≤p指结点的度。
    操作结果：删除T中P所指结点的第i棵子树。
TraverseTree(T，Visit())；    
  初始条件：树T存在，Visit是对结点操作的应用函数。
  操作结果：按某种次序对T的每个结点调用函数visit()一次且至多一次。
    一旦visit()失败，则操作失败。
    
lADT Tree
　　树的结构定义是一个递归的定义，即在树的定义中又用到树的概念，它道出了树的固有特性。树还可有其它的表示形式，如图6．2所示为图6．1(b)中树的各种表示。其中(a)是以嵌套集合(即是一些集合的集体，对于其中任何两个集合，或者不相交，或者一个包含另一个)的形式表示的；(b)是以广义表的形式表示的，根作为由子树森林组成的表的名字写在表的左边；(c)用的是凹入表示法(类似书的编目)。表示方法的多样化，正说明了树结构在日常生活中及计算机程序设计中的重要性。一般说来，分等级的分类方案都可用层次结构来表示，也就是说，都可导致一个树结构。
　　 (a)(A(B(E(K，L)，F)，C(G)，D(H(M)，I，J)))
    (b)图6．2树的其它三种表示法
    下面列出树结构中的一些基本术语。
    树的结点包含一个数据元素及若干指向其子树的分支。结点拥有的子树数称为结点的度(Degree)。例如，在图6．1(b)中，A的度为3，c的度为1，F的度为0。度为0的结点称为叶子(Leaf)或终端结点。图6．1(b)中的结点K、L、F、G、M、I、J都是树的叶子。度不为0的结点称为非终端结点或分支结点。除根结点之外，分支结点也称为内部结点。树的度是树内各结点的度的最大值。如图6．1(b)的树的度为3。结点的子树的根称为该结点的孩子(Ch5．1d)，相应地，该结点称为孩子的双亲(Parent)。例如，在图6．1(b)所示的树中，D为A的子树T3的根，则D是A的孩子，而A则是D的双亲，同一个双亲的孩子之间互称兄弟(sibling)。例如，H、I和J互为兄弟。将这些关系进一步推广，可认为D是M的祖父。结点的祖先是从根到该结点所经分支上的所有结点。例如，M的祖先为A、D和H。反之，以某结点为根的子树中的任一结点都称为该结点的子孙。如B的子孙为E、K、L和F。
    结点的层次(Level)从根开始定义起，根为第一层，根的孩子为第二层。若某结点在第z层，则其子树的根就在第z+1层。其双亲在同一层的结点互为堂兄弟。例如，结点G与E、F、H、I、J互为堂兄弟。树中结点的最大层次称为树的深度(Depth)或高度。图6．1(b)所示的树的深度为4。
    如果将树中结点的各子树看成从左至右是有次序的(即不能互换)，则称该树为有序树，否则称为无序树。在有序树中最左边的子树的根称为第一个孩子，最右边的称为最后一个孩子。
    森林(I：orest)是m(m≥0)棵互不相交的树的集合。对树中每个结点而言，其子树的-集合即为森林。由此，也可以森林和树相互递归的定义来描述树。    
    就逻辑结构而言，任何一棵树是一个二元组me=(，oot，F)，其中：root是数据元素，称做树的根结点；F是m(m≥0)棵树的森林，F=(r1，T2，…，T。)，其中t=(_，E)称做根，"oot的第i棵子树；当优≠O时，在树根和其子树森林之间存在下列关系：  RF：{(root，n)l i=l，2，…，m，>0}
这个定义将有助于得到森林和树与二叉树之间转换的递归定义。
    树的应用广泛，在不同的软件系统中树的基本操作集不尽相同。
6．2二叉树
    在讨论一般树的存储结构及其操作之前，我们首先研究一种称为二叉树的抽象数据类型。
  6．2．1二叉树的定义
  二叉树(Bi／18ry Tree)是另一种树型结构，它的特点是每个结点至多只有二棵子树(即二叉树中不存在度大于2的结点)，并且，二叉树的子树有左右之分，其次序不能任意颠倒。
    抽象数据类型二叉树的定义如下：
    ^DT Bin|Iqee{
    数据对象D：D是具有相同特性的数据元素的集合。
    数据关系R：
    若D=中，则R=中，称BinaryTree为空二叉树； 
    若D≠中，则R={H}，H是如下二元关系：
    (1)在D中存在唯一的称为根的数据元素root，它在关系H下无前驱；
    (2)若D一{root}≠垂，则存在D一{root}={Dl，D：}，且Dln Dr=；
    (3)若D1≠∞，则D1中存在唯一的元素x】，<root，Xl>∈H，且存在Dl上的关系H1cH；若Dr≠包则Dr中存在唯一的元素写，<root，≈>∈H，
    且存在Dr上的关系臣cH；H：{<root：，x1>，<root，>，Hl，K}．
    (4)(D。，{H1})是一棵符合本定义的二叉树，称为根的左子树，
    (Dr，{也})是一棵符合本定义的二叉树，称为根的右子树。
    基本操作P：
    InitBiTree(＆T)；
    操作结果：构造空二叉树T。
    DestroyBiTree(＆T)；
    初始条件：二叉树T存在。
    操作结果：销毁二叉树T。
    CreateBiTree(&T，defin北ion)；
    初始条件：definition给出二叉树T的定义。
    操作结果：按definltion构造二叉树L
    clearBiTree(＆T)；    。
    初始条件：二叉树T存在。
    操作结果：将二叉树T清为空树。
    BiTreeEmpty(T)；
    初始条件：二叉树T存在。
    操作结果：若T为空二叉树，则返回TRUE，否则FALSE。
    BiTreeDepth(T)；
    初始条件：二叉树T存在。
    操作结果：返回T的深度。
    Root(T)；
    初始条件：二叉树T存在。
    操作结果：返回T的根。
    Value(T，e)；
    初始条件：二叉树T存在，e是T中某个结点。
    操作结果：返回e的值。
    Assign(T，＆e，value)；
    初始条件：二叉树T存在，e是T中某个结点。
    操作结果：结点e赋值为value。
    Parent(T，e)；
    初始条件：二叉树T存在，e是T中某个结点。
    操作结果：若e是T的非根结点，则返回它的双亲，否则返回“空”。
    LeftChild(T，e)；    ．
    初始条件：二叉树T存在，e是T中某个结点。
    操作结果：返回e的左孩子。若e无左孩子，则返回“空”。
    RightChlld(T，e)；
    初始条件：二叉树T存在，e是T中某个结点。
    操作结果：返回e的右孩子。若e无右孩子，则返回“空”。
    LeftSibl．ing(T，e)；
    初始条件：二叉树T存在，e是T中某个结点。
    操作结果：返回e的左兄弟。若e是T的左孩子或无左兄弟，则返回“空”。
    RightSibling(T，e)；
    初始条件：二叉树T存在，e是T中某个结点。
    操作结果：返回e的右兄弟。若e是T的右孩子或无右兄弟，则返回“空”。
    InsertChild(T，p，LR，c)；
    初始条件：二叉树T存在，p指向T中某个结点，LR为0或1，非空二叉树c与T不相交且右子树为空。
    操作结果：根据LR为O或1，插入c为T中p所指结点的左或右子树。p所指结点的原有左或右子树则成为c的右子树。
    DeleteChild(T，p，LR)；
    初始条件：二叉树T存在，p指向T中某个结点，LR为O或1。
  操作结果：根据LR为O或1，删除T中p所指结点的左或右子树。
PreOx~erTraverse(T，Vislt())；
  初始条件：二叉树T存在，visit是对结点操作的应用函数。
  操作结果：先序遍历TI对每个结点调用函数Visit一次且仅一次。一旦visit()失败，则操作失败。
InOrderTraverse(T，VisJ．t())；
  初始条件：二叉树T存在，Visit是对结点操作的应用函数。
  操作结果：中序遍历T，对每个结点调用函数Visit一次且仅一次。一旦visit()失败，则操作失败。
PostOrderTraverse(T，Visit())；
  初始条件：二叉树T存在，Visit是对结点操作的应用函数。
  操作结果：后序遍历T，对每个结点调用函数visit一次且仅一次。一旦visit()失败，则操作失败。
LevelOrderTraverse(T，Visit())；
  初始条件：二叉树T存在，Vis／．t是对结点操作的应用函数。
  操作结果：层序遍历T，对每个结点调用函数Visit一次且仅一次。一旦visit()失败，则操    作失败。
    I^DT BjnaryTree
　　上述数据结构的递归定义表明二叉树或为空，或是由一个根结点加上两棵分别称为左子树和右子树的、互不相交的二叉树组成。由于这两棵子树亦是二叉树，则由二叉树的定义，它们也可以是空树。由此，二叉树可以有五种基本形态，如图6．3所示。
图6．3二叉树的五种基本形态
(a)空二叉树；(b)仅有根结点的二叉树；(c)右子树为空的二叉树；
    (d)左、右子树均非空的二叉树；【e)左子树为空的二叉树。
6．1节中引入的有关树的术语也都适用于二叉树。
6．2．2二叉树的性质
  二叉树具有下列重要特性。
  性质1在二叉树的第i层上至多有2个结点(i≥1)。
  利用归纳法容易证得此性质。
  i=1时，只有一个根结点。显然，2=20：1是对的。
  现在假定对所有的．『，1≤J<i，命题成立，即第n层上至多有2J叫个结点。那么，可以证明j=i时命题也成立。
    由归纳假设：第i－1层上至多有2卜。个结点。由于二叉树的每个结点的度至多为2，故在第i层上的最大结点数为第i－1层上的最大结点数的2倍，即2×2’12=2。。
    性质2深度为志的二叉树至多有2‘－1个结点，(五≥1)。
    由性质1可见，深度为n的二叉树的最大结点数为
    ∑(第i层上的最大结点数)=∑2H=2‘一1
    性质3  对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为”2，则o=2+10    设，z，为二叉树丁中度为1的结点数。因为二叉树中所有结点的度均小于或等于2，所以其结点总数为=o+，z1+，z2    (6―1)
    再看二叉树中的分支数。除了根结点外，其余结点都有一个分支进入，设B为分支总数，则，z=B+1。由于这些分支是由度为1或2的结点射出的，所以又有B=n1+2n2。于是得1+221    (6．2)
由式(6―1)和(6―2)得
    ，z0。2+1
    完全二叉树和满二叉树，是两种特殊形态的二叉树。
    一棵深度为且有2‘1个结点的二叉树称为满二叉树。如图6．4(a)所示是一棵深度为4的满二叉树，这种树的特点是每一层上的结点数都是最大结点数。
    可以对满二叉树的结点进行连续编号，约定编号从根结点起，自上而下，自左至右。由此可引出完全二叉树的定义。深度为是的，有咒个结点的二叉树，当且仅当其每一个结点都与深度为m的满二叉树中编号从1至，z的结点一一对应时，称之为完全二叉树。①如图6．4(b)所示为一棵深度为4的完全二叉树。显然，这种树的特点是：(1)叶子结点只可能在层次最大的两层上出现；(2)对任一结点，若其右分支下的子孙的最大层次为z，则其左分支下的子孙的最大层次必为z或z+1。如图6．4中(c)和(d)不是完全二叉树。
    完全二叉树将在很多场合下出现，下面介绍完全二叉树的两个重要特性。
    性质4具有n个结点的完全二叉树的深度为L log2扎j+1⑦。
    证明：假设深度为愚，则根据性质2和完全二叉树的定义有≤n<2‘
于是是～1≤log2 n<  。．。是整数  ．’．=L log2”j+1
　　性质5如果对一棵有m个结点的完全二叉树(其深度为L：log2J+1)的结点按层序编号(从第1层到第L|og2j+1层，每层从左到右)，则对任一结点i(1≤i≤，z)，有
　　   (1)如果1，则结点i是二叉树的根，无双亲；如果i>1，则其双亲PARENT(i)是①  在各种版本的数据结构书中，对完全二叉树的定义均不相同。本书中将一律以此定义为准。②符号【．r J表示不大于z的最大整数，反之，r z]表示不小于z的最小整数。
    图6．4特殊形态的二叉树
    (a)满二叉树；(b)完全二叉树；(c)和(d)非完全二叉树。
  结点L i／2 j。
，    (2)如果2i>，z，则结点i无左孩子(结点f为叶子结点)；否则其左孩子LCHILD(i)LCHIt，D(i)    LCHILD(i+1)
    RCHII，D(i)  RCHILD(i+1)
    (a)
图6．5完全二叉树中结点i和i+1的左、右孩子
    (a)结点i和i+1在同一层上；
    (b)结点i和i+1不在同一层上。
是结点2i。
    (3)如果2i+1>n，则结点i无右孩子；
否则其右孩子R(7HI．LD(i)是结点2i+1。
    我们只要先证明(2)和(3)，便可以从(2)
和(3)导出(1)。
    对于产1，由完全二叉树的定义，其左孩子是结点2。若2>"，即不存在结点2，此时结点i无左孩子。结点i的右孩子也只能是结点3，若结点3不存在，即3>，此时结点i无右孩子。
    对于i>1可分两种情况讨论：(1)设第j(1≤j≤L log2n J)层的第一个结点的编号为i(由二叉树的定义和性质2可知i=2j 11)，则其左孩子必为第J+1层的第一个结点，其编号为2j：2(2，)=2i，若2i>”，则无左孩子；其右孩子必为第歹+1层的第二个结点，其编号为2i+1，若2￡+1>，z，则无右孩子；(2)假设第J(1≤歹≤L log2n j)层上某个结点的编号为i(2卜。≤i<2J一1)，且2i+1<n，则其左孩子为2i，右孩子为2i+1，则编号为i+l的结点是编号为i的结点的右兄弟或者堂兄弟，若它有左孩子，则编号必为2i+2=2(i+1)，若它有右孩子，则其编号必为2i+3：2(i+1)十1。图6．5所示为完全二叉树上结点及其左、右孩子结点之间的关系。
  6．2．3二叉树的存储结构
  一、顺序存储结构，
  ∥…二叉树的顺序存储表示…
  #define MAX。TREE～SIZE 100    ∥二叉树的最大结点数
  typedef TElemType SqBiTree[MAX’FREESIZE]；  ∥0号单元存储根结点
  SqBiTree bt：
  按照顺序存储结构的定义，在此约定，用一组地址连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素，即将完全二叉树上编号为i的结点元素存储在如上定义的一维数组中下标为i-1的分量中。例如，图6．6(a)所示为图6．4(b)所示完全二叉树的顺序存储结构。对于一般二叉树，则应将其每个结点与完全二叉树上的结点相对照，存储在一维数组的相应分量中，如图6．4(c)所示二叉树的顺序存储结构如图6．6(b)所示，图中以“O”表示不存在此结点。由此可见，这种顺序存储结构仅适用于完全二叉树。因为，在最坏的情况下，一个深度为量且只有n个结点的单支树(树中不存在度为2的结点)却需要长度为2‘－1的一维数组。
图6．6二叉树的顺序存储结构
    (a)完全二叉树；(b)一般二叉树。
  二、链式存储结构
  设计不同的结点结构可构成不同形式的链式存储结构。由二叉树的定义得知，二叉树的结点(如图6．7()所示)由一个数据元素和分别指向其左、右子树的两个分支构成，则表示二叉树的链表中的结点至少包含三个域：数据域和左、右指针域，如图6．7(6)所示。有时，为了便于找到结点的双亲，则还可在结点结构中增加一个指向其双亲结点的指针域，如图6．7(c)所示。利用这两种结点结构所得二叉树的存储结构分别称之为二叉链表和三叉链表，如图6．8所示。链表的头指针指向二叉树的根结点。容图6．7二叉树的结点及其存储结构    (a)二叉树的结点；  (b)含有两个指针域的结点结构；  (c)含有三个指针域的结点结构。易证得，在含有，z个结点的二叉链表中有，z+1个空链域。在6．3节中我们将会看到可以利用这些空链域存储其它有用信息，从而得到另一种链式存储结构――线索链表。以下是二叉链表的定义和部分基本操作的函数原型说明。
∥…二叉树的二叉链表存储表示
tIR~f stz~ct BiTNode{
    TElType data；
    struct BiTNode  *Ichild，*rchild；∥左右孩子指针
}BiTNode，*B'iTree；
∥基本操作的函数原型说明(部分)…
Status CreateBiTree(BiTree＆T)；
  ∥按先序次序输入二叉树中结点的值(一个字符)，空格字符表示空树，
  ∥构造二叉链表表示的二叉树T。
Status PreOrderTraverse(BiTree T，Status(*Visit)(TElemType e))；
  ∥采用二叉链表存储结构，Visit是对结点操作的应用函数。
  ∥先序遍历二叉树T，对每个结点调用函数Visit一次且仅一次。
  ∥一旦visit()失败，则操作失败。
Status InOrderTraverse(BiTree T，Status(*Visit)(lType e))；
  ∥采用二叉链表存储结构，Visit是对结点操作的应用函数。
  ∥中序遍历二叉树T，对每个结点调用函数Visit一次且仅一次。
  ∥一旦visit()失败，则操作失败。
Status PostOrderTraverse(BiTree T，Status(*Visit)(TZlemType e))；
  ∥采用二叉链表存储结构，Visit是对结点操作的应用函数。
  ∥后序遍历二叉树T，对每个结点调用函数Visit一次且仅一次。
  ∥一旦visit()失败，则操作失败。
Status LevelOrderTraverse(BiTree T，Status(*Visit)(TElT'5『pe e))；
  ∥采用二叉链表存储结构，Visit是对结点操作的应用函数。
  ∥层序遍历二叉树T，对每个结点调用函数Visit一次且仅一次。
  ∥一旦visit()失败，则操作失败。
    图6．8链表存储结构
(a)单支树的二叉链表；(b)二叉链表；(c)三叉链表。
  在不同的存储结构中，实现二叉树的操作方法亦不同，如找结点x的双亲PARENT(T，e)，在三叉链表中很容易实现，而在二叉链表中则需从根指针出发巡查。由此，在具体应用中采用什么存储结构，除根据二叉树的形态之外还应考虑需进行何种操作。读者可试以6．2节中定义的各种操作对以上三种存储结构进行比较。
6．3遍历二叉树和线索二叉树
6．3．1遍历二叉树
　　在二叉树的一些应用中，常常要求在树中查找具有某种特征的结点，或者对树中全部结点逐一进行某种处理。这就提出了一个遍历二叉树(Traversing Binary Tree)的问题，即如何按某条搜索路径巡访树中每个结点，使得每个结点均被访问一次，而且仅被访问一次。“访问”的含义很广，可以是对结点作各种处理，如输出结点的信息等。遍历对线性结构来说，是一个容易解决的问题。而对二叉树则不然，由于二叉树是一种非线性结构，每个结点都可能有两棵子树，因而需要寻找一种规律，以便使二叉树上的结点能排列在一个线性队列上，从而便于遍历。
　　回顾二叉树的递归定义可知，二叉树是由三个基本单元组成：根结点、左子树和右子树。因此，若能依次遍历这三部分，便是遍历了整个二叉树。假如以L、D、R分别表示遍历左子树、访问根结点和遍历右子树，则可有DLR、I．DR、LRD、DRL、RDL、RLD六种遍历二叉树的方案。若限定先左后右，则只有前三种情况，分别称之为先(根)序遍历，中(根)序遍历和后(根)序遍历。基于二叉树的递归定义，可得下述遍历二叉树的递归算法定义。
　　先序遍历二叉树的操作定义为：
    若二叉树为空，则空操作；否则
    (1)访问根结点；
    (2)先序遍历左子树；
    (3)先序遍历右子树。
    中序遍历二叉树的操作定义为：
    若二叉树为空，则空操作；否则
    (1)中序遍历左子树；
    (2)访问根结点；
    (3)中序遍历右子树。
    后序遍历二叉树的操作定义为：
    若二叉树为空，则空操作；否则
    (1)后序遍历左子树；
    (2)后序遍历右子树；  。
    (3)访问根结点。
　　算法6．1给出了先序遍历二叉树基本操作的递归算法在二叉链表上的实现。读者可类似地实现中序遍历和后序遍历的递归算法，此处不再一一列举。
　　Status PreOrder~’raverse(BiTree T，Status(*  Visit)(TElemType e)){
∥采用二叉链表存储结构，Visit是对数据元索操作的应用函数，
∥先序遍历二叉树T的递归算{对每个数据元索调用函数Visit。
∥最简单的Visit函数是：
／／  Status prIntEl~t(TEleType e)f∥输出元索e的值
∥prIntf(e)，    ／／实用时．an~格式串
∥return OK；
∥    }
∥调用实例：Pr如de以se(T．PrIntEl~ent)；
if({
  if(Vislt(T->data”
    if(p~-eOrderTraverse(T->ichild，Visit))
    if(PreorderTraverse(T->rchild，Visit))retu蚰OK；
    retERROR：
Iel86 retOK
算法6 I
  例如图6 9所示的二叉树0表示下述表达式
    a+b*(cd)e／f
若先序遍历此二叉树，按访问结点的先后次序将结点排列起来，
为 a*b―cd／ef    (6．3)
类似地。中序遍历此二叉树，可得此二叉树的中序序列为    a+b*c―d―df    (6．4)
后序遍历此二叉树，可得此二叉树的后序序列为    abed一*+d／一    (6．5)
从表达式来看，以上三个序列(6-3)、(6-4)和(6．5)恰好为表达式的前缀表示(波兰式)、中缀表示和后缀表示(逆波兰式)。
　　从上述二叉树遍历的定义可知．三种遍历算法之不同处仅在于访问根结点和遍历左、右子柑的先后关系。如果在算法中暂且抹去和递归无关的visite语句，则三个遍历算法完全相同。由此，从递归执行过程的角度来看先序、中序和后序遍历也是完可得到二叉树的先序序列表选式(a十h*(c―d)一√f)的二叉树相同的。图6 lO(b)中用带箭头的虚线表示了这三种遍历算法的递归执行过程。其中，向下的箭头表示更深一层的递归调用，向上的箭头表示从递归调用退出返回；虚线旁的三角形、圆形和方形内的字符分别表示在先序、中序和后序遍历二叉树过程中访问结点时输出的信息。例如，由于中序遍历中访问结点是在遍历左子树之后、遍历右子树之前进行，则带圆形的字符标在向左递归返回和向右递归调用之间。由此，只要沿虚线从1出发到2结束，将沿途所见的三角形(或圆形、或方形)内的字符记下，便得遍历二叉树的先序(或中序、或后序)序列。例如，从图6．10(b)分别可得图6，10(a)所示表达式的前缀表示(一*abc)、中缀表示(a*b―c)和后缀表示(ab*c一)。
    图6．10三种遍历过程示意图
　　(a)表达式(a*b―c)的二叉树；(b)遍历的递归执行过程。
    仿照递归算法执行过程中递归工作栈的状态变化状况可直接写出相应的非递归算法。例如，从中序遍历递归算法执行过程中递归工作栈的状态可见：(1)工作记录中包含两项，其一是递归调用的语句编号，其二是指向根结点的指针，则当栈顶记录中的指针非空时，应遍历左子树，即指向左子树根的指针进栈；(2)若栈顶记录中的指针值为空，则应退至上一层，若是从左子树返回，则应访问当前层即栈顶记录中指针所指的根结点；(3)若是从右子树返回，则表明当前层的遍历结束，应继续退栈。从另一角度看，这意味着遍历右子树时不再需要保存当前层的根指针，可直接修改栈顶记录中的指针即可。由此可得两个中序遍历二叉树的非递归算法如算法6．2和6．3所示，供读者分析比较，以加深理解。
Status InOrderTraverse(BiTree T，Status(*Vis it)(TElemType e)){
    ∥采用二叉链表存储结构，Visit是对数据元素操作的应用函数。
    ∥中序遍历二叉树T的非递归算法，对每个数据元素调用函数visit。
    Initstack(s)；Push(s，T)；    ∥根指针进栈
    ．hile(!StackEmpty(S)){
    whlle(~tTop(s，p)&＆。p)th／sh(S，p->ichild)；∥向左走到尽头
    Pop(s，p)；    ∥空指针退栈
    if(!St~ckEmpty(s)){    ∥访问结点，向右一步
    Pop(s，p)；  1f(!Vj，it(p->dat：a))return ERROR；
    Push(s，p->rchild)；
    }∥if
  l∥While
  return【OK：
＼}f InOrderTraverse
算法6．2
Status InOrderTraverse(BiTree T。Status(*Visit)(TElemType e)){
  ∥采用二叉链表存储结构，Visit是对数据元素操作的应用函数。
  ∥中序遍历二叉树T的非递归算法，对每个数据元素调用函数Visit。
  InitStack(S)；P=T；
  while(P 0 1 Stac~pty(S)){
    if(P){Push(S，p)；P：P->Ichild；}∥根指针进栈，遍历右予树
    else{    ∥根指针退栈，访问根结点，遍历右子树
    Pop(S，p)；  if(!Visit(p->data))return ERROR；
    P：P->rchild；
    ＼}f else
  }∥While
  return OK；
}∥InorderTraverse
    算法6．3
    “遍历”是二叉树各种操作的基础，可以在遍历过程中对结点进行各种操作．如一棵已知树可求结点的双亲，求结点的孩子结点．判定结点所在层次等，反之，也可在遍历过程中生成结点，建立二叉树的存f睬估构。例如．算法6．4是一个按先序序列建立的二叉链表的过程。对图6．8(b)所示二叉树，按下列次序顺序读入字符    A B C①D 可建立的_I叉链表。
Status CreateBiTree(BiTree＆T)1
  ∥按先序次序输入二叉树中-Bj值(一个字符)，空格字符表示空树，
  ∥构造二叉链表表示的：：
  8caInf(&ch)；
  if(ch==～)T=I；
  else I
    if(!(T=(Bil~Node*)~lloc(sizeof(BiTNode))))exit(OVERFLOW)；
    T->data=ch；    ／／生成根结点
    Cre~teBiTree(T->ichild)；    ∥构造左子树
    CreateBiTree(T->rchild)；    ∥构造右子树
  }
  return OK；
}∥CreateBiTree
    算法6．4
    对二叉树进行遍历的搜索路径除了上述按先序、中序或后序外，还可从上到下、从左到右按层次进行。
    显然，遍历二叉树的算法中的基本操作是访问结点，则不论按哪一种次序进行遍历。对含”个结点的二叉树，其时间复杂度均为o(”)。所需辅助空间为遍历过程中栈的最大容量，即书时的深度，最坏情况下为”，则空间复杂度也为0(n)。遍历时如果用二叉树的其它存储结构，如带标志域的三叉链表(参见算法6．13)，此时因存储结构中已存有遍历所需足够信息，则遍历过程中不需另设栈，也可和8．5节将讨论的遍历广义表的算法相类似，采用带标志域的二叉链表作存储结构，并在遍历过程中利用指针域暂存遍历路径，也可省略栈的空间，但这样做将使时间上有很大损失。
6．3．2线索二叉树
    从上节的讨论得知：遍历二叉树是以一定规则将二叉树中结点排列成一个线性序列，得到二叉树中结点的先序序列或中序序列或后序序列。这实质上是对一个非线性结构进行线性化操作，使每个结点(除第一个和最后一个外)在这些线性序列中有且仅有一个直接前驱和直接后继(在不致于混淆的情况，我们省去直接二字)①。例如在图6．9所示的二叉树的结点的中序序列a+b*c―d―e／f中’c’的前驱是’*，后继是’。
    但是，当以二叉链表作为存储结构时，只能找到结点的左、右孩子信息，而不能直接得到结点在任一序列中的前驱和后继信息，这种信息只有在遍历的动态过程中才能得到。    如何保存这种在遍历过程中得到的信息呢?一个最简单的办法是在每个结点上增加两个指针域fwd和bkwd，分别指示结点在依任一次序遍历时得到的前驱和后继信息。显然，这样做使得结构的存储密度大大降低。另一方面，在有n个结点的二叉链表中必定存在n+1个空链域。由此设想能否利用这些空链域来存放结点的前驱和后继的信息。
    试作如下规定：若结点有左子树，则其lchild域指示其左孩子，否则令lchild域指示其前驱；若结点有右子树，则其rchild域指示其右孩子，否则令rchild域指示其后继。为了避免混淆，尚需改变结点结构，增加两个标志域lchild  l ltag I data l nag l  rchild
其中：
    ．    f 0 lchild域指示结点的左孩子
    “u6  i l lchild域指示结点的前驱
    f 0 rchild域指示结点的右孩子
    …。  f l rchild域指示结点的后继
    以这种结点结构构成的二叉链表作为二叉树的存储结构，叫做线索链表，其中指向结点前驱和后继的指针，叫做线索。加上线索的二叉树称之为线索二叉树(Threaded BinaryTree)。例如图6．11(a)所示为中序线索二叉树，与其对应的中序线索链表如图6．1l(b)所示。其中实线为指针(指向左、右子树)，虚线为线索(指向前驱和后继)。对二叉树以某种次序遍历使其变为线索二叉树的过程叫做线索化。
    在线索树上进行遍历，只要先找到序列中的第一个结点，然后依次找结点后继直至其后继为空时而止。
    如何在线索树中找结点的后继?以图6．11的中序线索树为例来看，树中所有叶子结点的右链是线索，则右链域直接指示了结点的后继，如结点b的后继为结点*。树中所有①  注意在本节下文中提到的“前驱”和“后继”均指以某种次序遍历所得序列中的前驱和后继。
图6．11  线索二叉树及其存储结构
(a)中序线索二叉树；(b)中序线索链表。
非终端结点的右链均为指针，则无法由此得到后继的信息。然而，根据中序遍历的规律可知，结点的后继应是遍历其右子树时访问的第一个结点，即右子树中最左下的结点。例如在找结点*的后继时，首先沿右指针找到其右子树的根结点“一”，然后顺其左指针往下直至其左标志为1的结点，即为结点*的后继，在图中是结点c。反之，在中序线索树中找结点前驱的规律是：若其左标志为“1”，则左链为线索，指示其前驱，否则遍历左子树时最后访问的一个结点(左子树中最右下的结点)为其前驱。
在后序线索树中找结点后继较复杂些，可分三种情况：(1)若结点x是二叉树的根，则其后继为空；(2)若结点x是其双亲的右孩子或是其双亲的左孩子且其双亲没有右子树，则其后继即为双亲结点；(3)若结点x是其双亲的左孩子，且其双亲有右子树，则其后继为双亲的右子树上按后序遍历列出的第一个结点。例如图6．12所示为后序后继线索二叉树，结点B的后继为结点c，结点C的后继为结点D，结点F的后继为结点G，而结点D的后继为结点E。可见，在后序线索化树上找后继时需知道结点双亲，即需带标志域的三叉链表作存储结构。
    可见，在中序线索二叉树上遍历二叉树，虽则时间复杂度亦为0(n)，但常数因子要比上节讨论的算法小，且不需要设栈。
图6．12后序后继
  线索二叉树
因此，若在某程序中所用二叉树需经常遍历或查找结点在遍历所得线性序列中的前驱和后继，则应采用线索链表作存储结构。
∥二叉树的二叉线索存储表示
tenum{Link，Thread}PoInterTag；
tstru~BiThrNode{
  TElemType data：
  8truct BiThJ：Node    *ichild，  *rchJ．1d；
  PointerTag LTag，RTag；
∥Link==0：指针，Thread==1：线索
∥左右孩子指针
∥左右标志
    }BiThrNode。*BiThrTree；
    为方便起见，仿照线性表的存储结构，在二叉树的线索链表上也添加一个头结点，并令其lchild域的指针指向二叉树的根结点，其rchild域的指针指向中序遍历时访问的最后一个结点；反之，令二叉树中序序列中的第一个结点的lchild域指针和最后一个结点rehild域的指针均指向头结点。这好比为二叉树建立了一个双向线索链表，既可从第一个结点起顺后继进行遍历，也可从最后一个结点起顺前驱进行遍历(如图6．11(b)所示)。
下述算法6．5正是以双向线索链表为存储结构时对二叉树进行遍历的算法。
Status InOrderTraverse―Thr(BiThrTree T，Status(*Visit)(TElemType e)){
  ∥T指向头结点，头结点的左链ichild指向根结点，可参见线索化算法。
  ∥中序遍历二叉线索树T的非递归算法，对每个数据元素调用函数Visit。
  P=T->Ichild；    ∥P指向根结点
  while(P!=T){    ∥空树或遍历结束时，P：=T
    while(p->LTag==Link)P=P->ichild；
    if(!Visit(p->data))return ERROR；    ∥访问其左子树为空的结点
    while(p->RTag==Thread＆＆P->rchild!=T){
    P=P->rchild；  Visit(p->data)；    ∥访问后继结．-0
    }
    P=P->rchild：
  }
  return OK；
、}}InOrderTraverse。Thr
    算法6．5
    那末，又如何进行二叉树的线索化呢?由于线索化的实质是将二叉链表中的空指针
改为指向前驱或后继的线索，而前驱或后继的信息只有在遍历时才能得到，因此线索化的
过程即为在遍历的过程中修改空指针的过程。为了记下遍历过程中访问结点的先后关
系，附设一个指针pre始终指向刚刚访问过的结点，若指针P指向当前访问的结点，则pre
指向它的前驱。由此可得中序遍历建立中序线索化链表的算法如算法6．6和6．7所示。
Status InOrderThreading(BiThrTree&Thrt，BiThrTree T){
  ∥中序遍历二叉树T，井将其中序线索化，Thrt指向头结点。
  if(!(Thrt=(BiThrTree)mall~(size~(BiThrNode))))exit(OVERFLOW)；
  Thrt->LTag=Link；Thrt->RTag=Thread；    ∥建头结点
  Thrt->rchild=Thrt；    ∥右指针回指
  if(!T)Thrt->Ichild=Thrt；    ∥若二叉树空，则左指针回指
  else}    ・
    Thrt->ichild=T；pre=Thrt：
    InThreading(T)；    ∥中序遍历进行中序线索化
    pre->rchild：Thrt；pre->RTag：Thread；  ∥最后一个结点线索化
    Thrt->rchild=pre；
  }
  return OK；
}∥InorderThreading
    算法6．6
・134・
void InThreading(BiThrTree P){
  if(P){
    InThreading(p->ichild)；  ∥左子树线索化
    if(!P->ichild){P->LTag=Thread；P->ichild=pre；}  ∥前驱线索
    if(!pre->rchild){pre->RTag=Thread；pre->rchild=p；}∥后继线索
    pre i p；    ∥保持pre指向p的前驱
    InThreading(p->rchild)；  ∥右子树线索化
  }    ．
＼}?InThreading
    算法6．7
6．4树和森林
这一节我们将讨论树的表示及其遍历操作，并建立森林与二叉树的对应关系。
6．4．1树的存储结构
    在大量的应用中，人们曾使用多种形式的存储结构来表示树。这里，我们介绍三种常用的链表结构。
  一、双亲表示法
  假设以一组连续空间存储树的结点，同时在每个结点中附设一个指示器指示其双亲结点在链表中的位置，其形式说明如下：
∥树的双亲表存储表示
#define MAX―TREE―SIZE 100
tnx~f stru~．PTNode{
  TElemType data；
  int parent；∥双亲位置域
}PTNode；
tdef stru=t{
  PTNode nodes【MAX-TREE-SIZE]；
  int    n；    ∥结点数
}PTree；
例如，图6．13展示一棵树及其双亲表示的存储结构。这种存储结构利用了每个结点(除根以外)只有唯一的双亲的性质。PARENT(T，x)操作可以在常量时间内实现。反复调用PARENT操作，直到遇见无双亲的结点时，便找到了树的根，这就是ROOT(x)操作的执行过程。但是，在这种表示法中，求结点的孩子时需要遍历整个结构。
  二、孩子表示法
数组下标
图6．13树的双亲表示法示例
由于树中每个结点可能有多棵子树，则可用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点，此时链表中的结点可以有如下两种结点格式：data  1  childl  l  child2  若采用第一种结点格式，则多重链表中的结点是同构的，其中d为树的度。由于树中很多结点的度小于d，所以链表中有很多空链域，空间较浪费，不难推出，在一棵有n个结点度为是的树中必有n(忌一1)+1个空链域。若采用第二种结点格式，则多重链表中的结点是不同构的，其中刁为结点的度，degree域的值同a。此时，虽能节约存储空间，但操作不方便。
　　另一种办法是把每个结点的孩子结点排列起来，看成是一个线性表，且以单链表作存储结构，则，z个结点有n个孩子链表(叶子的孩子链表为空表)。而n个头指针又组成一个线性表，为了便于查找，可采用顺序存储结构。这种存储结构可形式地说明如下：
　　    ∥树的孩子链表存储表示
    typedef struct CTNode{    ∥孩子结点
    ．int    chi．1d：
    struc~c CTNode”next：
    }*Chilc[Ptr；
    type4ef stz~ct{
  -rEle data；
  ChiidPtr firstchild；  ∥孩子链表头指针
    ICTBox；
    typedef struct{
    BDx nodes[MAX-TREE-S~ZE]；
    int  n，r；    ∥结点数和根的位置；
    Icrree；
    图6．14(a)是图6．13中的树的孩子表示法。与双亲表示法相反，孩子表示法便于那些涉及孩子的操作的实现，却不适用于PARENT(T，x)操作。我们可以把双亲表示法和孩子表示法结合起来，即将双亲表示和孩子链表合在一起。图6．14(b)就是这种存储结构的一例，它和图6．14(a)表示的是同一棵树。
    三、孩子兄弟表示法
    又称二叉树表示法，或二叉链表表示法。即以二叉链表作树的存储结构。链表中结点的两个链域分别指向该结点的第一个孩子结点和下一个兄弟结点，分别命名为firstchild域和nextsibling域。
    ∥…树的二叉链表(孩子一兄弟)存储表示
    tl~ef struct CSNode{    ’
    ElemType data：
    struct CSNode  *firstchJ．1d，*nextsibling；
  }CSNode。*CSTree；
  图6．15是图6．13中的树的孩子兄弟链表。利用这种存储结构便于实现各种树的操作。首先易于实现找结点孩子等的操作。例如：若要访问结点x的第i个孩子，则只要先    图6．14图6．13的树的另外两种表示法
    (a)孩子链表；(b)带双亲的孩子链表。
从firstchild域找到第1个孩子结点，然后沿着孩子结点的nextsibling域连续走i～1步，便可找到x的第i个孩子。
当然，如果为每个结点增设一个：PARENT域，则同样能方便地实现PARENT(T，x)操作。
  6．4．2森林与二叉树的转换
  由于二叉树和树都可用二叉链表作为存储结构，则以二叉链表作为媒介可导出树与二叉树之间的一个对应关系。也就是说，给定一棵树，可以找到唯一的一棵二叉树与之对应，从物理结构来看，它们的二叉链表是相同的，只是解释不同而已。图6．16直观地展示了树与二叉树之间的对应关系。
    从树的二叉链表表示的定义可知，任何一棵和树对应的二叉树，其右子树必空。若把森林中第二棵树的根结点看成是第一棵树的根结点的兄弟，则同样可导出森林和二叉树的对应关系。
例如．图6．17展示了森林与二叉树之间的对应关系。
图6．15图6．13中树的二叉链表表示法
二叉树
图6．16树与二叉树的对应关系示例    
树与二叉树对应
    图6．17森林与二叉树的对应关系示例
    这个一一对应的关系导致森林或树与二叉树可以相互转换，其形式定义如下：
    一、森林转换成二叉树
    如果F：{T1，T2，…，T。}是森林，则可按如下规则转换成一棵二叉树B=(，"oot，LB，RB)。    
    (1)若F为空，即m=0，则B为空树；
    (2)若F非空，即m≠0，则B的根root即为森林中第一棵树的根00T(T1)；B的左子树LB是从T1中根结点的子树森林F1={丁1l'T12，…，T1。1}转换而成的二叉树；其右子树．RB是从森林F’={T2，T3，…，L}转换而成的二叉树。
  二、二叉树转换成森林
  如果B=(root，LB，RB)是一棵二叉树，则可按如下规则转换成森林
F={Tl，2，…，。}：
    (1)若B为空，则F为空；
    (2)若B非空，则F中第一棵树T1的根RO()T(T1)即为二叉树B的根root；T中根结点的子树森林F1是由B的左子树LB转换而成的森林；F中除T1之外其余树组成的森林F’={T：，丁3，…，丁。}是由B的右子树RB转换而成的森林。
    从上述递归定义容易写出相互转换的递归算法。同时，森林和树的操作亦可转换成二叉树的操作来实现。
  6．4．3树和森林的遍历
  由树结构的定义可引出两种次序遍历树的方法：一种是先根(次序)遍历树，即：先访问树的根结点，然后依次先根遍历根的每棵子树；另一种是后根(次序)遍历，即：先依次后根遍历每棵子树，然后访问根结点。
    例如，对图6．16的树进行先根遍历，可得树的先根序列为    A B C D E
若对此树进行后根遍历，则得树的后根序列为：    B D C E A
　　按照森林和树相互递归的定义，我们可以推出森林的两种遍历方法：
　　 一、先序遍历森林
    若森林非空，则可按下述规则遍历之：
    (1)访问森林中第一棵树的根结点；
    (2)先序遍历第一棵树中根结点的子树森林；
    (3)先序遍历除去第一棵树之后剩余的树构成的森林。
    二、中序遍历森林
    若森林非空，则可按下述规则遍历之：
    (1)中序遍历森林中第一棵树的根结点的子树森林；
    (2)访问第一棵树的根结点；
    (3)中序遍历除去第一棵树之后剩余的树构成的森林。    ．
    若对图6．17中森林进行先序遍历和中序遍历，则分别得到森林的先序序列为A B C D E F G H I J
中序序列为    B C D A F E H J I G
    由上节森林与二叉树之间转换的规则可知，当森林转换成二叉树时，其第一棵树的子树森林转换成左子树，剩余树的森林转换成右子树，则上述森林的先序和中序遍历即为其对应的二叉树的先序和中序遍历。若对图6．17中和森林对应的二叉树分别进行先序和中序遍历，可得和上述相同的序列。
    由此可见，当以二叉链表作树的存储结构时，树的先根遍历和后根遍历可借用二叉树的先序遍历和中序遍历的算法实现之。
6．5树与等价问题
    在离散数学中，对等价关系和等价类的定义是：
    如果集合S中的关系R是自反的、对称的和传递的，则称它为一个等价关系。
    设R是集合s的等价关系。对任何z∈S，由[z]R={y 1 3，∈SzRy}给出的集合[z]R∈s称为由z∈S生成的一个R等价类。
    若R是集合S上的一个等价关系，则由这个等价关系可产生这个集合的唯一划分。即可以按R将S划分为若干不相交的子集S1，S2，…，它们的并即为S，则这些子集Si便称为S的R等价类。
    等价关系是现实世界中广泛存在的一种关系，许多应用问题可以归结为按给定的等价关系划分某集合为等价类，通常称这类问题为等价问题。
    例如在FORTRAN语言中，可以利用EQUIVNCE语句使数个程序变量共享同一存储单位，这问题实质就是按EQtJIVALANCE语句确定的关系对程序中的变量集合进行划分，所得等价类的数目即为需要分配的存储单位，而同一等价类中的程序变量可被分配到同一存储单位中去。此外，划分等价类的算法思想也可用于求网络的最小生成树等图的算法中。
    应如何划分等价类呢?假设集合s有n个元素，m个形如(z，y)(z，y∈s)的等价偶对确定了等价关系R，需求S的划分。
    确定等价类的算法可如下进行：
    (1)令s中每个元素各自形成一个只含单个成员的子集，记作S1，S2，…，S。
    (2)重复读入脚个偶对，对每个读入的偶对(z，y)，判定z和y所属子集。不失一般性，假设z∈sy∈sf，若si≠s，，则将si并入si并置si为空(或将S并入si并置S为空)。则当n个偶对都被处理过后，s，，s2，…S。中所有非空子集即为s的R等价类。
    从上述可见，划分等价类需对集合进行的操作有三个：其一是构造只含单个成员的集合；其二是判定某个单元素所在子集；其三是归并两个互不相交的集合为一个集合。由此，需要一个包含上述三种操作的抽象数据类型MFSet。
ADTFSet{
　　数据对象：若设s是MFSet型的集合，则它由n(n>0)个子集si(i=1，2，…，n)构成，每个子集的成员都是子界[。mLumber]内的整数；
　　数据关系：s1U S2U…Us。=s sics(i=1，2，…，n)
    基本操作：
  Initial(&S，n，。l，X2，…，)；
    操作结果：初始化操作。构造～个由n个子集(每个子集只含单个成员x。)构成的集合s。  Fiha(s，x)；
    初始条件：s是已存在的集合，x是s中某个子集的成员。
    操作结果：查找函数。确定s中x所属子集s：。
  Merge(&s，i，j)；    
    初始条件：s。和s。是s中的两个互不相交的非空集合。
    操作结果：归并操作。将s。和s、中的一个并入另一个中。
I^MFSet；
    以集合为基础(结构)的抽象数据类型可用多种实现方法，如用位向量表示集合或用有序表表示集合等。如何高效地实现以集合为基础的抽象数据类型，则取决于该集合的大小以及对此集合所进行的操作。根据MFSeT类型中定义的操作FIND(S，x)和MERGE(si，sj)的特点，我们可利用树型结构表示集合。约定：以森林F=(T1，2，…，T。)表示MFSet型的集合s，森林中的每一棵树Ti(i：l，2，…，n)表示s中的一个元素子集Si(SicS，卢1，2，…，”)，树中每个结点表示子集中的一个成员z，为操作方便起见，令每个结点中含有一个指向其双亲的指针，并约定根结点的成员兼作子集的名称。例如，图6．18(a)和(b)中的两棵树分别表示子集S】={1，3，6，9}和S2：{2，8，10}。
显然，这样的树形结构易于实现上述两种集合的操作。由于各子集中的成员均不相同，则实现集合的“并”操作，只要将一棵子集树的根指向另一棵子集树的根即可。例如：图6．18(c)中s3=s，U S2。同时，完成找某个成员所在集合的操作，只要从该成员结点出发，顺链而进，直至找到树的根结点为止。
    图6．18集合的一种表示法
    (a)S1={1，3，6，9}；(b)S2={2，8，10}；(c)S3：SlU S2。
为便于实现这样两种操作，应采用双亲表示法作存储结构，如下所示
∥…ADT MFSet的树的双亲表存储表示…
typedef PTree  MFSet：
此时，查找函数和归并操作的实现如算法6．8和算法6．9所示。
int findmfset(MFSet s。int i){
  ∥找集合s中i所在子集的根。
  if(i<1 ll i>s．n)return  1；    ∥i不属s中任一子集
  for(j=i；s．nodes[j]．parent>0；j=s．rlodes[j]．parent)；
  return j；
}∥findmfset
    算法6．8
Status mergemfset(MFSet&s，int i，int j){
  ∥s．nodes[i]和s．nodes[j]分别为s的互不相交的两个子集si和sj的根结点。
  ∥求并集siUsj。
  if(i<1 ll i>s．n ll j<1《j>s．n)return ERROR；
  s．nodes[i]．parent：j；
  return OK；
＼l}merge-mfset
    算法6．9
    算法6．8和算法6．9的时间复杂度分别为0(d)和0(1)，其中d是树的深度。从前面的讨论可知，这种表示集合的树的深度和树形成的过程有关。试看一个极端的例子。假设有n个子集s1，s2，…，&，每个子集只有一个成员si={i}1，…，n，可用n棵只有一个根结点的树表示，如图6．21(a)表示。现作n-1次“并”操作，并假设每次都是含成员多的根结点指向含成员少的根结点，则最后得到的集合树的深度为n，如图6．19(b)所示。如果再加上在每次“并”操作之后都要进行查找成员“1”所在子集的操作，则全部操作的时间便是0(n0)了。
　　改进的办法是在作“并”操作之前先判别子集中所含成员的数目，然后令含成员少的子集树根结点指向含成员多的子集的根。为此，需相应地修改存储结构：令根结点的parent域存储子集中含成员数目的负值。修改后的“并”操作算法如算法6.10所示。
　　void…mfset(~IFSet：＆s，int 1．int]){
  ∥S nos[，]S nodes[]]分别为S的互不相交
  ∥的两个子集s1和0]的根结点。求并集siUs3
  if(1<1 l 1>S n11]<1【I J>S n1
    rBturn ERR]R：
if(s nodes[1]i~x,ent>s rms[]]
∥si所含成员数比s]少
    S nodes[j]parerS nodes[1]parer；
    算法6 10
图6 19“并”操作的一种极端情形
    可以证明，按算法6 10进行“并”操作得到的集合树，其深度不超过log2。其中n为集合S中所有子集所含成员数的总和。
    由此，利用算法find mfset和mix mfset解等价问题的时间复杂度为O(，Jlog”)(当集合中有”个元素时，至多进行”1次mix操作)。
    例6。1假设集合S=1z l≤_≤，j是正整数}，R是S l的一个等价关系。
    R={(1，2)，(3，4)，(5，6)，(7，8)，(1，3)，(5，7)，(1，5)，}
现求s的等价类。
　　以MFSet类型的变世S表示集合S，S中成员个数为S n。开始时，由于每个成员自成一个等价类，则S nodes[i]l~arent的值均为～I。之后，每处理一个等价偶对(i，J)，首先必须确定i和各自所属集合，若这两个集合相同．则说明此等价关系足多余的，无需作处理；否则就合并这两个集合。图6 20展示了处理R中前七个等价关系时S的变化状况(图中省去T结点的数据域)，图到6 21(a)所示为最后一个S状态相应的树的形态。显然，随着子集逐对合并，树的深度也越来越大，为了进一步减少确定元素所在集合的时间，我们还可进一步将算法6 8改进为算法6 ll。当所查元素i不在树的笫二层时，在算法中增加一个“压缩路径”的功能，即将所有从根到元素i路径上的元素都变成树根的孩子。
　　Int fix_mfset( MFSet &S, int i) {
  int fix―mfset(MFSet＆s。int i){
    ∥确定i所在子集，并将从i至根路径上所有结点都变成根的孩子结点。
    if(i<I．1 i>§．n)return-l；    ∥i不是S中任一子集的成员
    for(j=i；S．nodes[j]．parent>0；j：S．nodes[j]．parent)；
    for(k=i；k!=J；k=t){
    t=S．nodes[k]．parent；S．nodes[k]．parent：J；
    }
    return J；
    }∥fix-mfset
    算法6．II
S．nodes    S．nodes    S．nodes
图6．20求等价类过程示例．
    图6．21表示集合的树
    (a)压缩路径之前；(b)压缩路径之后。
    假设例6．1中R的第8个等价偶对为(8，9)，则在执行fix(s，8)的操作之后图6．21
(a)的树就变成图6．21(b)的树。
    已经证明，利用算法fix-mfset和mix-mfset划分大小为t／的集合为等价类的时间复杂度为O((n))。其中a(”)是一个增长极其缓慢的函数，若定义单变量的阿克曼函数为A(z)：A(z．。)，则函数a(n)定义为A(z)的拟逆，即a(n)的值是使A(z)≥Y成立的最小z。所以，对于通常所见到的正整数r／而言，a(n)≤4。
    
6．6赫夫曼树及其应用
    赫夫曼(14uffman)树，又称最优树，是一类带权路径长度最短的树，有着广泛的应用。本节先讨论最优二叉树。
  6．6．1最优二叉树(赫夫曼树)
  首先给出路径和路径长度的概念。从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径，路径上的分支数目称做路径长度。树的路径长度是从树根到每一结点的路径长度之和。6．2．1节中定义的完全二叉树就是这种路径长度最短的二叉树。
    若将上述概念推广到一般情况，考虑带权的结点。结点的带权路径长度为从该结点到树根之间的路径长度与结点上权的乘积。树的带权路径长度为树中所有叶子结点的带权路径长度之和，通常记作WPZ，=≥：twkl＆。
    假设有n个权值{1，W2，…，n。}，试构造一棵有n个叶子结点的二叉树，每个叶子结点带权为叫i，则其中带权路径长度WPI，最小的二叉树称做最优二叉树或赫夫曼树。
　　例如，图6．22中的三棵二叉树，都有4个叶子结点a、b、c、d，分别带权7、5、2、4，它们的带权路径长度分别为
　　    (a)WPI。=7×2+5×2+2×2+4×2=36
    (b)WPL，=7×3+5×3+2×1+4×2=46
    (c)WPL，=7×1+5×2+2×3+4×3=35
其中以(c)树的为最小。可以验证，它恰为赫夫曼树，即其带权路径长度在所有带权为7、5、2、4的四个叶子结点的二叉树中居最小。
图6．22具有不同带权路径长度的二叉树
　　在解某些判定问题时，利用赫夫曼树可以得到最佳判定算法。例如，要编制一个将百分制转换成五级分制的程序。显然，此程序很简单，只要利用条件语句便可完成。如：
　　if(a<60)b=”bad”；
else if(a<70)b=“pass”；
    else if(a<80)b=”general“：
    elseif(a<90)b=”gocrf-：
    e18e b=”excellent”：
这个判定过程可以图6．23(a)的判定树来表示。如果上述程序需反复使用，而且每次的输入量很大，则应考虑上述程序的质量问题，即其操作所需时间。因为在实际生活中，学生的成绩在五个等级上的分布是不均匀的。假设其分布规律如下表所示：
则80％以上的数据需进行三次或三次以上的比较才能得出结果。假定以5，15，40，30和10为权构造一棵有五个叶子结点的赫夫曼树，则可得到如图6．23(b)所示的判定过程，它可使大部分的数据经过较少的比较次数得出结果。但由于每个判定框都有两次比较，将这两次比较分开，我们得到如图6．23(c)所示的判定树，按此判定树可写出相应的程序。假设现有10000个输入数据，若按图6．23(a)的判定过程进行操作，则总共需进行31500次比较；而若按图6．23(c)的判定过程进行操作，则总共仅需进行22000次比较。
图6．23转换五级分制的判定过程
    那末，如何构造赫夫曼树呢?赫夫曼最早给出了一个带有一般规律的算法，俗称赫夫曼算法。现叙述如下：
　　(1)根据给定的n个权值{l，7,02，…，。}构成n棵二叉树的集合F={T，，，，…，T。}，其中每棵二叉树Ti中只有一个带权为wi的根结点，其左右子树均空。
    (2)在F中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左、右子树上根结点的权值之和。
    (3)在F中删除这两棵树，同时将新得到的二叉树加入F中。
    (4)重复(2)和(3)，直到F只含一棵树为止。这棵树便是赫夫曼树。
    例如，图6．24展示了图6．20(c)的赫夫曼树的构造过程。其中，根结点上标注的数字是所赋的权。
图6．24赫夫曼树的构造过程
  算法的具体描述和实际问题所采用的存储结构有关，将留在下节进行讨论。
  6．6．2赫夫曼编码
  目前，进行快速远距离通信的主要手段是电报，即将需传送的文字转换成由二进制的字符组成的字符串。例如，假设需传送的电文为’A B AC C D A’，它只有四种字符，只需两个字符的串便可分辨。假设A、B、C、D的编码分别为00、01、10和11，则上述七个字符的电文便为’00010010101100’，总长14位，对方接收时，可按二位一分进行译码。
    当然．在传送电文时，希望总长尽可能地短。如果对每个字符设计长度不等的编码，且让电文中出现次数较多的字符采用尽可能短的编码，则传送电文的总长便可减少。如果设计A、B、C、D的编码分别为0、00、1和01，则上述七个字符的电文可转换成总长为9的字符串’000011010’。但是，这样的电文无法翻译，例如传送过去的字符串中前四个字符的子串’0000’就可有多种译法，或是’AAAA’，或是’ABA’，也可以是’BB’等。因此，若要设计长短不等的编码，则必须是任一个字符的编码都不是另一个字符的编码的前缀，这种编码称做前缀编码。
    可以利用二叉树来设计二进制的前缀编码。假设有一棵如图6．25所示的二叉树，其四个叶子结点分别表示A、B、c、D四个字符，且约定左分支表示字符’0’，右分支表示字符’1’，则可以从根结点到叶子结点的路径上分支字符组成的字符串作为该叶子结点字符的编码。读者可以证明，如此得到的必为二进制前缀编码。如由图6．25所得A、B、C、D
的二进制前缀编码分别为0、10、110和111。
    又如何得到使电文总长最短的二进制前缀编码呢?假设每种字符在电文中出现的次数为wi，其编码长度为zi，电文中只有n种字符，则电文总长为∑wili。对应到二叉树上，若置wi为叶子结点的权，zi恰为从根到叶子的路径长度。则∑wili恰为二叉树上带权路径长度。由此可见，设计电文总长最短的二进制前缀编码即为以n种字符出现的频率作权，设计一棵赫夫曼树的问题，由此得到的二进制前缀编码便称为赫夫曼编码。
图6．25前缀编码示例
  下面讨论具体做法。
  由于赫夫曼树中没有度为1的结点(这类树又称严格的(strict)(或正则的)二叉树)，则一棵有n个叶子结点的赫夫曼树共有2n一1个结点，可以存储在一个大小为2n～1的一维数组中。如何选定结点结构?由于在构成赫夫曼树之后，为求编码需从叶子结点出发走一条从叶子到根的路径；而为译码需从根出发走一条从根到叶子的路径。则对每个结点而言，既需知双亲的信息，又需知孩子结点的信息。由此，设定下述存储结构：
∥～赫夫曼树和赫夫曼编码的存储表示
t~pedef struct{
  unsigned int weight；
  unsigned int parent，ichild，rchild；
}HTNode，*HuffmanTree；    ∥动态分配数组存储赫夫曼树
t~oedef char**HuffmanCode；／／动态分配数组存储赫夫曼编码表
求赫夫曼编码的算法如算法6．12所示。
void HuffmanCodinq(HuffmanTree&HT，HuffmanCode&HC，int*w，／nt n){
  ∥W存放n个字符的权值(均>0)，构造赫夫曼树HT，并求出n个字符的赫夫曼编码HC。
  if(n<=1)return；
  m=2*n一1：
  }rr=(HuffmanTree)malloc((m+1)*sizeof(HTNode))；  ∥0号单元未用
  for(P=HT，i=1；i<=n；++i，++P，++w)  *P={*W，0，0，0}；
  for(；i<=m；++i，+’P)  ”P={0，0，0，0}；
  for(i=n+I；i<=m；+十i){    ∥建赫夫曼树
    ∥在HT[1．．i-I]选择parent为0且weight最小的两个结点，其序号分别为s1和s2。
    Select(HT，i-l。sl，s2)；
    HTl s1 J．parent：i；HT[s2]．parent=i；
    HT【i J．ichild=sl；HT[ij．rchild=s2；
    HIr[i]．weight=HT[s1]．Weight+[s2]．weight；
  l
  //从叶子到根逆向求每个字符的赫夫曼编码
  HC：(HuffmanCede)malloc((n+1)*sizeof(char*))；  ∥分配n个字符编码的头指针向量
  cd=(char*)malloc(n*sizeof(char))；    ∥分配求编码的工作空间
  cd[n-1]=”＼0”；    ／／编码结束符。
  for(i=1；i<=n；++i)I    ∥逐个字符求赫夫曼编码
    start=n-1；    ∥编码结束符位置
    for(c。i，f=HT[i]．parent；f!=0；C=f，f=HT[f]．parent)∥从叶子到根逆向求编码
    if(HT[f]．ichild=；C)cd[--start]=”0“；
    else cd[--start]：“1”；
    HC[ij。(char*)malloc((n-start)*sizeof(char))；／／为第i个字符编码分配空间
    strcpy(HC[i]，&cd[start])；    ∥从cd复制编码(串)到Hc
  }
  free(cd)；    ／／释放工作空间
、f?HuffanCoding
    算法6．12
向量HT的前”个分量表示叶子结点，最后一个分量表示根结点。各字符的编码长度不等，所以按实际长度动态分配空间。在算法6．12中，求每个字符的赫夫曼编码是从叶子到根逆向处理的。也可以从根出发，遍历整棵赫夫曼树，求得各个叶子结点所表示的字符的赫夫曼编码，如算法6．13所示。
∥无栈非递归遍历赫夫曼树，求赫夫曼编码
HC=(HuffmanCode)malloc((n+1)*sizeof(char*))；
P：m；cdlen=0；
for(i=1；i<=m；++i)HT[i]．weight：0；∥遍历赫夫曼树时用作结点状态标志
while(P){
  if(HT[p]．weight==0){    ∥向左
    HT[Pj．weight=1；
    if(}rr[p]．ichild!=0){P=HT[p]．ichild；cd[cdlen++]=”0”；}
    else if(HT[p]．rchild：=0){    ∥登记叶子结点的字符的编码
    HC[p]：(char*)aalloc((cdlen+1)*sizeof(char))；
    cd[cdlen]=”＼0”；strcpy(HC[p]，cd)；    ∥复制编码(串)
    I
    }
    else if(HT[p]．weight：：1){    ∥向右
   [pJ．weight=2；
    if(}rr[p]．rchild!=0){P=HT[p]．rchild；cd[cdlen++]=”1“；}
    }else{    ∥HT[p]．weight==2，退回
    }rr[p]．weight=0；P=HT[p]．parent；一一cdlen；∥退到父结点，编码长度减1
    ＼|}else    
}∥While
    算法6．13
    图6．26例6-2的赫夫曼树
    译码的过程是分解电文中字符串，从根出发，按字符～0或～1确定找左孩子或右孩子，直至叶子结点，便求得该子串相应的字符。具体算法留给读者去完成。
    例6-2  已知某系统在通信联络中只可能出现八种字符，其频率分别为0．05，0．29，0．07，0．08，0．14，0．23，0．03，0．11，试设计赫夫曼编码。
    设权=(5，29，7，8，14，23，3，11)，：8，则优=15，按上述算法可构造一棵赫夫曼树如图6．26所示。其存储结构HT的初始状态如图6．27(a)所示，其终结状态如图6．27(b)所示，所得赫夫曼编码如图6．27(c)所示。
图6．27例6-2的存储结构
    (a)HT的初态；
    (b)HT的终态；
    (c)赫夫曼编码HC
6．7回溯法与树的遍历
    在程序设计中，有相当一类求一组解、或求全部解或求最优解的问题，例如读者熟悉的八皇后问题等，不是根据某种确定的计算法则，而是利用试探和回溯(Backtracking)的搜索技术求解。回溯法也是设计递归过程的一种重要方法，它的求解过程实质上是一个先序遍历一棵“状态树”的过程，只是这棵树不是遍历前预先建立的，而是隐含在遍历过程中，但如果认识到这点，很多问题的递归过程设计也就迎刃而解了。为了说明问题，先看一个简单例子。
    例6．3求含n个元素的集合的幂集。
    集合A的幂集是由集合A的所有子集所组成的集合。如：A=f1，2，3}，则A的幂集
    p(A)={{l，2，3}，{1，2}，{1，3}，{1}，{2，3}，{2}，{3}，}    (6―6)
　　当然，可以用5．7节介绍的分治法来设计这个求幂集的递归过程。在此，从另一角度分析问题。幂集的每个元素是一个集合，它或是空集，或含集合A中一个元素，或含集合A中两个元素，或等于集合A。反之，从集合A的每个元素来看，它只有两种状态：它或属幂集的元素集，或不属幂集元素集。则求幂集iD(A)的元素的过程可看成是依次对集合A中元素进行“取”或“舍(弃)”的过程，并且可以用一棵如图6．28所示的二叉树，来表示过程中幂集元素的状态变化状况，树中的根结点表示幂集元素的初始状态(为空集)；叶子结点表示它的终结状态(如图6．28中8个叶子结点表示式(6．6)中幂集fD(A)的8个元素)；而第i(1，2，3，…，n-1)层的分支结点，则表示已对集合A中前i-1个元素进行了取／舍处理的当前状态(左分支表示“取”，右分支表示“舍”)。因此求幂集元素的过程即为先序遍历这棵状态树的过程，如算法6．14所描述。
6．28幂集元素在生成过程中的状态图
vold Powerset(如．t i，int n){
  ∥求含n个元素的集合A的幂集P(A)。进入函数时已对A中前i一1个元素作了取舍处理，
  ∥现从第i个元素起进行取舍处理。若i>n，则求得幂集的一个元素，并输出之。
  ∥初始调用：PowerSet(1，n)；
  if(i>n)输出幂集的一个元素；
  else j取第i个元素；PowerSet(i+1，n)；
    舍第i个元素；PowerSet：(i+1，n)；
    }
＼fI PowerSet
    算法6．14‘
    对算法6．14求精需确定数据结构。假设以线性表表示集合，则求精后的算法如算法6．15所示。
Vold GetPowerSet(int i，List A，L1st＆B){
    ∥线性表A表示集合A，线性表B表示幂集p(A)的一个元素。
    ∥局部量k为进入函数时表B的当前长度。第一次调用本函数时，B为空表。i=1。
    if(i>ListLength(A))Output(B)；  ∥输出当前B值。即p(A)的一个元素
    e18e{GetEl(A，i，x)；    k：ListLength(B)；
    Listlnserlt(B，k+1，x)；    GetPowerSet(i+1，A，B)；
    ListDelete(B，k+l，x)；    GetPowerSet(i+1，A，B)；
    }
  }∥Get：P0werset
    算法6。15
    图6．28中的状态变化树是一棵满二叉树，树中每个叶子结点的状态都是求解过程中可能出现的状态(即问题的解)。然而很多问题用回溯和试探求解时，描述求解过程的状态树不是一棵满的多叉树。当试探过程中出现的状态和问题所求解产生矛盾时，不再继续试探下去，这时出现的叶子结点不是问题的解的终结状态。这类问题的求解过程可看成是在约束条件下进行先序(根)遍历，并在遍历过程中剪去那些不满足条件的分支。
　　例6―4求四皇后问题的所有合法布局(作为例子，我们将八皇后问题简化为四皇后问题)。
　　6．29  四皇后问题的棋盘状态树
    图6．29展示求解过程中棋盘状态的变化情况j这是一棵四又树，树上每个结点表示一个局部布局或一个完整的布局。根结点表示棋盘的初始状态：棋盘上任何棋子，每个(皇后)棋子都有四个可选择的位置，但在任何时刻，棋盘的合法布局都必须满足三个约束条件，即任何两个棋子都不占据棋盘上的同一行、或者同一列、或者同一对角线。图6．29中除结点a之外的叶子结点都是不合法的布局。
    求所有合法布局的过程即为在上述约束条件下先根遍历图6．29的状态树的过程，遍历中访问结点的操作为，判别棋盘上是否已得到一个完整的布局(即棋盘上是否已摆上四个棋子)，若是，则输出该布局；否则依次先根遍历满足约束条件的各棵子树，即首先判断该子树根的布局是否合法，若合法，则先根遍历该子树，否则剪去该子树分支。算法6．16为求所有合法布局的伪码算法：
void Trial(int i，int n){
  ∥进入本函数时，在n×n棋盘前i-1行已放置了互不攻击①的i-1个棋子：
  ∥现从第i行起继续为后续棋f选择合适①位置。
  ∥当i>n时，求得个合法布局，输出之。
  if(i>n)输出棋盘的当前布局；    ∥n为4时，即为4皇后问题
  elBefoz(j=l；j<：n；++j){
    在第i行第j列放置一个棋f；
}∥Trial
if(当前布局合法)Trial(i十1，n)；
移走第i行第j列的棋子；
算法6．16
  算法6．16可进一步求精，在此从略。算法6．16可作为回溯法求解的一般模式，类似问题有骑士游历、迷宫问题、选最优解问题等等。
6．8树的计数
    本节将讨论的树的计数问题的提法是：具有n个结点的不同形态的树有多少棵?下面我们先讨论二叉树的情况，然后可将结果推广到树。
    在讨论二叉树的计数之前应先明确两个不同的概念。
    称二叉树T和T’相似是指：二者都为空树或者二者均不为空树，且它们的左右子树分别相似。
    称二叉树T和T’等价是指：二者不仅相似，而且所有对应结点上的数据元素均相同。
    二叉树的计数问题就是讨论具有”个结点、互不相似的二叉树的数目6。
    在n值很小的情况下，可直观地得到：60=1为空树；6l=1是只有一个根结点的树；62=2和63=5，它们的形态分别如图6．30(a)和图6．30(b)所示。那末，在n>3时又如何呢?
    图6．30二叉树的形态
。(a)n=2，(b)n=3；(c)一般情形n>1。
    一般情况下，一棵具有”(”>1)个结点的二叉树可以看成是由一个根结点、一棵具有i个结点的左子树、和一棵具有，z―i一1个结点的右子树组成(如图6．30(c)所示)，其中0≤i≤n一1。由此可得下列递推公式：
    可以利用生成函数来讨论这个递推公式。
    对序列 b0，b1，…bn定义生成函数
因为
根据(6．7)
由此得
即
60，61，…，b。，…
B(z)=b0+61z+6222+…+6nz“+‘’
B2(z)=b060+(60b1+blb0)z+(60b2+bl b1+bEbo)Z2+…
解此二次方程得
B。(g)
由初值60。l，应有B(z)=bo。
所以
利用二项式展开
    当k=0时，式(6―10)的第一项为1，故有
对照(6―8)和(6．11)而得
因此，含有”个结点的不相似的二叉树有鲁c!。棵。
    我们还可以从另一个角度来讨论这个问题。从二叉树的遍历已经知道，任意一棵二叉树结点的前序序列和中序序列是唯一的。反过来，给定结点的前序序列和中序序列，能否确定一棵二叉树呢?又是否唯一呢?
    由定义，二叉树的前序遍历是先访问根结点D，其次遍历左子树L，最后遍历右子树R。即在结点的前序序列中，第一个结点必是根D；而另一方面，由于中序遍历是先遍历左于树I．，然后访问根D，最后遍历右子树R，则根结点D将中序序列分割成两部分：在D之前是左子树结点的中序序列，在D之后是各子树结点的中序序列。反过来，根据左子树的中序序列中结点个数，又可将前序序列除根以外分成左子树的前序序列和右子树的前序序列两部分。依次类推，便可递归得到整棵二叉树。
    例6―5  已知结点的前序序列和中序序列分别为：
    前序序列U：A B C D E F G
    中序序列：C B E D A F G
则可按上述分解求得整棵二叉树。其构造过程如图6．31所示。首先由前序序列得知二叉树的根为A，则其左子树的中序序列为(CBED)，又右子树的中序序列为(FG)。反过来得知其左子树的前序序列必为(BcDE)，右子树的前序序列为(FG)。类似地，可由左子树的前序序列和中序序列构造得A的左子树，由右子树的前序序列和中序序列构造得A的右子树。
图6．3l  由前序和中序序列构造一棵二叉树的过程
    上述构造过程说明了给定结点的前序序列和中序序列，可确定一棵二叉树。至于它的唯一性，读者可试用归纳法证明之。
    我们可由此结论来推论具有”个结点的不同形态的二叉树的数目。
图6．32具有不同中序序列的二叉树
　　假设对二叉树的n个结点从1到n加以编号，且令其前序序列为1，2，…，”，则由前面的讨论可知，不同的二叉树所得中序序列不同。如图6．32所示两棵有8个结点的二叉树，它们的前序序列都是12345678，而(a)树的中序序列为32465178，(b)树的中序序列为23147685。因此，不同形态的二叉树的数目恰好是前序序列均为12…竹的二叉树所能得到的中序序列的数目。而中序遍历的过程实质上是一个结点进栈和出栈的过程。二叉树的形态确定了其结点进栈和出栈的顺序，也确定了其结点的中序序列。
    图6．33中序遍历时进战和出栈的过程    
　　例如图6．33中所示(a)    (b)    (c)    (d)    (e)
为”=3时不同形态的二叉树在中序遍历时栈的状态和访问结点次序的关系。由此，由前序序列12…，z所能得到的中序序列的数目恰为数列12…，z按不同顺序进栈和出栈所能得到的排列的数目。这个数目为
图6．34具有不同形态的树和二叉树

    由二叉树的计数可推得树的计数。由“6．4．2森林与二叉树的转换”中可知一棵树可转换成唯一的一棵没有右子树的二叉树，反之亦然。则具有n个结点有不同形态的树的数目t。和具有n-1个结点互不相似的二叉树的数目相同。即￡。=6。-1。图6．34展示了具有4个结点的树和具有3个结点的二叉树的关系。从图中可见，在此讨论树的计数是指有序树，因此(c)和(d)是两棵有不同形态的树(在无序树中，它们被认为是相同的)。
① 参考书目[3]中译本第457页。

