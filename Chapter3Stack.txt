
第3章栈和队列
    栈和队列是两种重要的线性结构。从数据结构角度看，栈和队列也是线性表，其特殊性在于栈和队列的基本操作是线性表操作的子集，它们是操作受限的线性表，因此，可称为限定性的数据结构。但从数据类型角度看，它们是和线性表大不相同的两类重要的抽象数据类型。由于它们广泛应用在各种软件系统中，因此在面向对象的程序设计中，它们是多型数据类型。本章除了讨论栈和队列的定义、表示方法和实现外，还将给出一些应用的例子。  
    3．1  栈
  3．1．1抽象数据类型栈的定义
  栈(Stack)  是限定仅在表尾进行插入或删除操作的线性表。因此，对栈来说，表尾端有其特殊含义，称为栈顶(top)，相应地，表头端称为栈底(bottom)。不含元素的空表称为空栈。
    假设栈S=(。。，口2，…，n。)，则称口1为栈底元素，a。为栈顶元素。栈中元素按n，，az，…，口。的次序进栈，退栈的第一个元素应为栈顶元素。换句话说，栈的修改是按后进先出的原则进行的(如图3．1(a)所示)。因此，栈又称为后进先出(I．ast In First Out)的线性表(简称LIFO结构)，它的这个特点可用图3．1(b)所示的铁路调度站形象地表示。
出栈    进栈    出栈
进栈
    图3．1栈
(a)栈的示意图；  (b)用铁路调度站表示栈。
    栈的基本操作除了在栈顶进行插入或删除外，还有栈的初始化、判空及取栈顶元素等。下面给出栈的抽象数据类型的定义：
    Stack i
    数据对象：D={ail ai∈Ele~Set，i=1，2，…，n，  n≥0}
    数据关系：R1={<ai．1，ai>I ai一1，ai∈D，i=2，…，n}
    约定a。端为栈顶，a，端为栈底。
  基本操作：
    InitStack(＆s)
  操作结果：构造一个空栈s。
    DestroyStack(＆s)
  初始条件：栈s已存在。    
  操作结果：栈s被销毁。
    clearStack(＆s)    
  初始条件：栈s已存在。
  操作结果：将s清为空栈。
    StackEmpty(S)    ’
  初始条件：栈s已存在。
  操作结果：若栈s为空栈；则返回TRUE，否则FALSE。
    StackLength(s)
  初始条件：栈s已存在。
  操作结果：返回s的元素个数，即栈的长度。
    GetTop(s，＆e)
  初始条件：栈s已存在且非空。
  操作结果：用e返回s的栈顶元素。
    Push(&s，e)
  初始条件：栈s已存在。
  操作结果：插入元素e为新的栈顶元素。
    Pop(&s，＆e)
    初始条件：栈s已存在且非空。
    操作结果：删除s的栈顶元素，并用e返回其值。
    StackTraverse(s，visi七())
    初始条件：栈s已存在且非空。
    操作结果：从栈底到栈顶依次对s的每个数据元素调用函数visit()。一旦visit()失败，则操作失效。
}ADT Stack
    本书在以后各章中引用的栈大多为如上定义的数据类型，栈的数据元素类型在应用程序内定义，并称插入元素的操作为入栈，删除栈顶元素的操作为出栈。
3．1．2栈的表示和实现
    和线性表类似，栈也有两种存储表示方法。
    顺序栈，即栈的顺序存储结构是，利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，同时附设指针top指示栈顶元素在顺序栈中的位置。通常的习惯做法是以top=0表示空栈，鉴于c语言中数组的下标约定从O开始，则当以c作描述语言时，如此设定会带来很大不便；另一方面，由于栈在使用过程中所需最大空间的大小很难估计，因此，一般来说，在初始化设空栈时不应限定栈的最大容量。一个较合理的做法是：先为栈分配一个基本容量，然后在应用过程中，当栈的空间不够使用时再逐段扩大。为此，可设定两个常量：sTACK―INIT―SIZE(存储空间初始分配量)和SnKKINCREMENT(存储空间分配增量)，并以下述类型说明作为顺序栈的定义。
typedef struct{
    SEl~Type  *base~
    SElemType  *top；
    stacksize：
    I SqStack；
其中，stacksize指示栈的当前可使用的最大容量。栈的初始化操作为：按设定的初始分配量进行第一次存储分配，baSe可称为栈底指针，在顺序栈中，它始终指向栈底的位置。若base的值为NULL，则表明栈结构不存在。称top为栈顶指针，其初值指向栈底，即top=base可作为栈空的标记，每当插入新的栈顶元素时，指针top增1；删除栈顶元素时，指针top减1，因此，非空栈中的栈顶指针始终在栈顶元素的下一个位置上。图3．2展示了顺序栈中数据元素和栈顶指针之间的对应关系。    
图3．2栈顶指针和栈中元素之间的关系
以下是顺序栈的模块说明。
／／==…ADT Stack的表示与实现=====
    ∥…栈的顺序存储表示…
#defi~STACKTNIT-SIZE 100；  ／／存储空间初始分配量
#define sTAINCl  10；    ／／存储空间分配增量
t《struut{
    SEl~Type  *base；  ／／在栈构造之前和销毁之后，base的值为NULL
    SEleaType*top；  ／／栈顶指针
    int stacksize~    ／／当前已分配的存储空间，以元素为单位
}SqSt~；
∥…・基本操作的函数原型说明…
Status InitStack(SqStack＆s)；
    ∥构造一个空栈S
 Ststum DestroyStack(S~Stack＆s)；
    ∥销毁栈S，S不再存在
Stst~ClearStack(SqStack＆s)；
    ∥把S置为空栈
Status S~ckEmpty(SqStack s)；
    ∥若栈S为空栈，则返回TRUE，否则返回FALSE
 int stacl【【gth(SqStack s)；
    ∥返回S的元素个数，即栈的长度
Status GetTop(SqStacl【S，SElemType＆e)；
    ∥若栈不空，则用e返回S的栈顶元素，并返回OK；否则返回ERROR
Status Push(SqStack&s，SElemType e)；
    ∥插入元素e为新的栈顶元素
Status Pop(SqStack＆S，SE[emType＆e)；
    ∥若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR
Status StackTraverse(SqStack S，Status(*visit)())；
    ∥从栈底到栈顶依次对栈中每个元素调用函数visit()。一旦visit()失败，则操作失败
　　∥…基本操作的算法描述(部分)…
　　Status InitStack(SqStack&s){
  ∥构造一个空栈S
  S．base：(SElemType*)mallet(STACK～INIT―SIZE*sizeof(ElemType))；
  if(!S．base)exit(O~_aFLOW)；  ∥存储分配失败
  S．top=S．base：
  S．stacksize=STACK―INIT―SIZE：
  return OK；    
}／／InitStack
Status GetTop(SqStack S，SElemType＆e){
  ∥若栈不空，则用e返回S的栈顶元素，并返回OK；否则返回ERROR
  if(S．top：=S．base)  return ERROR；
    e=*(S．top一1)；
    return OK；
}
GetTop
Status Push(SqStack＆s，SElemType e){
    ∥插入元素e为新的栈顶元素
    if(S．top-S．base>=S．stacksize){∥栈满，追加存储空间
    S．base=(ElemType*)realloc(S．base，
    (S．stacksize+STACKINCREMENT)*sizeof(ElemType))；
    if(!S．base)exit(OVERFLOW)；／／存储分配失败
    S．top：S．base+S．stacksize：
    S．stacksize+=STACKINCREMENT；
  }
  *S．top++=e：
  return OK；
／／Push
Status Pop(SqStack&s，SElemType＆e){
    ∥若栈不空，则删除S的栈顶元素，用e返回其值，并返回
    OK；否则返回ERROR
    if(S．top=；S．base)return ERROR；
    e。*--S．top：
    return OK；
、}}Pop
栈顶
栈底
图3．3链栈示意图
    栈的链式表示――链栈如图3．3所示。由于栈的操作是线性表操作的特例，则链栈的操作易于实现，在此不作详细讨论。
3．2栈的应用举例
    由于栈结构具有的后进先出的固有特性，致使栈成为程序设计中的有用工具。本节将讨论几个栈应用的典型例子。
    3．2．1数制转换
    十进制数N和其他d进制数的转换是计算机实现计算的基本问题，其解决方法很多，其中一个简单算法基于下列原理：
    N=(N div d)×d+N mod(其中：div为整除运算，mod为求余运算)
    例如：(1348)10=(2504)8，其运算过程如下：
    N    N div 8    N mod 8
    1348    168    4
    168    21    0
    21    2    5
    2    0    2
    假设现要编制一个满足下列要求的程序：对于输入的任意一个非负十进制整数，打印输出与其等值的八进制数。由于上述计算过程是从低位到高位顺序产生八进制数的各个数位，而打印输出，一般来说应从高位到低位进行，恰好和计算过程相反。因此，若将计算过程中得到的八进制数的各位顺序进栈，则按出栈序列打印输出的即为与输入对应的八进制数。
    v,oid conversion(){
    ∥对于输入的任意一个非负十进制整数，打印输出与其等值的八进制数
    InitStack(s)；    ∥构造空栈
    8ca《(”％∥，N)；
    while(N){
    Push(s，N％8)；
    N=S／8：
    }
    While(!StackEmpty){
    Pop(s，e)；
    prirltf(”％f，e)；
    }
    }∥conversiorl
    算法3．1
这是利用栈的后进先出特性的最简单的例子。在这个例子中，栈操作的序列是直线式的，即先一味地入栈，然后一味地出栈。也许，有的读者会提出疑问：用数组直接实现不也很简单吗?仔细分析上述算法不难看出，栈的引入简化了程序设计的问题，划分了不同的关注层次，使思考范围缩小了。而用数组不仅掩盖了问题的本质，还要分散精力去考虑数组下标增减等细节问题。
3．2．2括号匹配的检验
　　假设表达式中允许包含两种括号：圆括号和方括号，其嵌套的顺序随意，即(【]())等为正确的格式，[(])或([())或(()])均为不正确的格式。检验括号是否匹配的方法可用“期待的急迫程度”这个概念来描述。例如考虑下列括号序列：
　　    1 2 3 4 5 6 7 8
当计算机接受了第一个括号后，它期待着与其匹配的第八个括号的出现，然而等来的却是第_二个括号，此时第一个括号“[”只能暂时靠边，而迫切等待与第二个括号相匹配的、第七个括号“)”的出现，类似地，因等来的是第三个括号“[”，其期待匹配的程度较第二个括号更急迫，则第二个括号也只能靠边，让位于第三个括号，显然第二个括号的期待急迫性高于第一个括号；在接受了第四个括号之后，第三个括号的期待得到满足，消解之后，第二个括号的期待匹配就成为当前最急迫的任务了，……，依次类推。可见，这个处理过程恰与栈的特点相吻合。由此，在算法中设置一个栈，每读入一个括号，若是右括号，则或者使置于栈顶的最急迫的期待得以消解，或者是不合法的情况；若是左括号，则作为一个新的更急迫的期待压入栈中，自然使原有的在栈中的所有未消解的期待的急迫性都降了一级。
另外，在算法的开始和结束时，栈都应该是空的。此算法将留给读者作为习题完成。
3．2．3行编辑程序
    一个简单的行编辑程序的功能是：接受用户从终端输入的程序或数据，并存入用户的数据区。由于用户在终端上进行输入时，不能保证不出差错，因此，若在编辑程序中，“每接受一个字符即存入用户数据区”的做法显然不是最恰当的。较好的做法是，设立一个输入缓冲区，用以接受用户输入的一行字符，然后逐行存入用户数据区。允许用户输入出差错，并在发现有误时可以及时更正。例如，当用户发现刚刚键入的一个字符是错的时，可补进一个退格符“#”，以表示前一个字符无效；如果发现当前键入的行内差错较多或难以补救，则可以键入一个退行符“@”，以表示当前行中的字符均无效。例如，假设从终端接受了这样两行字符：
    whli##ilr#e(s#*s)
    outcha@putchar(*s=#++)；
则实际有效的是下列两行：
    while(*s)
    putcbar(*s++)；
    为此，可设这个输入缓冲区为一个栈结构，每当从终端接受了一个字符之后先作如下
判别：如果它既不是退格符也不是退行符，则将该字符压入栈顶；如果是一个退格符，则从
栈顶删去一个字符；如果它是一个退行符，则将字符栈清为空栈。上述处理过程可用算法
3．2描述之。
void LineEdJt(){
  ∥利用字符栈飞，从终端接收一行并传送至调用过程的数据区。
  InitStack(s)；    ∥构造空栈s
  ch：getchar()；    ∥从终端接收第一个字符
  ．hile(ch f_日oF){∥EOF为全文结束符
    while(ch!=@OF＆&ch!=’＼n’){
    swi．tch(ch){
    case’#。：Pop(s，c)；    break；∥仅当栈非空时退栈
    case’@’：clearStack(s)；  break；∥重置s为空栈
    defau]t：Push(’s，ch)；    break；∥有效字符进栈，未考虑栈满情形
    }
    ch=getchar()；  ∥从终端接收下一个字符
    I
    将从栈底到栈顶的栈内字符传送至调用过程的数据区；
    clearStack(s)；    ∥重置s为空栈
    if(ch。!：mr)ch=getch~r()；
  }
  DestroyStack(s)；
I／／L1need／．t
算法3．2
3．2．4迷宫求解
求迷宫中从入口到出口的所有路径是一个经典的程序设计问题。由于计算机解迷宫时，通常用的是“穷举求解”的方法，即从入口出发，顺某一方向向前探索，若能走通，则继续往前走；否则沿原路退回，换一个方向再继续探索，直至所有可能的通路都探索到为止。为了保证在任何位置上都能沿原路退回，显然需要用一个后进先出的结构来保存从入口到当前位置的路径。因此，在求迷宫通路的算法中应用“栈”也就是自然而然的事了。
    首先，在计算机中可以用如图3．4所示的方块图表示迷宫。图中的每个方块或为通道(以空白方块表示)，或为墙(以带阴影线的方块表示)。所求路径必须入口图3．4迷宫出口是简单路径，即在求得的路径上不能重复出现同一通道块。
　　假设“当前位置”指的是“在搜索过程中某一时刻所在图中某个方块位置”，则求迷宫中一条路径的算法的基本思想是：若当前位置“可通”，则纳入“当前路径”，并继续朝“下位置”探索，即切换“下一位置”为“当前位置”，如此重复直至到达出口；若当前位置“不可通”，则应顺着“来向”退回到“前一通道块”，然后朝着除“来向”之外的其他方向继续探索；若该通道块的四周四个方块均“不可通”，则应从“当前路径”上删除该通道块。所谓“下一位置”指的是“当前位置”四周四个方向(东、南、西、北)上相邻的方块。假设以栈S记录“当前路径”，则栈顶中存放的是“当前路径上最后一个通道块”。由此，“纳入路径”的操作即为“当前位置入栈”；“从当前路径上删除前一通道块”的操作即为“出栈”。
　　求迷宫中一条从入口到出口的路径的算法可简单描述如下：
设定当前位置的初值为入口位置；
do I
若当前位置可通，
则{  将当前位置插入栈顶；    ∥纳入路径
    若该位置是出口位置，则结束；    ∥求得路径存放在栈中
    否则切换当前位置的东邻方块为新的当前位置；
    }
  否则，
    若栈不空且栈顶位置尚有其他方向未经探索，
    则设定新的当前位置为沿顺时针方向旋转找到的栈顶位置的下一相邻块；
    若栈不空但栈顶位置的四周均不可通，
    则{  删去栈顶位置；    ∥从路径中删去该通道块
    若栈不空，则重新测试新的栈顶位置，
    直至找到一个可通的相邻块或出栈至栈空；
    
}while(栈不空)；
　　在此，尚需说明一点的是，所谓当前位置可通，指的是未曾走到过的通道块，即要求该方块位置不仅是通道块，而且既不在当前路径上(否则所求路径就不是简单路径)，也不是曾经纳入过路径的通道块(否则只能在死胡同内转圈)。
　　typedef struct {
  int    ord；
  PosType    seat；
  int    di：
}  sElemType；
∥通道块在路径上的“序号”
∥通道块在迷宫中的“坐标位置”
∥从此通道块走向下一通道块的“方向”
∥栈的元素类型
Status MazePath(MazeType maze，PosType start，PosType end){
  ∥若迷宫e中存在从入口start到出口end的通道，则求得一条存放在栈中(从栈底到栈顶)，并返回TRUE；否则返回FALSE
In／‘tStack(s)；  curpos=start；
curstep。1：
do{
∥设定“当前位置”为“入口位置”
∥探索第一步
if(Pass(curpos)){  ∥当前位置可以通过，即是未曾走到过的通道块
  ．FootPrint(curpos)；    ∥留下足迹
  e=(curstep，curpos，1)；
  ．Push(s，e)；    ∥加入路径
  if(curpos==end)return(TRUE)；∥到达终点(出口)
  curpos。NextPos(curpos，1)；    ∥下一位置是当前位置的东邻
  curst．ep+’；    ∥探索下一步
   l∥if
    else{  ∥当前位置不能通过
    if(!stac~mpty(s))l
    Pop(s，e)；
    while(e．di==4&&!StackEmpty(s)){
    MarkPrint(e．seat)；Pop(s，e)；  ∥留下不能通过的标记，并退回一步
    }∥while
    if(e．di<4){
    e．di+’；Push(s，e)；    ∥换下一个方向探索
    curpos：NextPos(e．seat e．di)；    ∥设定当前位置是该新方向上的相邻块
    }∥if
    }∥if
    }∥else
  }while(!StackEmpt：y(s))；
return(LsE)；
∥MazePath
算法3．3
  3．2．5表达式求值
  表达式求值是程序设计语言编译中的一个最基本问题。它的实现是栈应用的又一个典型例子。这里介绍一种简单直观、广为使用的算法，通常称为“算符优先法”。
  要把一个表达式翻译成正确求值的一个机器指令序列，或者直接对表达式求值，首先要能够正确解释表达式。例如，要对下面的算术表达式求值    4+2×3―10／5
首先要了解算术四则运算的规则。即：
  1)先乘除，后加减；
  2)从左算到右；
  3)先括号内，后括号外。
由此，这个算术表达式的计算顺序应为
    4+2×3―10／5=4+6―10／5=10―10／5=10―2=8
算符优先法就是根据这个运算优先关系的规定来实现对表达式的编译或解释执行的。
　　任何一个表达式都是由操作数(operand)、运算符(operator)和界限符(delimiter)组成的，我们称它们为单词。一般地，操作数既可以是常数也可以是被说明为变量或常量的标识符；运算符可以分为算术运算符、关系运算符和逻辑运算符等三类；基本界限符有左右括号和表达式结束符等。为了叙述的简洁，我们仅讨论简单算术表达式的求值问题。这种表达式只含加、减、乘、除等四种运算符。读者不难将它推广到更一般的表达式上。
　　我们把运算符和界限符统称为算符，它们构成的集合命名为OP。根据上述三条运算规则，在运算的每一步中，任意两个相继出现的算符e。和e2之间的优先关系至多是下面三种关系之一；
　　    01<e2 e1的优先权低于02
        e。=e2 el的优先权等于02
        el>e2 el的优先权高于02
表3．1定义了算符之间的这种优先关系。
    表3．1算符间的优先关系
    由规则3)，+、-、*和／为q时的优先性均低于‘(’但高于“)”，由规则2)，当ql=q2时，令q1>q2，‘#’是表达式的结束符。为了算法简洁，在表达式的最左边也虚设一个‘#’构成整个表达式的一对括号。表中的‘(’=‘)’表示当左右括号相遇时，括号内的运算已经完成。同理，‘#’=‘#’表示整个表达式求值完毕。‘)’与‘(’、‘#’与‘)’以及‘(’与‘#’之间无优先关系，这是因为表达式中不允许它们相继出现，一旦遇到这种情况，则可以认为出现了语法错误。在下面的讨论中，我们暂假定所输入的表达式不会出现语法错误。
    为实现算符优先算法，可以使用两个工作栈。一个称做OPTR，用以寄存运算符；另一个称做()PND，用以寄存操作数或运算结果。算法的基本思想是：
    1)首先置操作数栈为空栈，表达式起始符“#”为运算符栈的栈底元素；
    2)依次读入表达式中每个字符，若是操作数则进()PND栈，若是运算符，则和OF，TR栈的栈顶运算符比较优先权后作相应操作，直至整个表达式求值完毕(即OPTR栈的栈顶元素和当前读入的字符均为“#”)。
    算法3．4描述了这个求值过程。
    0perandType Eva]uateExpression(){
    ∥算术表达式求值的算符优先算法。设0PTR和0PND分别为运算符栈和运算数栈，
    ∥OP为运算符集合。
    InitStac~c(OPTR)；Push(0PTR，’#，)；
    initStac~[(opt)；  c=getchar’()；
    while(c!=’#。Il GetTop(OPTR) =’#。){
    if(!In(c，oP)){Push((OPND，c)；c=getchar()；}  ∥不是运算符则进栈
    else
    switdl(Precede(GetTop(OPTR)，c){
    case’<’：  ∥栈顶元素优先权低
    Push(0PTR，c)；c=getchar()；
    break；
    case’=’：  ∥脱括号并接收下一字符
    Pop(OPTR，x)；  c=getchar()；
    break；
    casQ。>’：  ∥退栈并将运算结果入栈
    Pop(OPTR，’theta)；
    Pop(OPND，b)；Pop(OPND，a)；
    Push(OPND，Operate(a，theta，b))；
    break；
    {{SWIj tch
  l∥while
  ret=rn GetTop(OPND)：
}∥Evall／ateExpression
算法3．4
算法中还调用了两个函数。其中Precede是判定运算符栈的栈顶运算符01与读入的运算符e7之间优先关系的函数；()perate为进行二元运算a e 6的函数，如果是编译表达式，则产生这个运算的一组相应指令并返回存放结果的中间变量名；如果是解释执行表达式，则直接进行该运算，并返回运算的结果。
　　例3―1  利用算法EvaluateExpression―reduced对算术表达式3*(7―2)求值，操作过程如下所示。
　　3．3栈与递归的实现
    栈还有一个重要应用是在程序设计语言中实现递归。一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称做递归函数。
    递归是程序设计中一个强有力的工具。其一，有很多数学函数是递归定义的，如大家熟悉的阶乘函数    Factc n2 阶Fibonacci数列 
    Fib(n)=_{1    若n=1    (3―2)
    lFib(n一1)+Fib(”一2)其它情形
和Ackerman函数
     Ack(，，l，n)=．{．Ack(m一1，1)    若，z=0    (3―3)
    其二，有的数据结构，如二叉树、广义表等，由于结构本身固有的递归特性，则它们的操作可递归地描述；其三，还有一类问题，虽则问题本身没有明显的递归结构，但用递归求解比迭代求解更简单，如八皇后问题，Hanoi塔问题等。
    例3．2  (，z阶14anoi塔问题)假设有三个分别命名为x、Y和z的塔座，在塔座x上图3．5 3阶Hanoi塔问题的初始状态
插有n个直径大小各不相同、依小到大编号为1，2，…，n的圆盘(如图3．5所示)。现要求将x轴上的n个圆盘移至塔座z上并仍按同样顺序叠排，圆盘移动时必须遵循下列规则：
    1)每次只能移动一个圆盘；
    2)圆盘可以插在x、Y和z中的任一塔座上；
    3)任何时刻都不能将一个较大的圆盘压在较小的圆盘之上。
　　如何实现移动圆盘的操作呢?当，z=1时，问题比较简单，只要将编号为1的圆盘从塔座x直接移至塔座z上即可；当，z>1时，需利用塔座Y作辅助塔座，若能设法将压在编号为，z的圆盘之上的，z一1个圆盘从塔座x(依照上述法则)移至塔座Y上，则可先将编号为”的圆盘从塔座x移至塔座Z上，然后再将塔座Y上的n-1个圆盘(依照上述法则)移至塔座Z上。而如何将n-1个圆盘从一个塔座移至另一个塔座的问题是一个和原问题具有相同特征属性的问题，只是问题的规模小l，因此可以用同样的方法求解。
　　由此可得如算法3．5所示的求解一阶Hanoi塔问题的c函数。
    void hanoi．(Jail：n，char x，char y。char z)
    ∥将塔座x上按直径由小到大且自上而下编号为1至n的n个圆盘按规则搬到
    ∥塔座z上，y可用作辅助塔座。
    ∥搬动操作move(x，n，z)可定义为(c是初值为0的全局变量，对搬动计数)：
    ∥printf(。％i．Move disk％i from  ％c  to  ％c＼n’，++c，n。x，z)；
if(n==1)
  move(x。1，z)；    ∥将编号为1的圆盘从x移到z
else{
  hano~(n一1，x，z，y)；  ∥将x上编号为1至n―l的圆盘移到y，z作辅助塔
  moVe(x，n，z)；    ∥将编号为n的圆盘从x移到z
  hanoi．(n一1，y，x，z)；∥将y上编号为1至n―l的圆irON z，】c作辅助塔
}
算法3．5
    显然，这是一个递归函数，在函数的执行函数中，需多次进行自我调用。那末，这个递归函数是如何执行的?先看任意两个函数之间进行调用的情形。
    和汇编程序设计中主程序和子程序之间的链接和信息交换相类似，在高级语言编制的程序中，调用函数和被调用函数①之间的链接和信息交换需通过栈来进行。
    通常，当在一个函数的运行期间调用另一个函数时，在运行被调用函数之前，系统需先完成三件事：(1)将所有的实在参数、返回地址等信息传递给被调用函数保存；(2)为被调用函数的局部变量分配存储区；(3)将控制转移到被调函数的入口。而从被调用函数返回调用函数之前，系统也应完成三件工作：(1)保存被调函数的计算结果；(2)释放被调函数的数据区；(3)依照被调函数保存的返回地址将控制转移到调用函数。当有多个函数构成嵌套调用时，按照“后调用先返回”的原则，上述函数之间的信息传递和控制转移必须通过“栈”来实现，即系统将整个程序运行时所需的数据空间安排在一个栈中，每当调用一个函数时，就为它在栈顶分配一个存储区，每当从一个函数退出时，就释放它的存储区，则当前正运行的函数的数据区必在栈顶。例如，在图3．6(c)所示主函数main中调用了函数first，而在函数first中又调用了函数second，则图3．6(a)展示了当前正在执行函数second中某个语句时栈的状态，而图3．6(b)展示从函数second退出之后正执行函数first：中某个语句时栈的状态(图中以语句标号表示返回地址)。
栈顶
栈顶
int  first(int s，int t)；
int  second(int d)；
int  main(){
    t  m．n；
    first(m，n)；
    1：．．．
}
int first(／at s，int t)f
    int i；
    sec。nd(i)；
    2 1．．．
}
int second(int d)l
  x，y；
}
    (c)
图3．6主函数main执行期间运行栈的状态
　　一个递归函数的运行过程类似于多个函数的嵌套调用，只是调用函数和被调用函数是同一个函数，因此，和每次调用相关的一个重要的概念是递归函数运行的“层次”。假设调用该递归函数的主函数为第0层，则从主函数调用递归函数为进入第1层；从第i层递归调用本函数为进入“下一层”，即第i+1层。反之，退出第i层递归应返回至“上一层”、
　　①若在函数A中调用了函数B，则称函数A为调用函数，称函数B为被调用函数。
即第j一1层。为了保证递归函数正确执行；系统需设立一个“递归工作栈”①作为整个递归函数运行期间使用的数据存储区。每一层递归所需信息构成一个“工作记录”，其中包括所有的实在参数、所有的局部变量以及上一层的返回地址。每进入一层递归，就产生一个新的工作记录压入栈顶。每退出一层递归，就从栈顶弹出一个工作记录，则当前执行层的工作记录必是递归工作栈栈顶的工作记录，称这个记录为“活动记录”，并称指示活动记录的栈顶指针为“当前环境指针”。
    例如，图3．7展示了语句
    】hanoi(3，a，b，c)    (3―4)
执行过程(从主函数进入递归函数到退出递归函数而返回至主函数)中递归工作栈状态的变化情况。由于算法3．5所示的递归函数中只含四个值参数，则每个工作记录包含五个数据项：返回地址和四个实在参数，并以递归函数中的语句行号表示返回地址，同时假设主函数的返回地址为0。图3．7中◆表示栈顶指针。
    实际上，在调用函数和被调用函数之间不一定传递参数的值，也可以传递参数的地址。通常，每个程序设计语言都有它自己约定的传递方法(包括被调用函数的执行结果如何返回调用函数等)，其细节读者将会在后续课程中学到。
    由于递归函数结构清晰，程序易读，而且它的正确性容易得到证明。因此，利用允许递归调用的语言(例如c语言)进行程序设计时，给用户编制程序和调试程序带来很大方便。因为对这样一类递归问题编程时，不需用户自己而由系统来管理递归工作栈。
递归运行  运行语句     递归工作栈状态    塔与圆盘的状态 说  明 
的层次    ┃  行号      ┃(返址，n值，x值，y值．z值)    ┃                                    ┃                            ┃
由主函数进入第一层递归后，运行至语句(行)5，因递归调用而进入下一层。
由第一层的语句(行)5进入第二层递归。执行至语句    
由第二层的语句(行)5进     ┃
  入第三层递归，执行语句    将1号圆盘由a移至c后从语句(行)9退出第
  三层递归。返回至第二层的， 将2号圆盘由a移至b后，       从语句(行)7进入下一层       递归。                      
图3．7 Hanoi塔的递归函数运行示意图
    ①  在实际的系统中。一般都综合考虑递归调用和非递归调用统一处理，在此，我们只讨论直接递归调用的处理机制。
   递归运行  运行语句    递归工作栈状态    塔与圆盘的状态  说明 
的层次    ┃  行号      ┃(返址n值，x值，y值，z值)    ┃                                      将l号圆盘由c移至b后，   
从语句(行)9退出第三层，返回至第二层的语句(行)  从语句(行)9退出第二层。返回至第一层的语句(行)  将3号圆盘由a移至c后，   从语句(行)7进入下一层   递归。
从第二层的语句(行)5进   入第三层递归。  将1号圆盘由b移至a后，   从语句(行)9退出第三层   递归，返回至第二层语句  
递归。                  将1号圆盘由a移至c后，   从语句(行)9退出第三层， 
返回至第二层语句(行)。  从语句(行)9退出第二层， 
返回至第一层语句(行)8。从语句(行)9退出递归函数，返回至主函数。栈空。同上 继续运行主函数 图3．7(续)
    3．4  队
3．4．1抽象数据类型队列的定义
和栈相反，队列(Queue)是一种先进先出(FirSt In First Out，缩写为FIFo)的线性表。
它只允许在表的一端进行插入，而在另一端删除元素。这和我们日常生活中的排队是一致的，最早进入队列的元素最早离开。在队列中，允许插入的一端叫做队尾(rear。)，允许删除的一端则称为队头(front)。假设队列为q=(al，a2，…，an)，那么，a1就是队头元素，an则是队尾元素。队列中的元素是按照a1，a2，…，an的顺序进入的，退出队列也只能按照这个次序依次退出，也就是说，只有在头尾al，a2，…，an-1都离开队列之后，an才能退出队列。图3．8是队列的示意图。
　　队列在程序设计中也经常出现。一个最典型的例子就是操作系统中的作业排队。在允许多道程序运行的计算机系统中，同时有几个作业运行。如果运行的结果都需要通过通道输出i那就要按请求输出的先后次序排队。每当通道传输完毕可以接受新的输出任务时，队头的作业先从队列中退出作输出操作。凡是申请输出的作业都从队尾进入队列。
　　队列的操作与栈的操作类似，也有八个。不同的是删除是在表的头部(即队头)进行。
    下面给出队列的抽象数据类型定义：
    ADT Queue{
    数据对象：D=faif ai∈ElemSet，i=1，2．…，n，n≥0 l
    数据关系：R1=l<ai―l，ai>{ai―l。ai∈D，i=2，…，n I
    约定其中a1端为队列头，an端为队列尾。
    基本操作：
    InitQueue(＆Q)
    操作结果：构造一个空队列Q。
    Destro!~)ueue(＆Q)
    初始条件：队列Q已存在。
    操作结果：队列Q被销毁，不再存在。
    clearOueue(&Q)
    初始条件：队列Q已存在。
    操作结果：将Q清为空队列。
    QueueEmpty(Q)
    初始条件：队列Q已存在。
    操作结果：若Q为空队列，则返回TRUE，否则FALSE。
    QueueSength(Q)
    初始条件：队列Q已存在。
    操作结果：返回Q的元素个数，即队列的长度。
    GetHead(Q，&e)    ’
    初始条件：Q为非空队列。
    操作结果：用e返回Q的队头元素。
    EnQueue(＆Q，e)
    初始条件：队列Q已存在。
    操作结果：插入元素e为Q的新的队尾元素。
    DeQueue(&Q，＆e)
    初始条件：Q为非空队列。
    操作结果：删除Q的队头元素，并用e返回其值。
    


  图3．10链队列示意图    图3．11  队列运算指针变化状况
    (a)空队列；    (b)元素x入队列；
    (c)元素Y入队列；  (d)元素x出队列。
    
／／…==ADT Queue的表示与实现…==
∥…--单链队列――队列的链式存储结构…--
t~def struct QNode{
  QEldata；
  struct QNode  *next；
}QNode，*QueuePtr；
tyIstruct{
  QueuePtr front；  ∥队头指针
  QueuePtr rear；  ∥队尾指针
}LinkQueue；
  ∥…--基本操作的函数原型说明…--
  Status InitQueue(LinkQueue＆Q)
    ∥构造一个空队列Q
  Status DestroyQueue(LinkQueue＆Q)
    ∥销毁队列Q，Q不再存在
  Status ClearQueue(LinkQueue&Q)
    ∥将Q清为空队列
  Status QueueEmpty(LinkQueue Q)
    ∥若队列Q为空队列，则返回TRUE，否则返回FALSE
  int QueueLength(LinkQueue O)
    ∥返回Q的元素个数，即为队列的长度
Status GetHead(LinkQueue O。QElemType＆e)
    ∥若队列不空，则用e返回Q的队头元素，并返回OK；否则返回ERROR
  Status EnQueue(LinkQueue&e，QElemType e)
    ∥插入元素e为Q的新的队尾元素
  Status DeQueue(LinkQueue＆Q，QElemType＆e)
    ∥若队列不空，则删除Q的队头元素，用e返回其值，并返回OK；
    ∥否则返回ERROR
Status QueueTraverse(LinkQueue Q，visit())
    ∥从队头到队尾依次对队列O中每个元素调用函数visit(o一旦visit失败，则操作失败。
∥…基本操作的算法描述(部分)…
Status InitQueue(LinkQueue＆Q){
    ∥构造一个空队列Q
    Q．front=Q．rear=(QueuePtr)malloc(slzeof(QNode))；
    if(!Q．front)exit(DW)；    ∥存储分配失败
    Q．front一>next=IULL；
    return OK；
}
Status DestroyQueue(Link-Queue＆Q){
    ∥销毁队列Q
    while(Q．front){
    Q．rear。Q．front一>next；
    free(Q．front)；
    Q．front=e．rear；
    }
    raturn OK；    

Status EnQueue(LinkQueue&Q，QElemType e){
    ∥插入元素e为Q的新的队尾元素
    p=(0ueuePtr)malloc(sizoof(ONode))；
    if(!P)it(OVZ~FLOW)；    ／／存储分配失败
    p一>data=e；P一>next=N【儿正．；
    Q．rear一>next=p；
    Q．resI。p；
    return OK；
}
Status DeQueue(LinkQueue＆Q，QElesType＆e){
    ∥若队列不空，则删除Q的队头元素，用e返回其值，并返回0K；
    ∥否则返回ERROR
    if(Q．front lIQ．rear)return ERROR；
    P=Q．front一>next；
    e=P一>data；
    Q．front一>next=P一>next：
    if(Q．rear-。p)Q．rear=Q．front；
    free(p)；
    return OK；
}
    在上述模块的算法描述中，请读者注意删除队列头元素算法中的特殊情况。一般情况下，删除队列头元素时仅需修改头结点中的指针，但当队列中最后一个元素被删后，队列尾指针也丢失了，因此需对队尾指针重新赋值(指向头结点)。
  3．4．3循环队列――队列的顺序表示和实现
  和顺序栈相类似，在队列的顺序存储结构中，除了用一组地址连续的存储单元依次存放从队列头到队列尾的元素之外，尚需附设两个指针front和rear分别指示队列头元素和队列尾元素的位置。为了在C语言中描述方便起见，在此我们约定：初始化建空队列时，令front=rear・=0，每当插入新的队列尾元素时，“尾指针增1”；每当删除队列头元素时，“头指针增1”。因此，在非空队列中，头指针始终指向队列头元素，而尾指针始终指向队列尾元素的下一个位置。如图3．12所示。
    4
    3
    9
    l
Q．rear
i―fro’nt 0
    图3．12头、尾指针和队列中元素之间的关系
    (a)空队列；(b)Jl、J2和J3相继队列。；
    (b)Jl和Jj相继被删除；(d)04、J5和j6相继插入队列之后’4被删除。
    假设当前为队列分配的最大空间为6，则当队列处于图3．12(d)的状态时不可再继续插入新的队尾元素，否则会因数组越界而遭致程序代码被破坏。然而此时又不宜如顺序栈那样，进行存储再分配扩大数组空间，因为队列的实际可用空间并未占满。一个较巧妙的办法是将顺序队列臆造为一个环状的空间，如图3．13所示，称之为循环队列。指针和队列元素之间关系不变，如图3．14(a)所示循环队列中，队列头元素是J3，队列尾元素是J5，之后J6、J7和J。
相继插入，则队列空间均被占满，如图3．14(b)所示，此时Q．front=Q．rear；反之‘，若J3、J4和J5相继从图3．14(a)的队列中删除，使队列呈“空”的状态，如图3．14(c)所示。此时亦存在关系式Q．
图3．13循环队列示意图
front=Q．rear，由此可见，只凭等式Q．front=Q．rear无法判别队列空间是“空”还是“满”。可有两种处理方法：其一是另设一个标志位以区别队列是“空”还是“满”；其二是少用一个元素空间，约定以“队列头指针在队列尾指针的下一位置(指环状的下一位置)上”作为队列呈“满”状态的标志。
    从上述分析可见，在C语言中不能用动态分配的～维数组来实现循环队列。如果用户的应用程序中设有循环队列，则必须为它设定一个最大队列长度；若用户无法予估所用队列的最大长度，则宜采用链队列。
    
    3 14循环队列的头尾指针
    (a)一般情况；(b)队列满时，(c)i队列
循环队列类型的模块说明如下：
∥…一  循环队列――队列的顺序存储结构…
#di~QSZZE i00  ∥最大队列长度
tⅢ《stractl
    l’y  *base；    ∥初始化的动态分配存储空间
    in七front；    ∥头指针。若队列不空，指向队列头元素
    int…；    ∥尾指针，若队列不空，指向队列尾元素的下一个位置
}SqQueue；
∥    --循环队列的基本操作的算法描述    一
Status Inlt蛐eue(SqQueue＆Q)l
    ∥构造一个空队列0
    0 base=(QElem~e。)mnl∞(MAXQSIZ~*siz~f(QEI~Type
    if(!Q base)口it(∞ERFLDw)；∥存储分配失败
    Ofront；0一=0；
    ㈣OK：
int~eueLength(SqQueue 0){
    ∥返回Q的元索个数，即队列的长度
    (…0 front十MAx∞IzE)％HAxsI；
Status EnQueue(SqQueue＆Q，QElemType e)
    ∥插入元素e为Q的新的队尾元素
    if((Q．rear・+1)％MAXOSZ~==Q．front)return ERROR；∥队列满
    Q．base【Q．rear。]=e；
    Q．rear=(Q．rear’+1)％MAXOSZZE；
    return OK；
}    ．
Status DeQueue(SqQueue＆Q，QElemType＆e)
    ∥若队列不空，则删除Q的队头元素，用e返回其值，并返回OK；
    ∥否则返回ERROR
    if(Q．front==Q．rear)return ERROR；
    e=Q．base{．Q．frontJ；
    Q．front=(Q．front+1)％MAXQSIZE；
    return OK；
}
3．5离散事件模拟
    在日常生活中，我们经常会遇到许多为了维护社会正常秩序而需要排队的情境。这样一类活动的模拟程序通常需要用到队列和线性表之类的数据结构，因此是队列的典型应用例子之一。这里将向读者介绍一个银行业务的模拟程序。
    假设某银行有四个窗口对外接待客户，从早晨银行开门起不断有客户进入银行。由于每个窗口在某个时刻只能接待一个客户，因此在客户人数众多时需在每个窗口前顺次排队，对于刚进入银行的客户，如果某个窗口的业务员正空闲，则可上前办理业务，反之，若四个窗口均有客户所占，他便会排在人数最少的队伍后面。现在需要编制一个程序以模拟银行的这种业务活动并计算一天中客户在银行逗留的平均时间。
    为了计算这个平均时间，我们自然需要掌握每个客户到达银行和离开银行这两个时刻，后者减去前者即为每个客户在银行的逗留时间。所有客户逗留时间的总和被一天内进入银行的客户数除便是所求的平均时间。称客户到达银行和离开银行这两个时刻发生的事情为“事件”，则整个模拟程序将按事件发生的先后顺序进行处理，这样一种模拟程序称做事件驱动模拟。算法3．6描述的正是上述银行客户的离散事件驱动模拟程序。
void Bank―Simulation(int CloseTime){
    ∥银行业务模拟，统计一天内客户在银行逗留的平均时间。
OpenForDay；    ∥初始化
．hile(MoreEvent)do l
 EventDrired(0ccurTime，EventType)；    ∥事件驱动
switch(EventType){
    case’A’：CustomerArrired；    Break；    ∥处理客户到达事件
    case’D’：CustomerDeparture；  Break；    ∥处理客户离开事件
    8~Eault：Ind；
  }∥switch
}∥while
 CloseForDay：
∥B【一simufatl。on
算法3．6
∥计算平均逗留时间
    下面讨论模拟程序的实现，首先要讨论模拟程序中需要的数据结构及其操作。
    算法3．6处理的主要对象是“事件”，事件的主要信息是事件类型和事件发生的时刻。算法中处理的事件有两类：一类是客户到达事件；另一类是客户离开事件。前一类事件发生的时刻随客户到来自然形成；后一类事件发生时刻则由客户事务所需时间和等待所耗时间而定。由于程序驱动是按事件发生时刻的先后顺序进行，则事件表应是有序表，其主要操作是插入和删除事件。
    模拟程序中需要的另一种数据结构是表示客户排队的队列，由于前面假设银行有四个窗口，因此程序中需要四个队列，队列中有关客户的主要信息是客户到达的时刻和客户办理事务所需时间。每个队列中的队头客户即为正在窗口办理事务的客户，他办完事务离开队列的时刻就是即将发生的客户离开事件的时刻，这就是说，对每个队头客户都存在一个将要驱动的客户离开事件。因此，在任何时刻即将发生的事件只有下列五种可能：
(1)新的客户到达；(2)1号窗口客户离开；(3)2号窗口客户离开；(4)3号窗口客户离开；
(5)4号窗口客户离开。
    从以上分析可见，在这个模拟程序中只需要两种数据类型：有序链表和队列。它们的数据元素类型分别定义如下：
tn~d-f struct{
  int 0ccurTime；    ∥事件发生时刻
  int NType；    ∥事件类型，0表示到达事件，1至4表示四个窗口的离开事件
}Event，ElemType；    ∥事件类型，有序链表LinkList的数据元素类型
typedef LinkList EventLJ．st    ∥事件链表类型，定义为有序链表
typedef struct{
    int  ArrivalTime
    int Durat：ion：
}QElemType；
∥到达时刻
∥办理事务所需时间
∥队列的数据元素类型
    现在我们详细分析算法3．6中的两个主要操作步骤是如何实现的。
    先看对新客户到达事件的处理。
    由于在实际的银行中，客户到达的时刻及其办理事务所需时间都是随机的，在模拟程序中可用随机数来代替。不失一般性，假设第二个顾客进门的时刻为0，即是模拟程序处理的第一个事件，之后每个客户到达的时刻在前一个客户到达时设定。因此在客户到达事件发生时需先产生两个随机数：其一为此时刻到达的客户办理事务所需时间durtime；
其二为下一客户将到达的时间间隔intertime，假设当前事件发生的时刻为occurtime，则下一个客户到达事件发生的时刻为OCC[・rtime+intertime,，由此应产生一个新的客户到达事件插入事件表；刚到达的客户则应插入到当前所含元素最少的队列中；若该队列在插入
前为空，则还应产生一个客户离开事件插入事件表。    
　　客户离开事件的处理比较简单。首先计算该客户在银行逗留的时间，然后从队列中删除该客户后查看队列是否空，若不空则设定一个新的队头客户离开事件。
　　最后我们给出在上述数据结构下实现的银行事件驱动模拟程序如算法3．7所示。
    ∥程序中用到的主要变量
    EventList  ev：    ∥事件表
    Event    eni    ff
    LinkQueue  q[4]；    ／／4个客户队列
    QElemType  customer；    ∥客户记录
    int TotaiTime．OustomerNum；  ∥累计客户逗留时间，客户数
int cmp(Event a，  Event b)；
  ∥依事件a的发生时刻<或=或>事件b的发生时刻分别返回一1或0或1
voidOpenForDay(){
  ∥初始化操作
  TotaiTime=0；CustomerNum=0；    ∥初始化累计时间和客户数为0
  InitList(ev)；    ∥初始化事件链表为空表
  en．OccurTime=0；  en．NType=0；    ∥设定第一个客户到达事件
  Orderlnsert(ev，en，(*cmp)())；    ∥插入事件表
  for(i=0；i<4；++i)InitQueue(q[i])；  ∥置空队列
＼}{OpenForDay
void CustomerArrived(){
    ∥处理客户到达事件，en．NType=0。
    ++CustomerNum 0
    Random(durtime，intertime)；    ∥生成随机数
    t=en．OccurTime+intertime；    ／／下一客户到达时刻
    if(t<CloseTime)    ∥银行尚未关门，插入事件表
    Orderlnsert(eV，(t，0)，(*cmp)())；
    i=Minimum(q)；    ∥求长度最短队列
    EnQueue(q[i]，(en．OccurTime，durtime))；
    if(QueueLength(q【i])==1)
    OrderInsert(ev，(en．OccurTime+durtime，i)，(*cmp)())；
    ∥设定第i队列的一个离开事件并插入事件表
}／／CustomerArrived
void CustomerDeparture(){
    ∥处理客户离开事件，en．NType>0。
    i：en．NType；DelQueue(q[i]，customer)；∥删除第i队列的排头客户
    TotalTime+。en．OccurTime―customer．ArrivalTime：
    ∥累计客户逗留时间
    if(!QueueEmpty(q【i])){    ∥设定第i队列的一个离开事件并插入事件表
    GetHead(q[i]，customer)；
    OrderInsert(ev，(e_n．OccurTime+curtomer．Duration，i)，(*cmp)())；
    }
    
}／／CustomerDeparture
void Bank―Simulation(int CloseTime){
  OpenForDay：    ∥初始化
  ．bile(!EmptyEventList(ev)){
    DelFirst(GetHead(eV)，p)；  en=GetCurElem(p)；
    if(en．Ⅶe==0)
    CustomerArrived；    ∥处理客户到达事件
    e1。e CustomerDeparture；    ∥处理客户离开事件
    }
    ∥计算并输出平均逗留时间
    pri．t~(。The Average Time is％f＼F，TotalTime／CustomerNum)；
＼}}Bank．Simulation
算法3．7
　　例3，3假设每个客户办理业务的时间不超过30分钟；两个相邻到达银行的客户的时间间隔不超过5分钟，模拟程序从第一个客户到达时间为“0”开始起运行。
　　删除事件表上第一个结点，得到en．OccurTime=0，因为an．NType=0，则随即得到两个随机数(23，4)，生成一个下一客户到达银行的事件(OccurTime=4，NType=0)插入事件表；刚到的第一位客户排在第一个窗口的队列中(ArrivalTime=0，Duration=23)，由于他是排头，故生成一个客户将离开的事件(OccurTime=23，NType：1)插入事件表。
    删除事件表上第一个结点，仍是新客户到达事件(因为en．NType=0)，an．OccurTime
=4，得到随机数为(3，1)，则下一客户到达银行的时间为OccurTime=4+1=5，由于此时第二个窗口是空的，则刚到的第二位客户为第二个队列的队头(ArrivalTime=4，Duration=3)，因而生成一个客户将离开的事件(OccurTime=7，NType：2)插入事件表。
    删除事件表上第一个结点，仍是新客户到达事件，en．OccurTime=5，得到随机数(11，3)，则插入事件表的新事件为(OccurTime：8，NType=0)，同时，刚到的第三位客户成为第三个队列的队头(ArrivalTime=5，Duration：11)，因而插入事件表的新事件为(Occur．Time=16，NType=3)。
    删除事件表的第一个结点，因为NType=2，说明是第二个窗口的客户离开银行en．OccurTime=7，删去第二个队列的队头，curstomer．ArrivalTime：4，则他在银行的逗留时间为3分钟。
    依次类推，在模拟开始后的一段时间内，事件表和队列的状态如图3．15所示，ev．first为链表头指针。

随机数    事件表
(23，4)
(3，1)
(11。3)
队列状态
Q
随机数    事件表    队列状态
    ev．st J
(29，2)
(18，4)
(13，5)
eV．
eV．
图3．15  事件驱动模拟(算法3．7)过程中事件表和队列状态变化状况
