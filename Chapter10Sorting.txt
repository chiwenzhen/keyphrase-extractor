
第10章内部排序
  10．1概  述
    排序(Sorting)是计算机程序设计中的一种重要操作，它的功能是将一个数据元素(或记录)的任意序列，重新排列成一个按关键字有序的序列。
    从第9章的讨论中容易看出，为了查找方便，通常希望计算机中的表是按关键字有序的。因为有序的顺序表可以采用查找效率较高的折半查找法，其平均查找长度为log2(，z+1)-1，而无序的顺序表只能进行顺序查找，其平均查找长度为(n+1)／2。又如建造树
表(无论是二叉排序树或B．树)的过程本身就是一个排序的过程。因此，学习和研究各种排序方法是计算机工作者的重要课题之一。
    为了便于讨论，在此首先要对排序下一个确切的定义：
    假设含n个记录的序列为
    {R1，R2，…，R。}    (101)
其相应的关键字序列为
    {K1，K2，…，K。}
需确定1，2，…，n的一种排列p1，p2，…，户。，使其相应的关键字满足如下的非递减(或非递增①)关系
    Kp，≤Kp，≤…≤Kp    (102)
即使式(10．1)的序列成为一个按关键字有序的序列
    {Rp．，Rp，，…，Rp}    (10-3)
这样一种操作称为排序。
　　上述排序定义中的关键字Ki可以是记录Ri(净1，2，…，n)的主关键字，也可以是记录R；的次关键字，甚至是若干数据项的组合。若Ki是主关键字，则任何一个记录的无序序列经排序后得到的结果是唯一的；若Ki是次关键字，则排序的结果不唯一，因为待排序的记录序列中可能存在两个或两个以上关键字相等的记录。假设Ki=Ki(1≤i≤”，1≤n≤n，i≠j)，且在排序前的序列中Ri领先于Ri(即i<n)。若在排序后的序列中Ri仍领先于R，，则称所用的排序方法是稳定的；反之，若可能使排序后的序列中尺i领先于Ri，则称所用的排序方法是不稳定的。②
　　由于待排序的记录数量不同，使得排序过程中涉及的存储器不同，可将排序方法分为两大类：一类是内部排序，指的是待排序记录存放在计算机随机存储器中进行的排序过程①  若将式(10-2)中的“≤”号改为“≥”号。则满足非递增关系。
②  对不稳定的排序方法，只要举出一组关键字的实例说明它的不稳定性即可。
；另一类是外部排序。指的是待排序记录的数量很大，以致内存一次不能容纳全部记录，在排序过程中尚需对外存进行访问的排序过程。本章先集中讨论内部排序，将在下一章中讨论外部排序。
    内部排序的方法很多，但就其全面性能而言，很难提出一种被认为是最好的方法，每一种方法都有各自的优缺点，适合在不同的环境(如记录的初始排列状态等)下使用。如果按排序过程中依据的不同原则对内部排序方法进行分类，则大致可分为插入排序、交换排序、选择排序、归并排序和计数排序等五类；如果按内部排序过程中所需的工作量来区分，则可分为三类：(1)简单的排序方法，其时间复杂度为O(恕0)；(2)先进的排序方法，其时间复杂度为0(nlogn)；(3)基数排序，其时间复杂度为0(矗・n)。本章仅就每一类介绍一两个典型算法，有兴趣了解更多算法的读者可阅读D．E．克努特著(计算机程序设计技巧>L2](第三卷，排序和查找)。读者在学习本章内容时应注意，除了掌握算法本身以外，更重要的是了解该算法在进行排序时所依据的原则，以利于学习和创造更加新的算法。
    通常，在排序的过程中需进行下列两种基本操作：(1)比较两个关键字的大小；(2)将记录从一个位置移动至另一个位置。前一个操作对大多数排序方法来说都是必要的，而后一个操作可以通过改变记录的存储方式来予以避免。待排序的记录序列可有下列三种存储方式：(1)待排序的一组记录存放在地址连续的一组存储单元上。它类似于线性表的顺序存储结构，在序列中相邻的两个记录Ri和R；+，(j=1，2，…，n-1)，它们的存储位置也相邻。在这种存储方式中，记录之间的次序关系由其存储位置决定，则实现排序必须借助移动记录；(2)一组待排序记录存放在静态链表①中，记录之间的次序关系由指针指示，则实现排序不需要移动记录，仅需修改指针即可；(3)待排序记录本身存储在一组地址连续的存储单元内，同时另设一个指示各个记录存储位置的地址向量，在排序过程中不移动记录本身，而移动地址向量中这些记录的“地址”，在排序结束之后再按照地址向量中的值调整记录的存储位置。在第二种存储方式下实现的排序又称(链)表排序，在第三种存储方式下实现的排序又称地址排序。在本章的讨论中，设待排序的一组记录以上述第一种方式存储，且为了讨论方便起见，设记录的关键字均为整数。即在以后讨论的大部分算法中，待排记录的数据类型设为：
#defin・  MAXSIZE  20
type4ef int KeyType；
t~mN／ef struct{
  KefOype key；
  InfoType otherinfo；
}R~mme；
∥一个用作示例的小顺序表的最大长度
∥定义关键字类型为整数类型
∥关键字项
∥其它数据项
∥记录类型
typedef struc％{
  RedType r[MAXsIZE+1]；  ∥r[0]闲置或用作哨兵单元
  int length；    ∥顺序表长度
}SqList；    ∥顺序表类型
    ①  因为在排序过程中，只是改变记录之间的次序关系。而不进行插入、删除操作，且在排序结束时尚需调整记录，故采用静态链表。
10．2插入排序
  lO．2．1直接插人排序
  直接插人排序(Straight Insertion Sort)是一种最简单的排序方法，它的基本操作是将一个记录插入到已排好序的有序表中，从而得到一个新的、记录数增1的有序表。
    例如，已知待排序的一组记录的初始排列如下所示：①
    R(49)，R(38)，R(65)，R(97)，R(76)，R(13)，R(27)，R(49)，…    (10―4)
假设在排序过程中，前4个记录已按关键字递增的次序重新排列，构成一个含4个记录的有序序列
    {R(38)，R(49)，R(65)，R(97)I    (10-5)
现要将式(10．4)中第5个(即关键字为76的)记录插入上述序列，以得到一个新的含5个记录的有序序列，则首先要在式(10．5)的序列中进行查找以确定R(76)所应插入的位置，然后进行插入。假设从R(97)起向左进行顺序查找，由于65<76<97，则R(76)应插入在R(65)和R(97)之间，从而得到下列新的有序序列
    {R(38)，R(49)，R(65)，R(76)，R(97)}    (106)
称从式(10．5)到式(10，6)的过程为一趟直接插入排序。一般情况下，第i趟直接插入排序的操作为：在含有i-1个记录的有序子序列r[1．．卜1]⑦中插入一个记录r[i]后，变成含有i个记录的有序子序列r[1．．i]；并且，和顺序查找类似，为了在查找插入位置的过程中避免数组下标出界，在r[O]处设置监视哨。在自i-1起往前搜索的过程中，可以同时后移记录。整个排序过程为进行孢-1趟插入，即：先将序列中的第1个记录看成是一个有序的子序列，然后从第2个记录起逐个进行插入，直至整个序列变成按关键字非递减有序序列为止。其算法如算法10．1所示：
    void InsertSort(&扣ist＆L){
    ∥对顺序表L作直接插入排序。
    for(i=2；i<=L．1engeh；++i)
    if LT(L．r[i]．key。L．r[i-1]．key)i    ∥“<”，需将L．r【i]插入有序子表
    L．r[0]=L．r[i]；    ∥复制为哨兵
    for(j=il；LT(r．．r[0]．key，L．r[j]．key)；  j)
    L．rfj+1]=L．r[j]；    ∥记录后移
    L．r[j+1]=L．r[0]；    ∥插入到正确位置
    I
    }∥InsettSort
    算法10．1
    以式(10―4)中关键字为例，按照算法10．1进行直接插入排序的过程如图10．1
所示。④
①  R(x)表示关键字为x的记录，以下同。
⑦r[1．．I_1]表示参与排序的顺序表中下标从l到i―l的记录序列，以后同。
③  为简便起见，图中省略记录R的符号，而只列其关键宇。
・265・
[初始关键字]：(49)38  65  97  76  13  27  49
    t监视哨L．r[O]
    图10．1直接插入排序示例
　　从上面的叙述可见，直接插入排序的算法简洁，容易实现，那么它的效率如何呢?
　　从空间来看，它只需要一个记录的辅助空间，从时间来看，排序的基本操作为：比较两个关键字的大小和移动记录。先分析一趟插入排序的情况。算法10．1中里层的for循环的次数取决于待插记录的关键字与前i-1个记录的关键字之间的关系。若L．r[i]．key>L．r[i-1]．key，则内循环只进行一次关键字间的比较，而不移动记录；若L．r[ikey<L．r[1]．key，则内循环中，待插记录的关键字需与有序子序列L．r[1．．i-1]中i-1个记录的关键字和监视哨中的关键字进行比较，并将L．r[1．．i-1]中i-1个记录后移。则在整个排序过程(进行，z―l趟插入排序)中，当待排序列中记录按关键字非递减有序排列(以下称之为“正序”)时，所需进行关键字间比较的次数达最小值竹-1(即∑1)，记录不需移动；反之，当待排序列中记录按关键字非递增有序排列(以下称之为“逆序”)时，总的比较次数达最大值(扎+2)(n-1)／2(即∑i)，记录移动的次数也达最大值(n+4)-1)／2(即∑(f+1))。若待排序记录是随机的，即待排序列中的记录可能出现的各种排列的概率相同，则我们可取上述最小值和最大值的平均值，作为直接插入排序时所需进行关键字间的比较次数和移动记录的次数，约为扎。／4。由此，直接插入排序的时间复杂度为O(凡0)。
10．2．2其它插人排序
    从上一节的讨论中可见，直接插入排序算法简便，且容易实现。当待排序记录的数量n很小时，这是一种很好的排序方法。但是，通常待排序序列中的记录数量n很大，则不宜采用直接插入排序。由此需要讨论改进的办法。在直接插入排序的基础上，从减少“比较”和“移动”这两种操作的次数着眼，可得下列各种插入排序的方法。
  一、折半插入排序
  由于插入排序的基本操作是在一个有序表中进行查找和插入，则从9．1节的讨论中可知，这个“查找”操作可利用“折半查找”来实现，由此进行的插入排序称之为折半插入排序(Binary Insertion Sort)，其算法如算法10．2所示。
void BInsertSort(SqList&L){
  ∥对顺序表L作折半插入排序。
  for(i=2；i<=L．1ength；++i){    ‘
    L．r[0]=L．r[i]；    ∥将L．r[i]暂存到L．r[0]
    low=1：high=i-1；
    ．h1．1・(10w<=high){    ∥在r[10w．．high]中折半查找有序插入的位置
    m=(10w+high)／2；    ∥折半
    if Lr(L．r[0]．key，L．r[m]．key)high=m-1；    ∥插入点在低半区
    else low=m+1：    ∥插入点在高半区
    }∥while
    ~or(j=i-1；j>=high+1； j)L．dj+1]=L．r[j]；    ∥记录后移
    L．r[high+1]=L．r[0]；    ∥插入
  I∥for・
}∥BIrmertSozlt
    算法lO．2
    从算法10．2容易看出，折半插入排序所需附加存储空间和直接插入排序相同，从时间上比较，折半插入排序仅减少了关键字间的比较次数，而记录的移动次数不变。因此，折半插入排序的时间复杂度仍为O(，z。)。
  二、2．路插入排序
  2．路插人排序是在折半插入排序的基础上再改进之，其目的是减少排序过程中移动记录的次数，但为此需要”个记录的辅助空间。具体做法是：另设一个和L．r同类型的数组d，首先将L．r[1]赋值给d[1]，并将d[1]看成是在排好序的序列中处于中间位置的记录，然后从L．r中第2个记录起依次插入到d[1]之前或之后的有序序列中。先将待插记录的关键字和d[1]的关键字进行比较，若L．r[i]．key<d[1]．key，则将L．r[i]插入到d【1]之前的有序表中。反之，则将L_r[i]插入到d[1]之后的有序表中。在实现算法时，可将d看成是一个循环向量，并设两个指针first和final分别指示排序过程中得到的有序序列中的第一个记录和最后一个记录在d中的位置。具体算法留作习题由读者自己写出。
   仍以式(10．4)中的关键字为例，进行2．路插入排序的过程如图10．2所示。
    [初始关键字]：  49  38  65  97  76  13  27药
    排序过程中d的状态如下：
i=1：    (49)
    first十十final
i=2：
i：3：
i：4：
(49)
+final
(49 65)
    +final
(49 65 97)
    ^final
(38)
▲first
(38)
十first
(38)
+first
    ・267・
i=5
i=6
i=7
(49 65 76 97)
    ^final
(49 65 76 97)
    +final
(49 65 76 97)
    ▲final
    (38)
    ▲first
(13 38)
+first
(13 27 38)
+first
    i=8：(49 49 65 76 97  13  27  38)
    +final+first
    图10．2 2一路插入排序示例
    在2．路插入排序中，移动记录的次数约为n。／8。因此，2．路插入排序只能减少移动
记录的次数，而不能绝对避免移动记录。并且，当L．r[1]是待排序记录中关键字最小或最大的记录时，2．路插入排序就完全失去它的优越性。因此，若希望在排序过程中不移动记录，只有改变存储结构，进行表插入排序。
  三、表插入排序
#d．|fin・SIZE 100
t'rP：n|ct I
  RcdI，pe  re；
  ilIt    next：
}s【Node；
td．z1Ict{
  S~ode r[SIZ~]；
  inth；
lSL~istType；
∥静态链表容量
∥记录项
}}∥表结点类型
∥0号单元为表头结点
∥链表当前长度
∥静态链表类型
    假设以上述说明的静态链表类型作为待排记录序列的存储结构，并且，为了插入方便起见，设数组中下标为“0”的分量为表头结点，并令表头结点记录的关键字取最大整数MAXINT。则表插入排序的过程描述如下：首先将静态链表中数组下标为“1”的分量(结点)和表头结点构成一个循环链表，然后依次将下标为“2”至“n”的分量(结点)按记录关键字非递减有序插入到循环链表中。仍以式(10―4)中的关键字为例，表插入排序的过程如图10．3所示(图中省略记录的其它数据项)。
i=2
key域
next域
i=8
MAXINT l 49 I 38 I 65 I 97 I 76 1 13 I 27
    图10．3表插入排序示例
    从表插入排序的过程可见，表插入排序的基本操作仍是将一个记录插入到已排好序的有序表中。和直接插入排序相比，不同之处仅是以修改2，z次指针值代替移动记录，排序过程中所需进行的关键字间的比较次数相同。因此，表插入排序的时间复杂度仍是0(n。)。
    另一方面，表插入排序的结果只是求得一个有序链表，则只能对它进行顺序查找，不能进行随机查找，为了能实现有序表的折半查找，尚需对记录进行重新排列。
    重排记录的做法是：顺序扫描有序链表，将链表中第i个结点移动至数组的第i个分量中。例如，图10．4(a)是经表插入排序后得到的有序链表SL。根据头结点中指针域的指示，链表的第一个结点，即关键字最小的结点是数组中下标为6的分量，其中记录应移至数组的第一个分量中，则将SL．r[1]和SL．r[6]互换，并且为了不中断静态链表中的“链”，即在继续顺链扫描时仍能找到互换之前在SL_r[1]中的结点，令互换之后的SL．r[1]中指针域的值改为“6”(见图10．4(b))。推广至一般情况，若第i个最小关键字的结点是数组中下标为户且户>i的分量，则互换SL．r[i]和SL．r[p]，且令sL．r[i]中指针域的值改为户；由于此时数组中所有小于i的分量中已是“到位”的记录，则当p<i时，应顺链继续查找直到p≥i为止。图10．4所示为重排记录的全部过程。
初始状态
   耍iG，．重妻；静悉链表数组中记录的过程
    算法10．3描述了二还重排记录的过程。容易看出，在重排记录的过程中，最坏情况是每个记录到位都必须进行一次记录的交换，即3次移动记录，所以重排记录至多需进行3(，z―t-)次记录的移动，它并不增加表插入排序的时间复杂度：
void Arrange(SLi~kList?ype&SL){
  ∥根据静态链表SL中备结点的指针值调整记录位置．浇得sL中记录按关键字
  ∥减有序顺序排列
  p=SL．rio]．next；    ∥p指示第一个记录的当前位置
  ~or(i=】；i<sL．ien~th；十+i)：    ∥SL．r：i．．i―l!中记录已按关键字
    ’乡笼-令记录在sL中的当前位置应不小于i
    while(p<i)  p，三二J．r：≥j．next
    q=sL．rip]．next；
・270・
l∥Arrange
∥交换记录，使第i个记录到位
∥指向被移走的记录，使得以后可由while循环找回
∥p指示尚未调整的表尾，为找第i+1个记录作准备
算法  10．3
    10．2．3希尔排序
    希尔排序(Shell’s Sort)又称“缩小增量排序”(I)iminishing Increment Sort)，它也是一种属插入排序类的方法，但在时间效率上较前述几种排序方法有较大的改进。
    从对直接插入排序的分析得知，其算法时间复杂度为0(”。)，但是，若待排记录序列为“正序”时，其时间复杂度可提高至0(”)。由此可设想，若待排记录序列按关键字“基本有序”，即序列中具有下列特性    I．．rf_i]．ke>r<Maxi I．．r[j]．ke。y’：    ，11)一7)
    l≤】<I
的记录较少时，直接插入排序的效率就可大大提高，叭另一方而来看，由于直接插入排序算法简单，则在，，值很小时效率也比较高。希尔排序正是从这两点分析出发对直接插入排序进行改进得到的一种插入排序方法。
　　它的基本思想是：先将整个待排记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行一次直接插入排字j
　　仍以式(10―4)中的关键字为例，先看一下希尔排序的过程、初始关键字序列如图10．5的第1行所示。首先将该序列分成五个子序列{Ri，R6；，：R 2．R 7∥一，；R，，R】0：，如图10．5的第2行至第6行所示，分别对每个子序列进行直接插入排序，排序结果如图10．5的第7行所示，从第1行的初始序列得到第7行的序列的过程称为一趟希尔排序。然后进行第二趟希尔排序，即分别对下列三个子序列：{R】，R。，R，，R10：，：R 2，R；，R8}和!R3，R。，．R，}进行直接插入排序。其结果如图10．5的第1l行所示，最后对整个序列进行一趟直接插入排序。至此，希尔排序结束，整个序列的记录已按关键字非递减有序排列。
　　从上述排序过程可见，希尔排序的一个特点是：子序列的构成不是简单地“逐段分割”，而是将相隔某个“增量”的记录组成一个子序列。如上例中，第一趟排序时的增量为5，第=趟排序时的增量为3，由于在前两趟的插入排序中记录的关键字是和同一子序列中的前一个记录的关键字进行比较，因此关键字较小的记录就不是一步一步地往前挪动，而是跳跃式地往前移，从而使得在进行最后一趟增量为1的插入排序时．序列已基本有序，只要作记录的少量比较和移动即可完成乔，享，西此綦尔排序的时间复杂度较直接插入排序低。下面用算法语言描述上述希尔排序的过程．为此先将算法10．：改写成如算法10．4所示的一般形式。希尔排序算法如算法lO．5所示。
void ShellInsez‘t(SqList&L，int dk)l
  ∥对顺序表L作一趟希尔插入排序。本算法是：
∥    I前后记录位置的增越是出，而不是l；
∥    2 r[0]只是暂存单元，不是哨兵。当]<=0时，插入位置已找到。
算法】0 4
vold ShellSort(SqList＆L，int dlta[]．i北t)I
  ∥按增世序l列dita[O t～l】对顺序表L作希尔排序。
    Shelllns~t(L．dlta[k】)；    ∥一趟增m}为~ta[k]的插人排序
l／／ShellSort
    算法lO 5
(关键字]t  {9 38 65 97，6 l 3卵石55 04
一趟排序结*：  13
排序结果z  13 04石拍一27 49 55 65 97 76
结果・04 13 27 38 49 49 55 65 76 97
    希尔排序的分析是一个复杂的问题．因为它的时间是所取“增量”序列的函数，这涉及一些数学上尚未解决的难题。l烈此，到目前为止尚未有八求得一种最好的，希尔排序所需的比较和移动次数约为n1．．．，当恕+oo时，可减少到n(】tog2以)。旺’。增量序列可以有各种取法①，但需注意应使增量序列中的值没有除1之外的公因子，并且最后一个增量值必须等于1。
10．3快速排序
    这一节讨论一类藉助“交换”进行排序的方法，其中最简单的一种就是人们所熟知的起泡排序(Bubble Sort)o
    起泡排序的过程很简单。首先将第一个记录的关键字和第二个记录的关键字进行比较，若为逆序(即L．r[1]．key>L．r[2]．key)，则将两个记录交换之，然后比较第二个记录和第三个记录的关键字。依次类推，直至第n-1个记录和第n个记录的关键字进行过比较为止。上述过程称作第一趟起泡排序，其结果使得关键字最大的记录被安置到最后一个记录的位置上。然后进行第二趟起泡排序，对前，l-1个记录进行同样操作，其结果是使关键字次大的记录被安置到第旭-1个记录的位置上。一般地，第i趟起泡排序是从L．f[1]到L．r[n―j+1]依次比较相邻两个记录的关键字，并在“逆序”时交换相邻记录，其结果是这n―i+1个记录中关键字最大的记录被交换到第，z―i+1的位置上。整个排序过程需进行忌(1≤愚<n)趟起泡排序，显然，判别起泡排序结束的条件应该是“在一趟排序过程中没有进行过交换记录的操作”。图10．6展示了起泡排序的一个实例。从图中可见，在起泡排序的过程中，关键字较小的记录好比水中气泡逐趟向上飘浮，而关键字较大的记录好比石块往下沉，每一趟有一块“最大”的石头沉到水底(请参见“1．43算法效率的度量”中起泡排序的算法)。
    图10．6起泡排序示例
分析起泡排序的效率，容易看出，若初始序列为“正序”序列，则只需进行一趟排序，在
①其它增量序列如：
"第一趟排序后
排序过程中进行n―1次关键字间的比较，且不移动记录；反之，若初始序列为“逆序”序列，则需进行礼-1趟排序，需进行乏：(i-1)：n(n-1)／2次比较，并作等数量级的记录
移动。因此，总的时间复杂度为O(n2)。
    快速排序(Quiek Sort)是对起泡排序的一种改进。它的基本思想是，通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。
　　假设待排序的序列为{L_r[s]，L_r[s+1]，…，L．r[t]}，首先任意选取一个记录(通常可选第一个记录L．r[s])作为枢轴(或支点)(pivot)，然后按下述原则重新排列其余记录：将所有关键字较它小的记录都安置在它的位置之前，将所有关键字较它大的记录都安置在它的位置之后。由此可以该“枢轴”记录最后所落的位置i作分界线，将序列{L．r[s]，…，L．r[t]}分割成两个子序列{L．r[s]，L．r[s+1]，…，L．r[i-1]}和{L．r[i+1]，L．r[i+2]，…，L．r【t]}。这个过程称作一趟快速排序(或一次划分)。
　　一趟快速排序的具体做法是：附设两个指针low和high，它们的初值分别为lOW和high，设枢轴记录的关键字为pivotkey，则首先从high所指位置起向前搜索找到第一个关键字小于pivotkey的记录和枢轴记录互相交换，然后从low所指位置起向后搜索，找到第一个关键字大于pivotkey的记录和枢轴记录互相交换，重复这两步直至low=high为止。其算法如算法10．6(a)所示。
int Partitlon(SqUist＆L，int low，int high){
  ∥交换顺序表L中子表L．r[1Dw．．high]的记录，使枢轴记录到位，并返回其所在位置，此时
  ∥在它之前(后)的记录均不大(小)于它。
  plvotkey=L．r【．10w]．key；    ∥用子表的第一个记录作枢轴记录
  while(10w<high){    ∥从表的两端交替地向中间扫描
    L．r[10w]--L．r[high]；    ∥将比枢轴记录小的记录交换到低端
    whi．1e(10w<high＆&L．r[10W]．key<=pivotkey)  十+low；
    L．r【10w卜--L．r[high]；    ∥将比枢轴记录大的记录交换到高端
  I
  retchl 10w；    ∥返回枢轴所在位置
I∥Partition
    算法10．6【a)
    具体实现上述算法时，每交换一对记录需进行三次记录移动(赋值)的操作。而实际上，在排序过程中对枢轴记录的赋值是多余的，因为只有在一趟排序结束时，即lOW：laigh的位置才是枢轴记录的最后位置。由此可改写上述算法，先将枢轴记录暂存在r[0]的位置上，排序过程中只作r[10w]或r[high]的单向移动，直至一趟排序结束后再将枢轴记录移至正确位置上。如算法10．6(b)所示。
int Partition(SqList＆L，int low，int high){
  ∥交换顺序表L中子表r[10w．．high]的记录，枢轴记录到位，并返回其所在位置，此时
  ∥在它之前(后)的记录均不大(小)于它。
  L，r[0]=L．r[10w]；
・274・
∥用子表的第一个记录作枢轴记录
  plvotkey=L．r[10w]．key；    ∥枢轴记录关键字
  while(10w<high)l    ∥从表的两端交替地向中间扫描
    while(10w<high＆&L．r[high]．key>=pivotkey)--high；
    L．r[10w]=L．r[high]；    ∥将比枢轴记录小的记录移到低端
    while(10w<high＆＆L．r【low]．key<=pivotkey)++low；
    L．r[high]=L．r【low]；    ∥将比枢轴记录大的记录移到高端
  }
  L．r[10w]=L．r[0]；    ∥枢轴记录到位
  return low；    ∥返回枢轴位置
t??Partition
    算法10．6(b)
    以式(10．4)中的关键字为例，一趟快排的过程如图10．7(a)所示。整个快速排序的过程可递归进行。若待排序列中只有一个记录，显然已有序，否则进行一趟快速排序后再分别对分割所得的两个子序列进行快速排序，如图10．7(b)所示。
    pivotkey
初始关键字
进行2次交换之后  27  38
进行3次交换之后  27  38
进行4次交换之后  27  38  13    76  97  65  ―49
完成一趟排序    27  38  13 49  76  97  65  ―49
    (a)
    初始状态    }49  38  65  97  76  13
    一次划分之后    }27  38  13}  49  {76  97
    分别进行快速排序  {13}  27  {38}
    有序序列    {13  27  38 49  ―49  65
    (b)
    图10．7快速排序示例
    (a)一趟快排过程；(b)排序的全过程。
递归形式的快速排序算法如算法10．7和算法10．8所示。
void QSort(SqLi8t＆L。int 10w。int high){
  ∥对顺序表L中的子序列L．r[10w．．high]作快速排序
  if(10w<high)I    ∥长度大于1
    pivot]．oc=Partition(L，10w，high)；    ∥将L．r[10w．．high]一分为二
    QSort(L，10w，pi・votloc―1)；    ∥对低子表递归排序，pivotloc是枢轴位置
    QSort(n，pivotloc+l，high)；    ∥对高子表递归排序
  I
}∥QSort
    算法10．7
void QuickSort(SqList an){
  ∥对顺序表L作快速排序。
  QSort(L，l。L．1ength)；
}∥QuickSort
算法lO．8
    快速排序的平均时间为L馏(竹)=足以Inn，其中n为待排序序列中记录的个数，是为某个常数，经验证明，在所有同数量级的此类(先进的)排序方法中，快速排序的常数因子最小。因此，就平均时间而言，快速排序是目前被认为是最好的一种内部排序方法。
    下面我们来分析快速排序的平均时间性能。
    假设T(”)为对n个记录L．r[1．．n]进行快速排序所需时间，则由算法QuickSon可见，其中丁加。(n)为对n个记录进行一趟快速排序Partition(L，1，n)所需时间，从算法10．7可见，它和记录数扎成正比，可以cn表示之(c为某个常数)；T(忌-1)和T(扎一愚)分别为对L．r[1．．k-1]和L．r[k+1．．n]中记录进行快速排序QSort(L，1，k-1)和Q!Sort(L，k+1，n)所需时间。假设待排序列中的记录是随机排列的，则在一趟排序之后，足取1至n之间任何一值的概率相同，快速排序所需时间的平均值则为
    通常，快速排序被认为是，在所有同数量级(0(10g恕))的排序方法中，其平均性能最好。但是，若初始记录序列按关键字有序或基本有序时，快速排序将蜕化为起泡排序，其时间复杂度为0(n。)。为改进之，通常依“三者取中”的法则来选取枢轴记录，即比较L．r[s]．key、LI r[t]．key和L．rl I半l I．key，取三者中其关键字取中值的记录为枢轴，只要将该记录和L．r[s]互换，算法10．6(b)。不变。经验证明，采用三者取中的规则可大大改善快速排序在最坏情况下的性能。然而，即使如此，也不能使快速排序在待排记录序列已按关键字有序的情况下达到0(n)的时间复杂度。为此，可如下所述修改“一次划分”算法：在指针high减l和low增1的同时进行“起泡”操作，即在相邻两个记录处于“逆序”时进行互换，同时在算法中附设两个布尔型变量分别指示指针low和high在从两端向中间的移动过程中是否进行过交换记录的操作，若指针．10w在从低端向中间的移动过程中没有进行交换记录的操作，则不再需要对低端子表进行排序；类似地，若指针high在从高端向中间的移动过程中没有进行交换记录的操作，则不再需要对高端子表进行排序。显然。如此“划分”将进一步改善快速排序的平均性能。
　　由以上讨论可知，从时间上看，快速排序的平均性能优于前面讨论过的各种排序方法，从空间上看，前面讨论的各种方法，除2．路插入排序之外，都只需要一个记录的附加空间即可，但快速排序需一个栈空间来实现递归。若每一趟排序都将记录序列均匀地分割成长度相接近的两个子序列，则栈的最大深度为L logzn j+1(包括最外层参量进栈)，但是，若每趟排序之后，枢轴位置均偏向子序列的一端，则为最坏情况，栈的最大深度为n。如果改写算法10．7，在一趟排序之后比较分割所得两部分的长度，且先对长度短的子序列中的记录进行快速排序，则栈的最大深度可降为O(10g)。
10．4选择排序
    选择排序(Selection Sot’t)的基本思想是：每一趟在n―i+1(i=1，2，…，恕-1)个记录中选取关键字最小的记录作为有序序列中第i个记录。其中最简单、且为读者最熟悉的是简单选择排序。(simple Selection Sort)。
  10．4．1简单选择排序
  一趟简单选择排序的操作为：通过n―z次关键字间的比较，从n一i+1个记录中选出关键字最小的记录，并和第i(1≤{≤n)个记录交换之。
    显然，对L．r[1．．n]中记录进行简单选择排序的算法为：令i从1至凡-1，进行n一1趟选择操作，如算法10．9所示。容易看出，简单选择排序过程中，所需进行记录移动的操作次数较少，其最小值为“0”，最大值为3(n-1)。然而，无论记录的初始排列如何，所需进行的关键字间的比较次数相同，均为n(n-1)／2。因此，总的时间复杂度也是0(n0)。
’'oid SelectSort(SqList＆L)l
∥对顺序表L作简单选择排序。
for(i≈1；i<L．1ength；++i)l
  j=SelectMinKey(L，i)；
∥选择第i小的记录，并交换到位
∥在L．r[i．．L．1en~h]中选择key最小的记录
・277・
    if(i!：j)L．r[1卜--L．r【jj；    ∥与第i个记录交换
}
∥SelectSort
    算法10．9
    那末，能否加以改进呢?
    从上述可见，选择排序的主要操作是进行关键字间的比较，因此改进简单选择排序应从如何减少“比较”出发考虑。显然，在n个关键字中选出最小值，至少进行，z-1次比较，然而，继续在剩余的，z―1个关键字中选择次小值就并非一定要进行”一2次比较，若能利用前”-1次比较所得信息，则可减少以后各趟选择排序中所用的比较次数。实际上，体育比赛中的锦标赛便是一种选择排序。例如，在八个运动员中决出前三名至多需要11场比赛，而不是7+6十5=18场比赛(它的前提是，若乙胜丙，甲胜乙，则认为甲必能胜丙)。例如，图10．8(a)中最低层的叶子结点中8个选手之间经过第一轮的四场比赛之后选拔出四个优胜者“cH久’、“BA()”、“DIAO”和“wANG”，然后经过两场半决赛和一场决赛之后，选拔出冠军“．BA()”。显然，按照锦标赛的传递关系，亚军只能产生于分别在决赛，半决赛和第一轮比赛中输给冠军的选手中。由此，在经过“CHA”和“LIU”、“CHA”和“DIA()”的两场比赛之后，选拔出亚军“CHA”，同理，选拔殿军的比赛只要在“ZHAO'’、“LIu”和“DIAO”三个选手之间进行即可。按照这种锦标赛的思想可导出树形选择排序。
10．4．2树形选择排序
    树形选择排序(1】?ree Selection Sort)，又称锦标赛排序(170urnament Sort)，是一种按照锦标赛的思想进行选择排亭的方法。首先对竹个记录的关键字进行两两比较，然后在其中厂詈]个较小者之间再进行两两比较，如此重复，直至选出最小关键字的记录为止。这个过程可用一棵有”个叶子结点的完全二叉树表示。一例如，图10．9(a)中的二叉树表示从8个关键字中选出最小关键字的过程。8个叶子结点中依次存放排序之前的8个关键字，每个非终端结点中的关键字均等于其左、右孩子结点中较小的关键字，则根结点中的关键字即为叶子结点中的最小关键字。在输出最小关键字之后，根据关系的可传递性，欲选出次小关键字，仅需将叶子结点中的最小关键字(13)改为“最大值”，然后从该叶子结点开始，和其左(或右)兄弟的关键字进行比较，修改从叶子结点到根的路径上各结点的关键字，则根结点的关键字即为次小关键字。同理，可依次选出从小到大的所有关键字(参见图10．9(b)和(c))。由于含有，z个叶子结点的完全二叉树的深度为厂log：”]+1，则在树形选择排序中，除了最小关键字之外，每选择一个次小关键字仅需进行厂bg2n]次比较，因此，它的时间复杂度为0(，zlog2n)。但是，这种排序方法尚有辅助存储空间较多、和“最大值”进行多余的比较等缺点。为了弥补，威洛姆斯(J．willioms)在1964年提出了另一种形式的选择排序――堆排序。
10．4．3堆排序
堆排序(Ileap Sort)只需要一个记录大小的辅助空间，每个待排序的记录仅占有一个・278・
    (a)选拔冠军的比赛程序；(b)选拔亚军的两场比赛；(c)选拔殿军的两场比赛。
存储空间。
    堆的定义如下：”个元素的序列m。，五2，…，忌。}当且仅当满足下关系时，称之为堆。
    若将和此序列对应的一维数组(即以一维数组作此序列的存储结构)看成是一个完全二叉树，则堆的含义表明，完全二叉树中所有非终端结点的值均不大于(或不小于)其左、右孩子结点的值。由此，若序列}七l，是2，…，尼。}是堆，则堆顶元素(或完全二叉树的根)必为序列中扎个元素的最小值(或最大值)。例如，下列两个序列为堆，对应的完全二叉树如图10．10所示。
    图10．9树形选择排序示例
(a)~_／ilt小关键字为13；(b)选出次小关键字为27；(c)选出居第三的关键字为38。
    图10．10堆的示例
    (a)堆顶元素取最大值；(b)堆顶元素取最小值。
　　若在输出堆顶的最小值之后，使得剩余n-1个元素的序列重又建成一个堆，则得到”个元素中的次小值。如此反复执行，便能得到一个有序序列，这个过程称之为堆排序。
　　由此，实现堆排序需要解决两个问题：(1)如何由一个无序序列建成一个堆?(2)如何在输出堆顶元素之后，调整剩余元素成为一个新的堆?
　　下面先讨论第二个问题。例如，图10．11(a)是个堆，假设输出堆顶元素之后，以堆中最后一个元素替代之，如图10．11(b)所示。此时根结点的左、右子树均为堆，则仅需自上至下进行调整即可。首先以堆顶元素和其左、右子树根结点的值比较之，由于右子树根结点的值小于左子树根结点的值且小于根结点的值，则将27和97交换之；由于97替代了27之后破坏了右子树的“堆”，则需进行和上述相同的调整，直至叶子结点，调整后的状态如图10．11(c)所示，此时堆顶为n-1个元素中的最小值。重复上述过程，将堆顶元素27和堆中最后一个元素97交换且调整，得到如图10．11(d)所示新的堆。
    图10．11输出堆顶元素并调整建新堆的过程
(a) 堆；(b)13~97交换后的情形；(c)调整后的新推；(d)27和97交换后再进行调整建成的新堆。
(b)     我们称这个自堆顶至叶子的调整过程为“筛选”。
    从一个无序序列建堆的过程就是一个反复“筛选”的过程。若将此序列看成是一个完全二叉树，则最后一个非终端结点是第L恕／2 J个元素，由此“筛选”只需从第L个元素开始。例如，图10．12(a)中的二叉树表示一个有8个元素的无序序列    {49，38，65，97，76，13，27，丽}则筛选从第4个元素开始，由于97>丽，则交换之，交换后的序列如图10．12(b)所示，同理，在第3个元素65被筛选之后序列的状态如图10．12(c)所示。由于第2个元素38不大于其左、右子树根的值，则筛选后的序列不变。图10．12(e)所示为筛选根元素49之后建成的堆。    
    堆排序的算法如算法10．11所示，其中筛选的算法如算法10．10所示。为使排序结果和10．1节中的定义一致，即：使记录序列按关键字非递减有序排列，则在堆排序的算法中先建一个“大顶堆”，即先选得一个关键字为最大的记录并与序列中最后一个记录交换，然后对序列中前他-1记录进行筛选，重新将它调整为一个“大顶堆”，如此反复直至排序结束。由此，“筛选”应沿关键字较大的孩子结点向下进行。
typ．def sqList HeapType；    ∥堆采用顺序表存储表示
void HeapAdjust(HeapType&H’int s，int m){
  ∥已知H．r[s．．m]中记录的关键字除H．r[8]．key之外均满足堆的定义，本函数调整H．r[s]  ∥的关键字，使H．r[s．．m]成为一个大顶堆(对其中记录的关键字而言)
∥将堆顶记录和当前未经排序于序列Mr【1 1】中
∥最后一个记录相互交换
∥将H r[1--1]重新调整为大顶堆
算法10 11
    堆排序方法对记录数较少的文件并不值得提倡，但对”较大的文件还是很有效的。因为其运行时间主要耗费在建初始堆和调整建新堆时进行的反复“筛选’’上。对深度为n的堆，筛选算法中进行的关键字比较次数至多为2(忌-1)次，则在建含n个元素、深度为^的堆时，总共进行的关键字比较次数不超过4n。①又，以个结点的完全二叉树的深度为L log2，2 J+1，则调整建新堆时调用}teapAdjust过程n-1次，总共进行的比较次数不超过下式之值，由此，堆排序在最坏的情况下，其时间复杂度也为0(nlog”)。相对于快速排序来说，这是堆排序的最大优点。此外，堆排序仅需一个记录大小供交换用的辅助存储空间。
10．5  归并排序
    归并排序(Merging Sort)是又一类不同的排序方法。“归并”的含义是将两个或两个以上的有序表组合成一个新的有序表。它的实现方法早已为读者所熟悉，无论是顺序存储结构还是链表存储结构，都可在0(优+竹)②的时间量级上实现。利用归并的思想容易实现排序。假设初始序列含有礼个记录，则可看成是竹个有序的子序列，每个子序列的长度为1，然后两两归并，得到r等]个长度为2或1的有序子序列；再两两归并，……，如此重复，直至得到一个长度为n的有序序列为止，这种排序方法称为2．路归并排序。例如图10．13为2．路归并排序的一个例子。
初始关键字
一趟归并之后
二趟归并之后
    图1Q 13争路归并排序示例
    2一路归并排序中的核心操作是将一维数组中前后相邻的两个有序序列归并为一个有序序列，其算法(类似于算法2．7)如算法10．12所示。
vold Merge(RcdType sa[]，aed~hrpe＆TR[]，int i，城m，int n){
  ∥将有序的sa[i．．m]和sa[m+1．．n]归并为有序的Ta[i．．n]
  for(j=m+1，k=i；i<=m＆&j<=n；十+k)l    ∥将sR中记录由小到大地并入TR
  ①由于第i层上的结点数至多为2i-1，以它们为根的二叉树的深度为^一i+1。则调用l号J次HeapAdjust
过程时总共进行的关键字比较次数不超过下式之值：
    算法10．12
    一趟归并排序的操作是，调用n次算法merge将SR[1．．n]中前后相邻且长度
为^的有序段进行两两归并，得到前后相邻、长度为2矗的有序段，并存放在TR[1．．n]中，整个归并排序需进行[10g2，z]趟。可见，实现归并排序需和待排记录等数量的辅助空间，其时间复杂度为o(nlog2n)。
    递归形式的2．路归并排序的算法如算法10．13和算法10．14所示。值得提醒的是，递归形式的算法在形式上较简洁，但实用性很差。其非递归形式的算法可查阅参考书目[1]。
    与快速排序和堆排序相比，归并排序的最大特点是，它是一种稳定的排序方法。但在一般情况下，很少利用2一路归并排序法进行内部排序，其它形式的归并排序如本书习题集中习题10．17所述。
  ∥将sR[s．．t]归并排序为TRI[s．．t]。
  if(s==t)TRI[s]=sR[s]；
  e18・l
    m=(s+t)／2；    ∥将sR[s．．t]平分为sR[s．．m]和sR[e+1．．t]
    MSort(sR，啦，s，m)；    ∥递归地将SR[s．．m]归并为有序的TR2【s．．m]
    MSort(ss，TR2，m+l，t)；  ∥递归地将sR[m+1．．t]归并为有序的TR2[m+1．．t]
    Merge(啦，TRl，s，m，t)；∥将TR2[s．．m]和TR2[m+1．．t]归并到TRI[s．．t]
  }
}∥MSort
    算法10．13
woi4 MergeSort(SqList aL)l
  ∥对顺序表L作归并排序。
  MSorlt(L．r，L。r，l，L．1ength)；"
I∥MezgeSort
算法lO．14
10．6基数排序
    基数排序(Radix Sorting)是和前面所述各类排序方法完全不相同的一种排序方法。从前几节的讨论可见，实现排序主要是通过关键字间的比较和移动记录这两种操作，而实现基数排序不需要进行记录关键字间的比较。基数排序是一种借助多关键字排序的思想对单逻辑关键字进行排序的方法。
  10．6．1多关键字的排序
  什么是多关键字排序问题?先看一个具体例子。
  已知扑克牌中52张牌面的次序关系为：
    ●2<．．13<…<．．．A<◆2<◆3<…<◆A
    <◆2<1-13<…<◆A<．．-2<●3<…<●A
每一张牌有两个“关键字”：花色(．．．<◆<◆<．．I)和面值(2<3<…<A)，且“花色”的地位高于“面值”，在比较任意两张牌面的大小时，必须先比较“花色”，若“花色”相同，则再比较面值。由此，将扑克牌整理成如上所述次序关系时，通常采用的办法是：先按不同“花色”分成有次序的四堆，每一堆的牌均具有相同的“花色”，然后分别对每一堆按“面值”大小整理有序。
    也可采用另一种办法：先按不同“面值”分成13堆，然后将这13堆牌自小至大叠在一起(“3”在“2”之上，“4”在“3”之上，……，最上面的是4张“A”)，然后将这付牌整个颠倒过来再重新按不同“花色”分成4堆，最后将这4堆牌按自小至大的次序合在一起(●在最下面，．．I在最上面)，此时同样得到一付满足如上次序关系的牌。这两种整理扑克牌的方法便是两种多关键字的排序方法。
    一般情况下，假设有n个记录的序列
    {R1，R2，…R。}    (10―10)
且每个记录Ri中含有d个关键字(K?，K：，…，础-1)，则称序列(10-10)对关键字(K。，K。，…，K扣’)有序是指：对于序列中任意两个记录Ri和Rj(1≤i<．j≤n)都满足下列有序关系①：
    (K?，Kj，…，K：-1)<(K?，Kj，…，Kj。)
其中K。称为最主位关键字，Kd。称为最次位关键字。为实现多关键字排序，通常有两种方法：第一种方法是：先对最主位关键字K0进行排序，将序列分成若干子序列，每个子序列中的记录都具有相同的K。值，然后分别就每个子序列对关键字K’进行排序，按K。值不同再分成若干更小的子序列，依次重复，直至对．Kaq进行排序之后得到的每一子序列中的记录都具有相同的关键字(Ko，K‘，…，K扩。)，而后分别每个子序列对K。进行排序，最后将所有子序列依次联接在一起成为一个有序序列，这种方法称之为最高位优先(Most Significant Digit．first)法，简称MSD法；第二种方法是从最次位关键字Kd 11起进行排序。然后再对高一位的关键字Kd 1进行排序，依次重复，直至对Ko进行排序后便成为一个有序序列。这种方法称之为最低位优先(I~east Significant Digit first)法，简称LSD法。
    MSD和L,SD只约定按什么样的“关键字次序”来进行排序，而未规定对每个关键字进行排序时所用的方法。但从上面所述可以看出这两种排序方法的不同特点：若按①  (“。，Ⅱ。，…，口。一。)<(6。，6’，…，∥一’)是指必定存在z，使得}当5=0，…，z―l时，akbe。而a‘<b‘。
．MS[)进行排序，必须将序列逐层分割成若干子序列，然后对各子序列分别进行排序；而按LsD进行排序时，不必分成子序列，对每个关键字都是整个序列参加排序，但对K’(0≤i≤d一2)进行排序时，只能用稳定的排序方法。另一方面，按LSD进行排序时，在一定的条件下(即对前一个关键字Ki(0≤i≤d一2)的不同值，后一个关键字KH‘均取相同值)，也可以不利用前几节所述各种通过关键字间的比较来实现排序的方法，而是通过若干次“分配”和“收集”来实现排序，如上述第二种整理扑克牌的方法那样。
  10．6．2链式基数排序
  基数排序是借助“分配”和“收集”两种操作对单逻辑关键字进行排序的一种内部排序方法。
  有的逻辑关键字可以看成由若干个关键字复合而成的。例如，若关键字是数值，且其值都在0≤K≤999范围内，则可把每一个十进数字看成一个关键字，即可认为K由三个关键字(K。，K‘，K。)组成，其中Ko是百位数，K‘是十位数，K。是个位数；又若关键字K是由五个字母组成的单词，则可看成是由五个关键字(K0，K’，K。，K0，K。)组成，其中11是(自左至右的)第J+1个字母。由于如此分解而得的每个关键字印都在相同的范围内(对数字，0≤Kj≤9，对字母’A’≤Kj≤’Z’)，则按LSD进行排序更为方便，只要从最低数位关键字起，按关键字的不同值将序列中记录“分配”到RADIX个队列中后再“收集”之，如此重复d次。按这种方法实现排序称之为基数排序，其中“基”指的是RADIX的取值范围，在上述两种关键字的情况下，它们分别为“10”和“26”。
　　实际上，早在计算机出现之前，利用卡片分类机对穿孔卡上的记录进行排序就是用的这种方法。然而，在计算机出现之后却长期得不到应用，原因是所需的辅助存储量(RADIX×N个记录空间)太大。直到1954年有人提出用“计数”代替“分配”才使基数排序得以在计算机上实现，但此时仍需要犯个记录和2×RADIX个计数单元的辅助空间。
　　此后，有人提出用链表作存储结构，则又省去了”个记录的辅助空间。下面我们就来介绍这种“链式基数排序”的方法。
    先看一个具体例子。首先以静态链表存储n个待排记录，并令表头指针指向第一个记录，如图10．14(a)所示；第一趟分配对最低数位关键字(个位数)进行，改变记录的指针值将链表中的记录分配至10个链队列中去，每个队列中的记录关键字的个位数相等，如图10．14(b)所示，其中f[i]和e[i]分别为第i个队列的头指针和尾指针；第一趟收集是改变所有非空队列的队尾记录的指针域，令其指向下一个非空队列的队头记录，重新将10个队列中的记录链成一个链表，如图10．14(c)所示；第二趟分配，第二趟收集及第三趟分配和第三趟收集分别是对十位数和百位数进行的，其过程和个位数相同，如图10．14(d)～(g)所示。至此排序完毕。
    在描述算法之前，尚需定义新的数据类型
#define MAX―NUll一0F―KEY 8
#deflne RADIX    10
#define MAX―SPACE  10000
。t／Imdef struct{
・286・
∥关键字项数的最大值
∥关键字基数，此时是十进制整数的基数
(g)
    图10．14链式基数排序示例
(a)初始状态；(b)第一趟分配之后；(c)第一趟收集之后；(d)第二趟分配之后
  (e)第二趟收集之后；(f)第三趟分配之后；(g)第三趟收集之后的有序文件
  KeysType keys[MAX―NUM―OF
  InfoType otheritems；
  int next；
}SLCell；
typedef struct{
KEY]；  ∥关键字
    ∥其它数据项
∥静态链表的结点类型
・287・
  SLCell r[MAX―SPACE]；
  int    keynum；
  int    recnum：
}SLList；
typedef int ArrType[RADIX]；
∥静态链表的可利用空间，r[O]为头结点
∥记录的当前关键字个数
∥静态链表的当前长度
∥静态链表类型
∥指针数组类型
    算法10．15为链式基数排序中一趟分配的算法，算法10．16为一趟收集的算法，算法10．17为链式基数排序的算法。从算法中容易看出，对于”个记录(假设每个记录含d个关键宇，每个关键字的取值范围为以个值)进行链式基数排序的时间复杂度为O(d(n+rd))，其中每一趟分配的时间复杂度为0(n)，每一趟收集的时间复杂度为O()，
整个排序需进行d趟分配和收集。所需辅助空间为2rd个队列指针。当然，由于需用链表作存储结构，则相对于其它以顺序结构存储记录的排序方法而言，还增加了”个指针域的空间。
void Distribute(SLCell&r，int i，ArrTyPe&f，ArrType＆e){
  ∥静态链表L的r域中记录已按(keys[0]，…，keys[i-1])有序。
  ∥本算法按第i个关键字keys[i]建立RADIX个子表，使同一子表中记录的keys[i]相同  ∥f[o．．RADIX-1]和e10．．RADIX-1]分别指向各子表中第一个和最后一个记录。
  for(J=0；J<Radix；++j)f[J]=0；    ∥各子表初始化为空表
  for(P=rio]．next；p；P=rip]．next){
    J：ord(r[p]．keys[i])；    ∥
    if(!f[j])f[j]=p；
    else r[e[j]]．next：p；
    e[j]=p；
  }
I ff Distribute
ord将记录中第i个关键字映射到[0．．RADIX―i]，
∥将P所指的结点插入第j个子表中
算法10．15
void Collect(SLCell＆r，int i，ArrType f，ArrType e){
  ∥本算法按keys[i]自小至大地将f[0．．RADIX-1]所指备子表依次链接成一个链表，
  ∥e10．．RADIX-1]为各子表的尾指针。
  ~or(J。0；!f[J]；J：SUCC(J))；∥找第一个非空子表，SUCC为求后继函数
  r[0 J．next=f[J]；t=e[J]；    ∥r[0]．next指向第一个非空子表中第一个结点
  while(J<RADIX){
    for(J。SUCC(j)；  J<RADIX―i＆＆!f[J]；  j：SUCC(J))；    ∥找下一个非空子表
    if(f[j]){r[t]．next=f[J]；t=e[]]；I    ∥链接两个非空子表
  }
  r[t]．next：0；
＼?f Collect
∥t指向最后一个非空子表中的最后一个结点
算法10．16
 void RadixSort(SLList&L){
    ∥L是采用静态链表表示的顺序表。
    ∥对L作基数排序，使得L成为按关键字自小到大的有序静态链表。L．r[0]为头结点。
    for(i=0；i<L．recnum；++i)  L．r[i]．next=i+1：
・288・
  L．r[L．recn衄]．ne)【t：0；    ∥将L改造为静态链表
  for(i=O；i<L．keyn唧；++i){∥按最低位优先依次对各关键字进行分配和收集
    Distri~te(L．r，1，f，e)；    ∥第i趟分配
    Co]lect(I．．r，i，f，e)；    ∥第i趟收集
  }
}∥Radixsort
    算法10．17
10．7各种内部排序方法的比较讨论
综合比较本章内讨论的各种内部排序方法，大致有如下结果：
┏━━━━━━━┳━━━━━━━━┳━━━━━━━━┳━━━━━━━┓
┃    排序方法  ┃    平均时间    ┃    最坏情况    ┃    辅助存储  ┃
┣━━━━━━━╋━━━━━━━━╋━━━━━━━━╋━━━━━━━┫
┃    简单排序  ┃    O(n。)      ┃    o(”。)     ┃    0(1)      ┃
┃    快速排序  ┃    o(nlogn)    ┃    o(月。)     ┃    O(1。g”) ┃
┃    堆排序    ┃    0(月l。g”) ┃    O(”log≈)  ┃    O(1)      ┃
┃    归并排序  ┃    o("logn)    ┃    O(nbgn)     ┃    O(规)     ┃
┃    基数排序  ┃    o(d(”+刑)) ┃    O(d(n+以))  ┃    0(一)     ┃
┗━━━━━━━┻━━━━━━━━┻━━━━━━━━┻━━━━━━━┛
    从上表司以得出如F几个结论：
    (1)从平均时间性能而言，快速排序最佳，其所需时间最省，但快速排序在最坏情况下的时间性能不如堆排序和归并排序。而后两者相比较的结果是，在佗较大时，归并排序所需时间较堆排序省，但它所需的辅助存储量最多。
    (2)上表中的“简单排序”包括除希尔排序之外的所有插入排序，起泡排序和简单选择排序，其中以直接插入排序为最简单，当序列中的记录“基本有序”或n值较小时，它是最佳的排序方法，因此常将它和其它的排序方法，诸如快速排序、归并排序等结合在一起使用。
    (3)基数排序的时间复杂度也可写成0(d・”)。因此，它最适用于n值很大而关键字较小的序列。若关键字也很大，而序列中大多数记录的“最高位关键字”均不同，则亦可先按“最高位关键字”不同将序列分成若干“小”的子序列，而后进行直接插入排序。
    (4)从方法的稳定性来比较，基数排序是稳定的内排方法，所有时间复杂度为0(n。)的简单排序法也是稳定的，然而，快速排序、堆排序和希尔排序等时间性能较好的排序方法都是不稳定的。一般来说，排序过程中的“比较”是在“相邻的两个记录关键字”间进行的排序方法是稳定的。值得提出的是，稳定性是由方法本身决定的，对不稳定的排序方法而言，不管其描述形式如何，总能举出一个说明不稳定的实例来。反之，对稳定的排序方法，总能找到一种不引起不稳定的描述形式。由于大多数情况下排序是按记录的主关键字进行的，则所用的排序方法是否稳定无关紧要。若排序按记录的次关键字进行，则应根据问题所需慎重选择排序方法及其描述算法。
    综上所述，在本章讨论的所有排序方法中，没有哪一种是绝对最优的。有的适用于n较大的情况，有的适用于”较小的情况，有的……等等。因此，在实用时需根据不同情况适当选用，甚至可将多种方法结合起来使用。
    本章讨论的多数排序算法是在顺序存储结构上实现的，因此在排序过程中需进行大量记录的移动。当记录很大(即每个记录所占空间较多)时，时间耗费很大，此时可采用静态链表作存储结构。如表插入排序、链式基数排序，以修改指针代替移动记录。但是，有的排序方法，如快速排序和堆排序，无法实现表排序。在这种情况下可以进行“地址排序”，即另设一个地址向量指示相应记录；同时在排序过程中不移动记录而移动地址向量中相应分量的内容。例如对图10．15(a)所示记录序列进行地址排序时，可附设向量adr(1：8)。在开始排序之前令adr÷[i]：=i，凡在排序过程中需进行r[i]：：r[j]的操作时，均以adr・[i]：：adr[j]代替，则在排序结束之后，地址向量中的值指示排序后的记录的次序，r[adr[1]]为关键字最小的记录，r[adr[8]]为关键字最大的记录，如图10．15(b)所示。最后在需要时可根据adr的值重排记录的物理位置。重排算法如下：
r(1：8)
adr(1：81
 r(1：8)
    图10．15地址排序示例．
　　(a)待排记录和地址向量的初始状态；(b)排序结束后的地址向量；(c)重排记录过程中的状态从卢1起依次检查每个分量位置上的记录是否正确到位。若adr[i]=i，则r[i]中恰为第i个最小关键字的记录，该位置上的记录不需要调整；若adr[i]=k≠i，则说明r[k]中记录是第i个最小关键字的记录，应在暂存记录r[i]之后将r[k]中记录移至r[i]的位置①上。类似地，若adz_[k]≠k，则应将r[adr[k]]中记录移至r[k]的位置上。依次类推，直至找到某个值j=adr[adr[．．・adr[k]．．・]]，等式adr・Ⅲ=i成立时，将暂存记录移至rⅢ的位置上。至此完成一个调整记录位置的小循环。例如图10．15的例子，由于图10．15(b)中adr。[1]：6，则在暂存R(49)以后，需将R(13)从r[6]的位置移至r[1]的位置。又，因为adr[6]：2，则应将R(65)从r[2]的位置移至r[6]的位置。同理，将R(27)移至r[2]的位置，此时，因adr[4]=1，则R(49)应置入r[4]的位置上。完成上述调整后的记录及地址向量的状态如图10．15(c)所示。算法10．18即为上述重排记录的算法。
　　①r[i]的位置指的是r数组中第i个分量，下同。
void Rear．range(SqList&L，int adz．[])I
  ∥adz・给出顺序表L的有序次序，即L．r[adr[i]]是第i小的记录。
  ∥本算法按adr重排L．r，使其有序。
  for(i=1；i<L．1ength；++i)
    if(adr[i]!=i)j
    j=i；  L．r[O]=L．r[i]；    ∥暂存记录L．r[i]
    while(adr[j]I_i){    ∥调整L．r[adr[j]]的记录到位直到adr[j]=i为止
    k=adr[j]；L．r[j]=L．r[k]；
    adr【j J=j；  j=k；
    }
    adr[j]：L．r[O]；adr[j]=j；  ∥记录按序到位
    I
}∥Rearrange
    算法10．18
    从上述算法容易看出，除了在每个小循环中要暂存一次记录外，所有记录均一次移动到位。而每个小循环至少移动两个记录，则这样的小循环至多有L n／2 j个，所以重排记录的算法中至多移动记录L 3，z／2 j次。
    本节最后要讨论的一个问题是，“内部排序可能达到的最快速度是什么”。我们已经看到，本章讨论的各种排序方法，其最坏情况下的时间复杂度或为0(”。)，或为0(nlogn)，其中0(n0)是它的上界，那末O(扎logn)是否是它的下界，也就是说，能否找到一种排序方法，它在最坏情况下的时间复杂度低于O(nlogn)呢?
    由于本章讨论的各种排序方法，除基数排序之外，都是基于“关键字间的比较”这个操作进行的，则均可用一棵类似于图10．16所示的判定树来描述这类排序方法的过程。
⑥    ⑤
    图10．16
    ⑧    ②
描述排序过程的判定树
    图10．16的判定树表示三个关键字分别为Kl、K2和K。的记录进行直接插入排序的过程，树中每个非终端结点表示两个关键字间的一次比较，其左、右子树分别表示这次比较所得的两种结果。假设K1≠K2≠K3≠K1，则排序之前依次排列的这三个记录{R1，R2，R 3}之间只可能有下列六种关系：(1)Kl<K2<K3；(2)Kl<K3<K2；(3)K3
<K1<K2；(4)K2<K1<K3；(5)K2<K3<K1；(6)K3<K2<K1，换句话说，这三个记录经过排序只可能得到下列六种结果：(1){R1，R2，R3 l；(2){Rl，R3，R2}；(3){R3，R1’_R2}；(4){R2，R1，R3}；(5){R2，R3，R1}；(6){R 3，R2，R1}，而图10．16中的判定树
    ・  291  ・
上六个终端结点恰好表示这六种排序结果。判定树上进行的每一次比较都是必要的，因此，这个判定树足以描述通过“比较”进行的排序过程。并且，对每一个初始序列经排序达到有序所需进行的“比较”次数，恰为从树根到和该序列相应的叶子结点的路径长度。由于图10．16的判定树的深度为4，则对3个记录进行排序至少要进行3次比较。--
    推广至一般情况，对。个记录进行排序至少需进行多少次关键字间的比较，这个问题等价于，给定竹个不同的砝码和一台天平，按重量的大小顺序排列这些砝码所需要的最少称重量次数问题。由于含n个记录的序列可能出现的初始状态有n!个，则描述n个记录排序过程的判定树必须有n!个叶子结点。因为，若少一个叶子，则说明尚有两种状态没有分辨出来。我们已经知道，若y．树的高度为h，则叶子结点的个数不超过2；反之，若有n个叶子结点，则二叉树的高度至少为厂log2“]十1。这就是说，描述。个记录排序的判定树上必定存在一条长度为广log2(n!)]的路径。由此得到下述结论：任何一个借助“比较”进行排序的算法，在最坏情况下所需进行的比较次数至少为。然而，这只是一个理论上的下界，一般的排序算法在n>4时所需进行的比较次数均大于此值，直到1956年，H．B．Demuth首先找到了对五个数进行排序只需要七次比较的方法‘。’之后，Lester Ford和Selmer Johnson将其推广，提出了归并插入①(Merge Insertion)排序，在竹<11时所用的比较次数和厂log2(竹!)]相同。②。根据斯特林公式，有厂log2(，z!)]=O(nlogn)，上述结论从数量级上告诉我们，借助于“比较”进行排序的算法在最坏情况下能达到的最好的时间复杂度为0(nlogn)。①  归并插入排序的过程请参见(题集)第10章中最后一题。
②下表中B(n)、M(n)和F(”)分别表示对n个数进行折半插入排序、归并排序和归并插入排序时在最坏情况下所需进行的比较次数‘。’