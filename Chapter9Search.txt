
第9章查    找
    本书在第2章至第7章中已经介绍了各种线性或非线性的数据结构，在这一章将讨论另一种在实际应用中大量使用的数据结构――查找表。
　　查找表(Search Table)  是由同一类型的数据元素(或记录)构成的集合。由于“集合”中的数据元素之间存在着完全松散的关系，因此查找表是一种非常灵便的数据结构。
　　对查找表经常进行的操作有：(1)查询某个“特定的”数据元素是否在查找表中；(2)检索某个“特定的”数据元素的各种属性；(3)在查找表中插入一个数据元素；(4)从查找表中删去某个数据元素。若对查找表只作前两种统称为“查找”的操作，则称此类查找表为静态查找表(static Search Table)。若在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已存在的某个数据元素，则称此类表为动态查找表(【)ynamic：SearchTable)。
    在日常生活中，人们几乎每天都要进行“查找”工作。例如，在电话号码簿中查阅“某单位”或“某人”的电话号码；在字典中查阅“某个词”的读音和含义等等。其中“电话号码簿”和“字典”都可视作是一张查找表。
    在各种系统软件或应用软件中，查找表也是一种最常见的结构之一。如编译程序中符号表、信息处理系统中信息表等等。
    由上述可见，所谓”查找”即为在一个含有众多的数据元素(或记录)的查找表中找出某个“特定的”数据元素(或记录)。
    为了便于讨论，必须给出这个“特定的”词的确切含义。首先需引入一个“关键字”的概念。
    关键字(Key)是数据元素(或记录)中某个数据项的值，用它可以标识(识别)一个数据元素(或记录)。若此关键字可以唯一地标识一个记录，则称此关键字为主关键字(Primarly Key)(对不同的记录，其主关键字均不同)。反之，称用以识别若干记录的关键字为次关键字(Seeondary：Key)。当数据元素只有一个数据项时，其关键字即为该数据元素的值。
    查找(Searching)  根据给定的某个值，在查找表中确定一个其关键字等于给定值的记录或数据元素。若表中存在这样的一个记录，则称查找是成功的，此时查找的结果为给出整个记录的信息，或指示该记录在查找表中的位置；若表中不存在关键字等于给定值的记录，则称查找不成功，此时查找的结果可给出一个“空”记录或“空”指针。
    例如，当用计算机处理大学入学考试成绩时，全部考生的成绩可以用图9．1所示表的结构储存在计算机中，表中每一行为一个记录，考生的准考证号为记录的关键字。假设给定值为179326，则通过查找可得考生陆华的各科成绩和总分，此时查找为成功的。若给定值为179238，则由于表中没有关键字为179238的记录，则查找不成功。
    如何进行查找?显然，在一个结构中查找某个数据元素的过程依赖于这个数据元素在结构中所处的地位。因此，对表进行查找的方法取决于表中数据元素依何种关系(这个关系是人为地加上的)组织在一起的。例如查电话号码时，由于电话号码簿是按用户(集体或个人)的名称(或姓名)分类且依笔划顺序编排，则查找的方法就是先顺序查找待查用户的所属类别，然后在此类中顺序查找，直到找到该用户的电话号码为止。又如，查阅英文单词时，由于字典是按单词的字母在字母表中的次序编排的，因此查找时不需要从字典中第一个单词比较起，而只要根据待查单词中每个字母在字母表中的位置查到该单词。
图9．1高考成绩表示例
    同样，在计算机中进行查找的方法也随数据结构不同而不同。正如前所述，本章讨论的查找表是一种非常灵便的数据结构。但也正是由于表中数据元素之间仅存在着“同属一个集合”的松散关系，给查找带来不便。为此，需在数据元素之间人为地加上一些关系，以便按某种规则进行查找，即以另一种数据结构来表示查找表。本章将分别就静态查找表和动态查找表两种抽象数据类型讨论其表示和操作实现的方法。
　　在本章以后备节的讨论中，涉及的关键字类型和数据元素类型统一说明如下：
　　    典型的关键字类型说明可以是
    数据元素类型定义为：
    ∥实型
∥整型
∥字符串型
∥关键字域
∥其它域
    fElemType；
对两个关键字的比较约定为如下的宏定义
  ∥--对数值型关键字
  #define EQ(a，b)  ((a)==(b))
  #define LT(a，b)((a)<  (b))
  #i∞LQ(a，b)((a)<=(b))
  ∥对字符串型关键字
  #define EQ(a，b)(!strcmp((a)，(b)))
  #define LT(a，b)(strcmp((a)，(b))<0)
  #define LQ(a，b)(strcmp((a)，(b))<=0)
・215  ・
9．1静态查找表
抽象数据类型静态查找表的定义为：
  ADT StaticSearchTable{
    数据对象D：D是具有相同特性的数据元素的集合。各个数据元素均含有类型相同，可唯一标识    数据元素的关键字。    数据关系R：数据元素同属一个集合。
    基本操作P：
    Create(&ST，n)；
    操作结果：构造一个含n个数据元素的静态查找表sT。
    Dest：roy(＆sT)；
    初始条件：静态查找表sT存在。
    操作结果：销毁表ST。
    Search(sT，key)；
    初始条件：静态查找表sT存在，key为和关键字类型相同的给定值。
    操作结果：若sT中存在其关键字等于key的数据元素，则函数值为该元素的值或在表中的
    位置，否则为“空”。
    ’traverse(sT，Visit())；
    初始条件：静态查找表钉存在，visit是对元素操作的应用函数。
    操作结果：按某种次序对sT的每个元素调用函数visit()一次且仅一次。一旦visit()失    败，则操作失败。
    }ADT StaticSearchTable
    静态查找表可以有不同的表示方法，在不同的表示方法中，实现查找操作的方法也不同。
  9．1．1顺序表的查找
  以顺序表或线性链表表示静态查找表，则searc’I、函数可用顺序查找来实现。本节中只讨论它在顺序存储结构模块中的实现，在线性链表模块中实现的情况留给读者去完成。    ∥----一静态查找表的顺序存储结构----一
    ’typedef struct{
    ElemType*el鲫；    ∥数据元素存储空间基址，建表时按实际长度分配，0号单元留空
    int    length；  ∥表长度
    }sSTable；
    下面讨论顺序查找的实现。
    顺序查找(Sequential Search)的查找过程为：从表中最后一个记录开始，逐个进行记录的关键字和给定值的比较，若某个记录的关键字和给定值比较相等，则查找成功，找到所查记录；反之，若直至第一个记录，其关键字和给定值比较都不等，则表明表中没有所查记录，查找不成功。此查找过程可用算法9．1描述之。    
int Search―seq(SSTable sT，Ke!／Type key){
  ∥在顺序表ST中顺序查找其关键字等于key的数据元素。若找到，则函数值为
  ∥该元素在表中的位置，否则为0。
  ST．elem[0]．key=key；
・216・
∥“哨兵”
  for(i=sT．1ength；!EQ(sT．elem[i]．key，key)；  i)；∥从后往前找  refur,l i：    ∥找不到时，i为0
＼I|Search―Seq
    算法9．1
    这个算法的思想和第2章中的函数LocateElbm Sq一致。只是在Search―Seq中，查找之前先对sT．elem[0]的关键字赋值key，目的在于免去查找过程中每一步都要检测整个表是否查找完毕。在此，ST．elem[0]起到了监视哨的作用。这仅是一个程序设计技巧上的改进，然而实践证明，这个改进能使顺序查找在ST．1ength≥1000时，进行一次查找所需的平均时间几乎减少一半，(参阅参考书目[1]中342页表7．1)。当然，监视哨也可设在高下标处。
    查找操作的性能分析
    在第1章中曾提及，衡量一个算法好坏的量度有三条：时间复杂度(衡量算法执行的时间量级)、空间复杂度(衡量算法的数据结构所占存储以及大量的附加存储)、和算法的其它性能。对于查找算法来说，通常只需要一个或几个辅助空间。又，查找算法中的基本操作是“将记录的关键字和给定值进行比较”，因此，通常以“其关键字和给定值进行过比较的记录个数的平均值”作为衡量查找算法好坏的依据。
    定义：为确定记录在查找表中的位置，需和给定值进行比较的关键字个数的期望值称为查找算法在查找成功时的平均查找长度(．Average Search Length)。
　　对于含有n个记录的表，查找成功时的平均查找长度为其中：Pi为查找表中第i个记录的概率，且∑Pi=1；
　　ci为找到表中其关键字与给定值相等的第i个记录时，和给定值已进行过比较的关键字个数。显然，Ci随查找过程不同而不同。
    从顺序查找的过程可见，ci取决于所查记录在表中的位置。如：查找表中最后一个记录时，仅需比较一次；而查找表中第一个记录时，则需比较n次。一般情况下Ci等于ni+1。
    假设=sT．1ength，则顺序查找的平均查找长度为1+P。    (9
    假设每个记录的查找概率相等，即
则在等概率情况下顺序查找的平均查找长度为
    有叫，表p各个记录的查找概率并不棚等。例如：将全校学生的在计算机中，则体弱多的病历记录的查哉概率必定离于健埭同学的病历记录。
  [h r式(9．2)中的AsL在j，。≥，’一l≥≥P!≥P1时达到极小值。因此，对融采fI{J代找  概率不等的查找表若能预先得知每个记录的查找概率，则应先列}己录的查找概率进行排  序，使表中记录按查找概率由小至大重新排列，以便提高查找效率。
    然而，在一般情况下，}己录的查找慨率预先无法测定。为了提高查找效宰，我们可以在每个记求小附|殳一个访问频度域，并使顺序表中曲记录始终保持按漪问频度非递减有  序的次序排列，使得查找概率大的记录在查找过程中不断往后移，吼便在“后的逐次查找小减少比较次数。或者在每次查找之后都将刚查找到的记录直接移至表尾。
    顺序查找和我们后Jn】将要刊论到的其它查找算法相比，』t缺点足平均查找长度较大，  特{=}Il是当”很大时，查找效率较低。然而，它有很大的优点是：算法简单目适应面广。它对表的结构无任何要求，无沦记录是否按关键宁有序‘。’均可麻用，而‰L述所有训论对线性：链表电同样适用。
    容易看出，上述对平均查找艮赏的刊沦足在∑P．=I的前挺下进行的，换句活说，我们认为每次拇找都灶“成功”的。在本章开始时曾提到，查找可能产生“成功”与“不成功  两利-结果，但柱实际应川的大多数情况下，查找成功的0lJ能性：比不成功的可能性大得多，’特别足在表t”记录数”很大时．查找不成功的概率可眦忽略不计。!_谯找4；成功的情形步缩小范围直到找到或找不到该记录为止。
    例如：已知如下11个数据元素的有序表(关键字即为数据元素的值)：    (05，13，19，21，37，56，64，75，80，88，92)
现要查找关键字为21和85的数据元素。
    假设指针lo训和high分别指示待查元素所在范围的下界和上界，指针mid指示区间的中间位置，即mid=L(10叫+high)／2 J。在此例中，low和high的初值分别为1
和11，即[1，11]为待查范围。
    下面先看给定值key=21的查找过程：
    05  13  19 21  37  56 64  75 80 88 92
    首先令查找范围中间位置的数据元素的关键字ST。elem[mid]．key与给定值key相比较，因为sT．elem[mid]．key>key，说明待查元素若存在，必在区间[10W，mid-1]的范围内，则令指针high指向第mid-1个元素，重新求得mid=l(1+5)／2 j=3仍以ST．elem[mid]．key和key相比，因为ST．elem[mid]．key<key，说明待查元素若存在，必在[mid十1，high]范围内，则令指针low指向第mid+1个元素，求得mid的新值为4，比较ST．elem[mid]．key和key，因为相等，则查找成功，所查元素在表中序号等于指针mid的值。
  此时因为下界low>上界high，则说明表中没有关键字等于key的元素，查找不成功。
    从上述例子可见，折半查找过程是以处于区间中间位置记录的关键字和给定值比较,若相等，则查找成功，若不等，~INd,NN，直至新的区间中间位置记录的关键字等于给定值或者查找区间的大小小于零时(表明查找不成功)为止。
    上述折半查找过程如算法9．2描述所示。
・219  ・
int Search―Bin(SSTab]．e sT，KeyType key)j
  ∥在有序表sT中折半查找其关键字等于key的数据元素。若找到，则函数值为
  ∥该元素在表中的位置，否则为0。
  low：1；hiqh=sT．1ength；    ∥置区间初值
  while(1。w<=high){
    mid=(10w+high)／2；
    if EQ(key，sT．elem[mid]．key)  return mid；    ∥找到待查元素
    elge if LT(key，sT．elem[mid]．key)  high=mid-1；  ∥继续在前半区间进行查找
    eIse 10w=mid+1；    ∥继续在后半区间进行查找
  }
  ：。turf。0：    ∥顺序表中不存在待查元素
}∥SearchBin
    算法9．2
  折半查找的性能分析
  先看上述11个元素的表的具体例子。从上述查找过程可知：
  找到第⑥个元素仅需比较1次；找到第③和第⑨个元素需比较2次；找到第①、④、⑦和⑩个元素需比较3次；找到第②、⑤、⑧和⑩个元素需比较4次。
    这个查找过程可用图9．2所示的二叉树来描述。树中每个结点表示表中一个记录，结点中的值为该记录在表中的位置，通常称这个描述查找过程的二叉树为判定树，从判定树上可见，查找21的过程恰好是走了一条从根到结点④的路径，和给定值进行比较的关键字个数为该路径上的结点数或结点④在判定树上的层次数。类似地，找到有序表中任一记录的过程就是走了一条从根结点到与该记录相应的结点的路径，和给定值进行比较的关键字个数恰为该结点在判定树上的层次数。因此，折半查找法在查找成功时进行比较的关键字个数最多不超过树的深度，而具有”个结点的判定树的深度为L lo＆n j+1①，所以，折半查找法在查找成功时和给定值进行比较的关键字个数至多为L|og2nj+1。
图9．2描述折半查找过程的判定树及查找21的过程
    如果在图9．2所示判定树中所有结点的空指针域上加一个指向一个方形结点的指针，图9．3所示。并且，称这些方形结点为判定树的外部结点(与之相对，称那些圆形结点为内部结点)，那末折半查找时查找不成功的过程就是走了一条从根结点到外部结点的路径，和给定值进行比较的关键字个数等于该路径上内部结点个数，例如：查找85的过程即为走了一条从根到结点19―10I的路径。因此，折半查找在查找不成功时和给定值进行比较的关键字个数最多也不超过L log2j+1。
  那末，折半查找的平均查找长度是多少呢?
① 判定树非完全二叉树，但它的叶子结点所在层次之差最多为1，则n个结点的判定树的深度和n个结点的完全：叉树的深度相同。
②   图9．3  加上外部结点的判定树和查找85的过程
  为讨论方便起见，假定有序表的长度”=2‘1(反之，^=log2(n+1))，则描述折半查找的判定树是深度为h的满二叉树。树中层次为1的结点有1个，层次为2的结点有2个，…，层次为^的结点有2“一。个。假设表中每个记录的查找概率相等(只。专)，则查找成功时折半查找的平均查找长度对任意的”，当”较大(n>50)时，可有下列近似结果可见，折半查找的效率比顺序查找高，但折半查找只能适用于有序表，且限于顺序存储结构(对线性链表无法进行折半查找)。
    以有序表表示静态查找表时，进行查找的方法除折半查找之外，还有斐波那契查找和插值查找。
    斐波那契查找是根据斐波那契序列②的特点对表进行分割的。假设开始时表中记录个数比某个斐波那契数小1，即”：F。-1，然后将给定值key和ST．elem[F。。]．key进行比较，若相等，则查找成功；若key<ST．elem[F。-1]．key，则继续在自ST．elem[1]至sT．elem[F1]的子表中进行查找，否则继续在自ST．elem[F。1+1]至ST．elem[Fu1]的子表中进行查找后一子表的长度为F。一2―1。斐波那契查找的平均性能比折半查找好，但最坏情况下的性能(虽然仍是0(10gn))却比折半查找差。它还有一个优点就是分割时只需进行加、减运算。
    插值查找是根据给定值key来确定进行比较的关键字ST．elem[i]_key的查找方法。令i=雨意e[yh-篙寒热黠嚼(h-l+1)，其中sT．elem[1]和sT．elem[h]分别为有序表中具有最小关键字和最大关键字的记录。显然，这种插值查找只适于关键字均匀分布的表，在这种情况下，对表长较大的顺序表，其平均性能比折半查找好。
9．1．3静态树表的查找
    J、节对有序表的查找性能的讨论是在“等概率”的前提下进行的，即当有序表中各记录的查找概率相等时，按图9．2所示判定树描述的查找过程来进行折半查找，其性能最优。如果有序表中各记录的查找概率不等，情况又如何呢?
    先看一个具体例子。假设有序表中含5个记录，并且已知各记录的查找概率不等，分别为pl=0．1，户2=0．2，户3=0．1，户4：0．4和p5=0．2。则按式(91)的定义，对此有序表进行折半查找，查找成功时的平均查找长度为    5
    ∑Pi(-?：=0．1×2+0．2×3+0．1×1+0．4×2+0．2×3=2．3
    j=l
但是，如果在查找时令给定值先和第4个记录的关键字进行比较，比较不相等时再继续在左子序列或右子序列中进行折半查找，则查找成功时的平均查找长度为
这就说明，当有序表中各记录的查找概率不等时，按图9．2所示判定树进行折半查找，其性能未必是最优的。那末此时应如何进行查找呢?换句话说，描述查找过程的判定树为何类二叉树时，其查找性能最佳?
    如果只考虑查找成功的情况，则使查找性能达最佳的判定树是其带权内路径长度
之和PH值①
    三
取最小值的二叉树。其中：n为二叉树上结点的个数(即有序表的长度)；^i为第i个结点在二叉树上的层次数；结点的权咖i=印。(i=1，2，…，n)，其中A为结点的查找概率，c为某个常量。称PH值取最小的二叉树为静态最优查找树(Static Optimal Search Tree)。由于构造静态最优查找树花费的时间代价较高，因此在本书中不作详细讨论，有兴趣的读者可查阅参考书目[1]。在此向读者介绍一种构造近似最优查找树的有效算法。
    已知一个按关键字有序的记录序列
    (r，，rf+1，…，r^)    (9．8)
其中    。l_key<n1．key<…<‘h．key
与每个记录相应的权值为
现构造一棵二叉树，使这棵二叉树的带权内路径长度PH值在所有具有同样权值的二叉树中近似为最小，称这类二叉树为次优查找树(Nearly Optimal Search Tree)。
①PH值和平均查找长度成正比。
    构造次优查找树的方法是：首先在式(9―8)所示的记录序列中取第i(z≤i≤h)个记录构造根结点⑤，使得△Pi=(9．10)
取最小值(△Pf。㈥M、in。t,SPi t)，然后分别对子序列{m n+∥，1}和{ri+l,…，r^}构造两棵次优查找树，并分别设为根结点⑤的左子树和右子树。
    为便于计算△P，引入累计权值和
由此可得构造次优查找树的递归算法如算法9．3所示。
(9-11)
(9．12)
(9．13)
Status SecondOptimal(BiTree&T，Elee R【]，float SW[]，int low，int high){
  ∥由有序表R[10w．．high]及其累计权值表sw(其中sw[0]==O)递归构造次优查找树T。
  i=low；min=abs(sw[high]．SW[10w])；dw=sw[high]+SW[10w-i]；
  for(J=low+1；j<：high；++j)    ∥选择最小的△Pi值
    }
  if(!(T=(BiTree)mall~(size(BiTNode))))return ERROR；
  T->data=R[i]；    ／／生成结点
=NULL；    ∥左子树空
  else SecondOptimal(T>ichild，R，sw，low，i1)；  ／／构造左子树
  if(i==high)T>rchild=NULL；    ∥右子树空
  'else SecondOptimal(T>rchild，R，sw，i+1，high)；∥构造右子树
  return OK；
}／／SecondOptimal
    算法9．3
例9-1  已知含9个关键字的有序表及其相应权值为
    关键字  A  B  C D  E  F  G H  I
    权值  1  1  2  5  3 4 4  3  5
则按算法9．3构造次优查找树的过程中累计权值SW和△P的值如图9．4(a)所示，构造所得次优二叉查找树如图9．4(b)所示。
    图9．4构造次优二叉查找树示例
    (a)累计权值和及△P值；  (b)次优查找树。
    由于在构造次优查找树的过程中，没有考察单个关键字的相应权值，则有可能出现被选为根的关键字的权值比与它相邻的关键字的权值小。此时应作适当调整：选取邻近的权值较大的关键字作次优查找树的根结点。
    例9．2已知含5个关键字的有序表及其相应权值为
    关键字  A  B    C D  E
    权值    1    30    2    29    3
则按算法9．3构造所得次优查找树如图9．5(a)所示，调整处理后的次优查找树如图9．5(b)所示。容易算得，前者的PH值为132，后者的PH值为105。
    大量的实验研究表明，次优查找树和最优查找树的查找性能之差仅为1％～2％，很少超过3％，而且构造次优查找树的算法的时间复杂度为0(nlogn)，因此算法9．3是构造近似最优二叉查找树的有效算法。
图9．5根的权小于子树根权的情况
    (a)调整之前的次优查找树；
    (b)调整之后的次优查找树。
    从次优查找树的结构特点可见，其查找过程类似于折半查找。若次优查找树为空，则查找不成功，否则，首先将给定值key和其根结点的关键字相比，若相等，则查找成功，该根结点的记录即为所求；否则将根据给定值key小于或大于根结点的关键字而分别在左子树或右子树中继续查找直至查找成功或不成功为止(算法描述和下节讨论的二叉排序树的查找算法类似，在此省略)。由于查找过程恰是走了一条从根到待查记录所在结点(或叶子结点)的一条路径，进行过比较的关键字个数不超过树的深度，因此，次优查找树的平均查找长度和logn成正比。可见，在记录的查找概率不等时，可用次优查找树表示静态查找树，故又称静态树表，按有序表构造次优查找树的算法如算法9．4所示。
typ．d．f BiTree SOSTz'ee；    ∥次优查找树采用二叉链表的存储结构
stltu8 CreateSOSTree(SOSTree＆T，SSTable ST){
    ∥由有序表sT构造一棵次优查找树T。sT的数据元素含有权域weight~。
    if(sT．1ength==0)T=B-GLL；
    el∞{
    FindSW(sw，ST)；    ∥按照由有序表ST中各数据元素的weight域求累计权值表sW。    SecondOpiamal(T，sT．elem，sw，1，sT．1ength)；
    }
    return OK；
    }∥CreateSOSTree
    算法9．4
9．1．4索引顺序表的查找
    若以索引顺序表表示静态查找表，则Search函数可用分块查找来实现。
    分块查找又称索引顺序查找，这是顺序查找的一种改进方法。在此查找法中，除表本身以外，尚需建立一个“索引表”。例如，图9．6所示为一个表及其索引表，表中含有18个索引表
图9．6表及其索引表
记录，可分成三个子表(R1，R2，…，6)、(R7，R8，…，R12)、(R13，R14，…R18)，对每个子
表(或称块)建立一个索引项，其中包括两项内容：关键字项(其值为该子表内的最大关键字)和指针项(指示该子表的第一个记录在表中位置)。索引表按关键字有序，则表或者有序或者分块有序。所谓“分块有序”指的是第二个子表中所有记录的关键字均大于第一个子表中的最大关键字，第三个子表中的所有关键字均大于第二个子表中的最大关键字，……，依次类推。
　　因此，分块查找过程需分两步进行。先确定待查记录所在的块(子表)，然后在块中顺序查找。假设给定值忌倒=38，则先将key・依次和索引表中各最大关键字进行比较，因为22<key<48，则关键字为38的记录若存在，必定在第二个子表中，由于同一索引项中的指针指示第二个子表中的第一个记录是表中第7个记录，则自第7个记录起进行顺序查找，直到ST．elem[10]．key=key为止。假如此子表中没有关键字等于是纠的记录(例如：key。29时自第7个记录起至第12个记录的关键字和key比较都不等)，则查找不成功。
　　由于由索引项组成的索引表按关键字有序，则确定块的查找可以用顺序查找，亦可用折半查找，而块中记录是任意排列的，则在块中只能是顺序查找。
　　由此，分块查找的算法即为这两种查找算法的简单合成。
分块查找的平均查找长度为    、
其中：k为查找索引表确定所在块的平均查找长度，L。为在块中查找元素的平均查找长度。
    一般情况下，为进行分块查找，可以将长度为n的表均匀地分成6块，每块含有s个记录，即6=n／s]；又假定表中每个记录的查找概率相等，则每块查找的概率为1／6，块中每个记录的查找概率为1／s。    若用顺序查找确定所在块，则分块查找的平均查找长度为可见，此时的平均查找长度不仅和表长竹有关，而且和每一块中的记录个数s有关。在给定孢的前提下，s是可以选择的。容易证明，当s取石时，ASLb；取最小值而十1。这个值比顺序查找有了很大改进，但远不及折半查找。
    若用折半查找确定所在块，则分块查找的平均查找长度为
9．2动态查找表
    在这一节和下一节中，我们将讨论动态查找表的表示和实现。动态查找表的特点是，表结构本身是在查找过程中动态生成的，即对于给定值key，若表中存在其关键字等于key的记录，则查找成功返回，否则插入关键字等于ke5r的记录。以下是动态查找表的定义：
抽象数据类型动态查找表的定义如下：    
  数据对象D：D是具有相同特性的数据元素的集合。各个数据元素均含有类型相同，可唯一标识
    数据元素的关键字。
  数据关系R：数据元素同属一个集合。
  基本操作P：
    InitDSTable(&DT)；
    操作结果：构造一个空的动态查找表DT。
    DestroyDSTable(＆)；
    初始条件：动态查找表v存在。
    操作结果：销毁动态查找表DT。
    SearchDSTable(，key)；
・226・
    初始条件：动态查找表v存在，key为和关键字类型相同的给定值。
    操作结果：若册中存在其关键字等于key的数据元素，则函数值为该元素的值或在表中的位置，否则为“空”。
    InsertDSTable(&DT，e)；
    初始条件：动态查找表crr存在，e为待插入的数据元素。
    操作结果：若DT中不存在其关键字等于e．key的数据元素，则插入e到DTa    DeleteDSTable(&nT，key)；    ．  ．
　　初始条件：动态查找表DT存在，key为和关键字类型相同的给定值。
　　操作结果：若DT中存在其关键字等于key的数据元素，则删除之。
    TraverseDSTable(叩，vis北())；
    初始条件：动态查找表DT存在，visit是对结点操作的应用函数。
    操作结果：按某种次序对DT的每个结点调用函数visit()一次且至多一次。一旦Visit()失败，则操作失败。
    }ADT DynamicSearchTabl e
    动态查找表亦可有不同的表示方法。在本节中将讨论以各种树结构表示时的实现方法。
9．2．1二叉排序树和平衡二叉树
  一、二叉排序树及其查找过程
  什么是二叉排序树?
  二叉排序树(Binary Sort Tree)或者是一棵空树；或者是具有下列性质的二叉树：(1)若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；(2)若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；(3)它的左、右子树也分别为二叉排序树。
    例如图9．7所示为两棵二叉排序树。
　　图9．7二叉排序树
 二叉排序树又称二叉查找树，根据上述定义的结构特点可见，它的查找过程和次优二叉树类似。即当二叉排序树不空时，首先将给定值和根结点的关键字比较，若相等，则查找成功，否则将依据给定值和根结点的关键字之间的大小关系，分别在左子树或右子树上继续进行查找。通常，可取二叉链表作为二叉排序树的存储结构，则上述查找过程如算法9．5(a)所描述。   
  ∥在根指针T所指二叉排序树中递归地查找某关键字等于key的数据元素，
  ∥若查找成功，则返回指向该数据元素结点的指针，否则返回空指针
  if((!T)II EQ(key，T->data．key))return(T)；    ∥查找结束
  else if LT(key。T>data．key)return(SearchBST(T>ichild，key))；
    ∥在左子树中继续查找
  else return(SearchBST(T>rchild，key))；    ∥在右子树中继续查找
}∥SearchBST
    算法9．5【a)
    例如：在图9．7(a)所示的二叉排序树中查找关键字等于100的记录(树中结点内的数均为记录的关键字)。首先以key=(100)和根结点的关键字作比较，因为key>45，则查找以@为根的右子树，此时右子树不空，且key>53，则继续查找以结点@为根的右子树，由于key和⑦的右手树根的关键字100相等，则查找成功，返回指向结点⑩的指针值。
又如在图9．7(a)中查找关键字等于40的记录，和上述过程类似，在给定值key与关键字45、12及37相继比较之后，继续查找以结点⑤为根的右子树，此时右子树为空，则说明该树中没有待查记录，故查找不成功，返回指针值为“NULL”。
    二、二叉排序树的插入和删除
    和次优二叉树相对，二叉排序树是一种动态树表。其特点是，树的结构通常不是一次生成的，而是在查找过程中，当树中不存在关键字等于给定值的结点时再进行插入。新插入的结点一定是一个新添加的叶子结点，并且是查找不成功时查找路径上访问的最后一个结点的左孩子或右孩子结点。为此，需将上一小节的二叉排序树的查找算法改写成算法9．5(b)，以便能在查找不成功时返回插入位置。插入算法如算法9．6所示。
Status SearchBST(BiTree T，Ke~ype key，BiTree f，BiTree&p){
  ∥在根指针T所指二叉排序树中递归地查找其关键字等于key的数据元素，若查找成功。
  ∥则指针P指向该数据元素结点，并返回TRUE，否则指针P指向查找路径上访问的
  ∥最后一个结点并返回FALSE，指针f指向T的双亲，其初始调用值为NULL
  if(!T){P=f；zetura FALSE；I    ∥查找不成功
  else if EQ(key，T>data．key)I P=T；return TRUE；}    ∥查找成功
  else if LT(key，T>data．key)SearchBST(T>ichild，key，T，p)；  ∥在左子树中继续查找
  else SearchBST(T>rchild，key，T，p)；    ∥在右子树中继续查找
}∥SearchBST
    算法9。5(b)
Status Insert BST(BiTree＆T，ElemType e){
  ∥当二叉排序树T中不存在关键字等于e．key的数据元素时，插入e并返回TRUE，
  ∥否则返回FALSE
  if(!Searc~T(T，e．key，NULL，P){    ∥查找不成功
    8=(BiTree)mall~(sizeof(BiTNode))；
    s>data=e；S>ichild=s>rchild=NULL；
    if(!P)T=S；    ∥被插结点*S为新的根结点
    else if LT(e．key，P>data．key)P>Ichild=S；∥被插结点*s为左孩子
    eln P>rchild=S；    ∥被插结点*S为右孩子
    return TRUE；
・228・
  I
  else retura FAsE；    ∥树中已有关键字相同的结点，不再插入
I   算法9．6
    若从空树出发，经过一系列的查找插入操作之后，可生成一棵二叉树。设查找的关键字序列为{45。24，53，45，12，24。90}，则生成的二叉排序树如图9．8所示。
(a)
    图9．8二叉排序树的构造过程
    (a)空树；(b)插入45；(c)插入24；(d)插入53；(e)插入12；(f)插入90。
    容易看出，中序遍历二叉排序树可得到一个关键字的有序序列(这个性质是由二叉排序树的定义决定的，读者可以自己证明之)。这就是说，一个无序序列可以通过构造一棵二叉排序树而变成一个有序序列，构造树的过程即为对无序序列进行排序的过程。不仅如此，从上面的插入过程还可以看到，每次插入的新结点都是二叉排序树上新的叶子结点，则在进行插入操作时，不必移动其它结点，仅需改动某个结点的指针，由空变为非空即可。这就相当于在一个有序序列上插入一个记录而不需要移动其它记录。它表明，二叉排序树既拥有类似于折半查找的特性，又采用了链表作存储结构，因此是动态查找表的一种适宜表示。
    同样，在二叉排序树上删去一个结点也很方便。对于一般的二叉树来说，删去树中一个结点是没有意义的。因为它将使以被删结点为根的子树成为森林，破坏了整棵树的结构。然而，对于二叉排序树，删去树上一个结点相当于删去有序序列中的一个记录，只要在删除某个结点之后依旧保持二叉排序树的特性即可。
    那末，如何在二叉排序树上删去一个结点呢?假设在二叉排序树上被删结点为*p①(指向结点的指针为p)，其双亲结点为*f(结点指针为f)，且不失一般性，可设*p是*f的左孩子(图9．9(a)所示)。
  下面分三种情况进行讨论：
  (1)若*p结点为叶子结点，即PL和PR均为空树。由于删去叶子结点不破坏整棵树的结构，则只需修改其双亲结点的指针即可。   
①  以下均简称指针p(或f等)所指结点为*p(或*f等)结点，PL和PR分别表示其左子树和右子树。
    (2)若*P结点只有左子树PI，或者只有右子树PR，此时只要令P。或P。直接成为其双亲结点*f的左子树即可。显然，作此修改也不破坏二叉排序树的特性。
    (3)若*P结点的左子树和右子树均不空。显然，此时不能如上简单处理。从图9．9(b)可知，在删去*P结点之前，中序遍历该二叉树得到的序列为{．．・Cl，C…QLQSI，SPPRF…}，在删去*P之后，为保持其它元素之间的相对位置不变，可以有两种做法：其一是令*p的左子树为*f的左子树，而*p的右子树为*s的右子树，如图9．9(C)所示；其二是令*P的直接前驱(或直接后继)替代*P，然后再从二叉排序树中删去它的直接前驱(或直接后继)。如图9．9(d)所示，当以直接前驱*S替代*P时，由于*S只有左子树SI．，则在删去*s之后，只要令SI，为*S的双亲*q的右子树即可。
    图9．9在二叉排序树中删除*P
(a)以*f为根的子树；(b)删除*p之前；(c)删除*P之后，以P。作为*s的右子树的情形
(d)删除*P之后，以*s替代*P的情形。
    在二叉排序树上删除一个结点的算法如算法9．7所示，其中由前述三种情况综合所得的删除操作如算法9．8所示。
Status DeleteBST(BiTree＆T，  KeyType key){
  ／／若二叉排序树T中存在关键字等于key的数据元素时，则删除该数据元素结点，  ∥并返回TRUE；否则返回FALSE
if(!T)return FALSE；
else{
∥不存在关键字等于key的数据元素
  if EQ(key，T>data．key)Delete(T)；    ∥找到关键字等于key的数据元素
  e15e if LT(key，T>data．key)DeleteBST(T>ichild，key)；
  else DeleteBST(T>rchild，key)；
  return TRUE；
  }
＼}f DeleteBST
    算法9．7
其中删除操作过程如算法9．8所描述
void Delete(BiTree＆p){
  ∥从二叉排序树中删除结点P，并重接它的左或右子树
  J．f(!P>rchild)f  ∥右子树空则只需重接它的左子树
    q。p；P：P>ichild；free(q)；
・230・
}
el舱if(!P>ichild){  ∥只需重接它的右子树
  q=P；P=P>rchild；free(q)；
 else{  ∥左右子树均不空
    q：p；  s=P>ichild；
    while(S>rchild){q：s；s：s>rchild}  ∥转左，然后向右到尽头
    P>data：s>data；    ∥s指向被删结点的“前驱”
    if(q!=P)q->rchild：S>ichild；    ∥重接*q的右子树
    elu q>ichild=S>Ichild；    ∥重接。q的左子树
  }
＼}f Delete
    算法9．8
    三、二叉排序树的查找分析
    从前述的两个查找例子(key=100和key：40)可见，在二叉排序树上查找其关键字等于给定值的结点的过程，恰是走了一条从根结点到该结点的路径的过程，和给定值比较的关键字个数等于路径长度加1(或结点所在层次数)，因此，和折半查找类似，与给定值比较的关键字个数不超过树的深度。然而，折半查找长度为”的表的判定树是唯一的，而含有n个结点的二叉排序树却不唯一。例如：图9．10中(a)和(b)的两棵二叉排序树中结点的值都相同，但前者由关键字序到(45，24，53，12，37，93)构成，而后者由关键字序列(12，24，37，45，53，93)构成。(a)树的深度为3，而(b)树的深度为6。再从平均查找长度来看，假设6个记录的查找概率相等，为1／6，则(a)树的平均查找长度为
    ASL(。)=i1[1+2+2+3+3+3]=14／6
    而(b)树的平均查找长度为
       ASL(6)=i1[1+2+3十4+5+6]=21／6
    图9．10不同形态的二叉查找树
    (a)关键字序列为(45，24，53，12，37，93)的二叉排序树；(b)关键字序列为(12，24，37，45，53，93)的单支树。
因此，含有”个结点的二叉排序树的平均查找长度和树的形态有关。当先后插入的关键字有序时，构成的二叉排序树蜕变为单支树。
树的深度为n，其平均查找长度为!!。顺序查找相同)，这是最差的情况。显然，最好的情况是二叉排序树的形态和折半查找的判定树相同，其平均查找长度和10致以成正比。那末，它的平均性能如何呢?
    假设在含有n(，l≥1)个关键字的序列中，i个关键字小于第一个关键字，，z1个关键字大于第一个关键字，则由此构造而得的二叉排序树在以个记录的查找概率相等的情况下，其平均查找长度为 其中P(i)为含有i个结点的二叉排序树的平均查找长度，则P(i)+1为查找左子树中每个关键字时所用比较次数的平均值，P(n―i-1)+1为查找右子树中每个关键字时所用比较次数的平均值。又假设表中竹个关键字的排列是“随机”的，即任一个关键字在序列中将是第1个，或第2个，…，或第”个的概率相同，则可对、(9．17)式从i等于0至n1取平均值
    
容易看出上式括弧中的第一项和第二项对称。又，0时(i)=0，则上式可改写为
显然，P(0)=0，P(1)=1。
    由式(9．18)可推得
由此可得
由递推公式(9．19)和初始条件P(1)：1可推得：
        由此可见，在随机的情况下，二叉排序树的平均查找长度和log挖是等数量级的。然而，在某些情况下(有人研究证明，这种情况出现的概率约为46．5％)[1I，尚需在构成二叉排序树的过程中进行“平衡化”处理，成为二叉平衡树。
  四、平衡二叉树
  平衡二叉树(Baianced Binary Tl'ee或}{eight―Balanced Tree)又称AVL树。它或者是一棵空树，或者是具有下列性质的二叉树：它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1。若将二叉树上结点的平衡因子BF(BalanceF。。t。，)定义为该结点的左子树的深度减去它的右子树的深度，则平衡二叉树上所有结点的平衡因子只可能是-1、0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。如图9．11(a)所示为两棵平衡二叉树，而图9．1l(b)所示为两棵不平衡的二叉树，结点中的值为该结点的平衡因子。
    图9．11平衡与不平衡的二叉树及结点的平衡因子
    (a)平衡二叉树；  (b)不平衡的二叉树。
    我们希望由任何初始序列构成的二叉排序树都是AVL树。因为AVL树上任何结点的左右子树的深度之差都不超过1，则可以证明它的深度和logN是同数量级的(其中N为结点个数)。由此，它的平均查找长度也和logN同数量级。
    如何使构成的二叉排序树成为平衡树呢?先看一个具体例子(参见图9．12)。假设表中关键字序列为(13，24，37，90，53)。空树和1个结点⑩的树显然都是平衡的二叉树。在插入24之后仍是平衡的，只是根结点的平衡因子BF、由0变为-1；在继续插入37之后，由于结点⑩的BF值由-1变成一2，由此出现了不平衡的现象。此时好比一根扁担出现一头重一头轻的现象，若能将扁担的支撑点由⑩改至④，扁担的两头就平衡了。由此，可以对树作一个向左逆时针“旋转”的操作，令结点⑦为根，而结点⑩为它的左子树，此时,结点⑩和⑦的平衡因子都为0，而且仍保持二叉排序树的特性。在继续插入90和53之后，由于结点⑦的BF’值由 1变成 2，排序树中出现了新的不平衡的现象，需进行调整。
但此时由于结点⑦插在结点④的左子树上，因此不能如上作简单调整。对于以结点⑤为根的子树来说，既要保持二叉排序树的特性，又要平衡，则必须以⑦作为根结点，而使⑦成为它的左子树的根，①成为它的右子树的根。这好比对树作了两次“旋转”操作――先向右顺时针，后向左逆时针(见图9．12(f)一(h))，使二叉排序树由不平衡转化为平衡。
  图9．12平衡树的生成过程
    (a)空树；(b)插入13；(c)插入24；(d)插入37；(e)向左逆时针右旋转平衡；
(f)相继插入90和53；(g)第一次向右顺时针旋转；(h)第二次向左逆时针旋转平衡之。
    一般情况下，假设由于在二叉排序树上插入结点而失去平衡的最小子树根结点的指针为a(即a是离插入结点最近，且平衡因子绝对值超过1的祖先结点)，则失去平衡后进行调整的规律可归纳为下列四种情况：
    (1)单向右旋平衡处理：由于在*a的左子树根结点的左子树上插入结点，*a的平衡因子由1增至2，致使以*a为根的子树失去平衡，则需进行一次向右的顺时针旋转操作，如图9．13(a)所示。
    (2)单向左旋平衡处理：由于在*a的右子树根结点的右子树上插入结点，*a的平衡因子由-1增至一2，致使以*a为根结点的子树失去平衡，则需进行一次向左的逆时针旋转操作。如图9．13(c)所示。
    (3)双向旋转(先左后右)平衡处理：由于在*a的左子树根结点的右子树上插入结点，*a的平衡因子由1增至2，致使以*a为根结点的子树失去平衡，则需进行两次旋转(先左旋后右旋)操作。如图9．13(b)所示。
    (4)双向旋转(先右后左)平衡处理：由于在*a的右子树根结点的左子树上插入结点，*a的平衡因子由-1增至一2，致使以*a为根结点的子树失去平衡，则需进行两次旋转(先右旋后左旋)操作。如图9．13(d)所示。
    上述四种情况中，(1)和(3)对称，(2)和(4)对称。旋转操作的正确性容易由“保持二叉排序树的特性：中序遍历所得关键字序列自小至大有序”证明之。同时，从图9．13可见，无论哪一种情况，在经过平衡旋转处理之后，以*b或*c为根的新子树为平衡二叉树，而且它的深度和插入之前以*a为根的子树相同。因此，当平衡的二叉排序树因插入结点而失去平衡时，仅需对最小不平衡子树进行平衡旋转处理即可。因为经过旋转处理之后的子树深度和插入之前相同，因而不影响插入路径上所有祖先结点的平衡度。
    插入结点    (c)
插入结点
    图9．13二叉排序树的平衡旋转图例
    (a)LL型；  (b)LR型；  (c)RR型；  (d)RL型。
    在平衡的二叉排序树BBS'I、上插入一个新的数据元素e的递归算法可描述如下：
    (一)若BBST为空树，则插入一个数据元素为e的新结点作为BBST、的根结点，树的深度增l；
    (二)若e的关键字和BBST‘的根结点的关键字相等，则不进行插入；
    (三)若e的关键字小于BBST的根结点的关键字，而且在BBST‘的左子树中不存在和e有相同关键字的结点，则将e插入在BBST‘的左子树上，并且当插入之后的左子树深度增加(+1)时，分别就下列不同情况处理之：
    (1)BBST、的根结点的平衡因子为l(右子树的深度大于左子树的深度)：则将根结点的平衡因子更改为0，BBST的深度不变；
    (2)BBST、的根结点的平衡因子为O(左、右子树的深度相等)：则将根结点的平衡因子更改为1，BBST的深度增l；
    ・235・
　　(3)BBST的根结点的平衡因子为1(左子树的深度大于右子树的深度)：则若BBST的左子树根结点的平衡因子为l：则需进行单向右旋平衡处理，并且在右旋处理之后，将根结点和其右子树根结点的平衡因子更改为0，树的深度不变；
    若BBST的左子树根结点的平衡因子为-1：则需进行先向左、后向右的双向旋转平衡处理，并且在旋转处理之后，修改根结点和其左、右子树根结点的平衡因子，树的深度不变；
    (四)若e的关键字大于BBST的根结点的关键字，而且在BBST的右子树中不存在和e有相同关键字的结点，则将e插入在BBST的右子树上，并且当插入之后的右子树深度增加(+1)时，分别就不同情况处理之。其处理操作和(3)中所述相对称，读者可自行补充。
    假设在“6．2．3二叉树的存储结构”中定义的二叉链表的结点中增加一个存储结点平衡因子的域bf，则上述在平衡的二叉排序树BBsT上插入一个新的数据元素e的递归算法如算法9．11所示，其中，左平衡处理的算法如算法9．12所示。算法9．9和算法9．10分别描述了在平衡处理中进行右旋操作和左旋操作时修改指针的情况。右平衡处理的算法和左平衡处理的算法类似，读者可自己补充。
    二叉排序树的类型定义为：
tn~def struct BSTNode I
  ElemType data：
  imt    bf；    ∥结点的平衡因子
  struct BSTNode*lch／．1d，*rcjild；∥左、右孩子指针
I BSTNode，*BSTree；
vold R―Rotate(BSTree＆p){
  ∥对以*p为根的二叉排序树作右旋处理，处理之后p指向新的树根结点，即旋转  ∥处理之前的左子树的根结点
∥lc指向的p左子树根结点
∥lc的右子树挂接为p的左子树
∥p指向新的根结点
算法9．9
  ∥对以*p为根的二叉排序树作左旋处理，处理之后p指向新的树根结点，即旋转
  ∥处理之前的右子树的根结点
∥rc指向的p右子树根结点
∥rc的左子树挂接为p的右子树
∥p指向新的根结点
算法9．10
Status InsertAVL(BSTree&T。ElemType e，Boolean&taller){
  ∥若在平衡的二叉排序树T中不存在和e有相同关键字的结点，则插入一个数据元素
  ∥为e的新结点，并返回1，否则返回0。若因插入而使二叉排序树失去平衡，则作平衡
  ∥旋转处理，布尔变量taller反映T长高与否
  if(!T){∥插入新结点，树“长高”，置taller为TRUE
>data．key){    ∥应继续在*T的左子树中进行搜索
    if(!InsertAVL(T>ichild，e，taller))  return 0；    ∥未插入
    if(taller)    ∥已插入到*T的左子树中且左子树“长高”
    switch(T>bf){    ∥检查*T的平衡度
    case LH：    ∥原本左子树比右子树高，需要作左平衡处理
    LeftBalance(T)；taller=FALSE；brack；
    case EH：    ∥原本左、右子树等高，现因左子树增高而使树增高
    T>bf=LH：taller=TRUE；  break；
    case RH：    ∥原本右子树比左子树高，现左、右子树等高
    T>bf：EH；taller=FALSE；  break；
    else{    ∥应继续在*T的右子树中进行搜索
    if(!InsertAVL(T>rchild，e，taller))return 0；    ∥未插入
    if(taller)    ∥已插入到T的右子树且右子树长高
    switch(T>bf){    ∥检查T的平衡度
    case LH：    ∥原本左子树比右子树高，现左、右子树等高
    T>bf=EH；taller=FALSE；break；
    case EH：    ∥原本左、右子树等高，现因右子树增高而使树增高
    T>bf=RH；taller=TRUE；  break；
    case RH：    ∥、原本右子树比左子树高，需要作右平衡处理
    RightBalance(T)；taller=FALSE；  break；
    }∥switch(T>bf)
    ＼jt else
    、?，else
    return 1；
＼f}InsertAVL
    算法9．II
void LeftBalance(BSTree＆T){
  ∥对以指针T所指结点为根的二叉树作左平衡旋转处理，本算法结束时，指针T指向
  ∥新的根结点
  ic=T>ichild；    ∥ic指向*T的左子树根结点
  switch(ic>bf){    ∥检查*T的左子树的平衡度，并作相应平衡处理
    case LH：    ∥新结点插入在*T的左孩子的左子树上，要作单右旋处理
    T>bf=ic>bf=EH；
    RRotate(T)；break；
    case RH：    ∥新结点插入在*T的左孩子的右子树上，要作双旋处理
    rd。Ic>right；  ∥rd指向*T的左孩子的右子树根
    ・237・
舯dtch(rd>bf>l  ∥修改*T及其左孩子的平衡因子
    case LH：T>bf=RH；  lc>bf=EH；  break；
    case翻：T>bf=lc>bf=EH；    break；
    case RH：T>bf=EH；  1c>bf=LH；  break；
l∥switch(rd>bf)
rd>bf=EH；
    LRotate(Thild)
    RRotate(T)；
  }∥switch(1c>bf)
＼≠}LeftBalance
∥对*T的左子树作左旋平衡处理
∥*T作右旋平衡处理
算法9．12
  五、平衡树查找的分析
  在平衡树上进行查找的过程和排序树相同，因此，在查找过程中和给定值进行比较的关键字个数不超过树的深度。那末，含有n个关键字的平衡树的最大深度是多少呢?为解答这个问题，我们先分析深度为^的平衡树所具有最少结点数。
    假设以N。表示深度为，2的平衡树中含有的最少结点数。显然，N0=0，Nl=1，N2：2，并且N。=．N卜，+N^一：+l。这个关系和斐波那契序列极为相似。利用归纳法容易证明：当^≥0时M=R+2～1，而R约等于(其中9=L!≯)[，则M约等于
    。反之，含有”个结点的平衡树的最大深度为logc、(√5(n+1))一2。因此，在平衡树上进行查找的时间复杂度为0(10g，r)。
    上述对二叉排序树和二叉平衡树的查找性能的讨论都是在等概率的前提下进行的，若查找概率不等，则类似于“9．1．3静态树表的查找”中的讨论。为了提高查找效率，需要对待查记录序列先进行排序，使其按关键字递增(或递减)有序，然后再按算法9．4构造一棵次优查找树。显然，次优查找树也是一棵二叉排序树，但次优查找树不能在查找过程中插入结点生成。二叉排序树(或称二叉查找树)是动态树表，最优或次优查找树是静态树表。    9．2．2 B．树和B’树
    一、B-树及其查找
　　B-树是一种平衡的多路查找树，它在文件系统中很有用。在此先介绍这种树的结构及其查找算法。
　　   一棵优阶的B树，或为空树，或为满足下列特性的m叉树：
    (1)树中每个结点至多有m棵子树；
    (2)若根结点不是叶子结点，则至少有两棵子1对；
    (3)除根之外的所有非终端结点至少有m／2]棵子树；
    (4)所有的非终端结点中包含下列信息数据
    (”，A0，K1，Al，K!，A2．…，K。，A。)①
    其中；K，(户l，…，n)为关键字，且K。<K。+1(i=l，…，"1)；Ai(i。0，…，n)为指向子树根结点的指针，且指针Ai。所指子树中所有结点的关键字均小于K：(i。l，…，
n)，A。所指子树中所有结点的关键字均大于K。，”()为关键字的个数(或n+1为子树个数)。
　　(5)所有的叶子结点都出现在同一层次上，并且不带信息(可以看作是外部结点或查找失败的结点，实际上这些结点不存在，指向这些结点的指针为空)。
　　    例如图9．14所示为一棵4阶的B-树，其深度为4。
图9．14一棵4阶的B0树
    由B．树的定义可知，在B．树上进行查找的过程和二叉排序树的查找类似。例如．在图9．14的B．树上查找关键字47的过程如下：首先从根开始，根据根结点指针t找到*a结点，因*a结点中只有一个关键字，且给定值47>关键字35，则若存在必在指针A2所指的子树内，顺指针找到*c结点，该结点有两个关键字(43和78)，而43<47<78，则若存在必在指针～所指的子树中。同样，顺指针找到*g结点，在该结点中顺序查找找到关键字47，由此，查找成功。查找不成功的过程也类似，例如在同一棵树中查找23。从根开始，因为23<35，则顺该结点中指针‰找到*b结点．又因为*b结点中只有一个关键字18，且23>18，所以顺结点中第二个指针A1找到*e结点。同理因为23<27，则顺指针往下找，此时因指针所指为叶子结点，说明此棵B．树中不存在关键字23，查找因失败而告终。
    由此可见，在B-树上进行查找的过程是一个顺指针查找结点和在结点的关键字中进行查找交叉进行的过程。
    由于B．树主要用作文件的索引，因此它的查找涉及外存的存取，在此略去外存的读写，只作示意性的描述。假设结点类型如下说明：
#define m 3
tyl：ec[ef struct BTNode{
  int    keynus：
  ．truct BTNode  。parent：
  Ke~／Pype    key[m十l：；
  8truct BTNode    *ptr【m+l：；
，／／B树的阶，暂设为3
∥结点中关键字个数，即结点的大小
∥指向双亲结点
／／关键字向量，
指针目录
・239・
  Record    *recptr[m+1]；
IBTNode，*BTree；
tledef struct{
∥记录指针向量，O号单元未用
∥B树结点和B树的类型
    FrNode*pt；    ∥指向找到的结点
    int    i；    ∥1．．m，在结点中的关键字序号
    ．int tag；    ∥1：查找成功，O：查找失败
    IResult；    ∥B树的查找结果类型
则算法9．13简要地描述了B树的查找操作的实现。
Result searchBTree(BTtee T。KeyType K){
  ∥在m阶B树T上查找关键字K，返回结果(pt，i，tag)。若查找成功，则特征值’tag=1，指针pt  ∥所指结点中第i个关键字等于K；否则特征值tag=0，等于K的关键字应插入在指针pt所指  ∥结点中第i和第H 1个关键字
p：T；  q=NULL；  found=FALSE；  i=0；while(p&＆!found){
    n=p>keynuln；  i=Search(p，K)；
∥初始化，p指向待查结点，q指向p的双亲
∥在p>key[1．．keyn~]中查找，
；  ∥找到待查关键字
  else return(q，i，0)；
ff SearchSTree
∥查找成功
∥查找不成功，返回K的插入位置信息
算法9．13
  二、B-树查找分析
  从算法9．11可见，在B树上进行查找包含两种基本操作：(1)在B．树中找结点；(2)在结点中找关键字。由于&树通常存储在磁盘上，则前一查找操作是在磁盘上进行的(在算法9．11中没有体现)，而后一查找操作是在内存中进行的，即在磁盘上找到指针p所指结点后，先将结点中的信息读入内存，然后再利用顺序查找或折半查找查询等于K的关键字。显然，在磁盘上进行一次查找比在内存中进行一次查找耗费时间多得多，因此，在磁盘上进行查找的次数、即待查关键字所在结点在B-树上的层次数，是决定B-树查找效率的首要因素。
    现考虑最坏的情况，即待查结点在B。树上的最大层次数。也就是，含N个关键字的m阶B-树的最大深度是多少?
    先看一棵3阶的B-树。按B．树的定义，3阶的B．树上所有非终端结点至多可有两个关键字，至少有一个关键字(即子树个数为2或3，故又称2-3树)。因此，若关键字个数≤2时，树的深度为2(即叶子结点层次为2)；若关键字个数≤6时，树的深度不超过3。反之，若B-树的深度为4，则关键字的个数必须≥7(参见图9．15(g))，此时，每个结点都含有可能的关键字的最小数目。
    一般情况的分析可类似二叉平衡树进行，先讨论深度为z+1的m阶B-树所具有的最少结点数。
    根据Bj．的定义，第一层至少有1个结点；第二层至少有2个结点；由于除根之外的   图9．15不同关键字数目的B-树
    (a)空树；(b)N=l；(c)N：2；(d)N一3；(e)N=4；(f)N=5；(g)N。7。
每个非终端结，点至少有厂m／2]棵子树，则第三层至少有2(广m／2])个结点．．．…‘；依次类推，第z+1层至少有2(厂m／2])卜。个结点。而z+1层的结点为叶子结点。若m阶B-树中具有N个关键字，则叶子结点即查找不成功的结点为N+1，由此有：这就是说，在含有N个关键字的B树上进行查找时，从根结点到关键字所在结点的路径上涉及的结点数不超过logr。
    三、B．树的插入和删除
    B-树的生成也是从空树起，逐个插入关键字而得。但由于B_树结点中的关键字个数必须≥厂优／2]-1，因此，每次插入一个关键字不是在树中添加一个叶子结点，而是首先在最低层的某个非终端结点中添加一个关键字，若该结点的关键字个数不超过m-1，则插入完成，否则要产生结点的“分裂”，如图9．16所示。
    例如，图9．16(n)所示为3阶的B-树(图中略去F结点(即叶子结点))，假设需依次插入关键字30，26，85和7。首先通过查找确定应插入的位置。由根*a起进行查找，确定30应插入在*d结点中，由于*d中关键字数目不超过2(即m-1)，故第一个关键字插入完成。插入30后的B．树如图9．16(b)所示。同样，通过查找确定关键字26亦应插入在*d结点中。由于*d中关键字的数目超过2，此时需将*d分裂成两个结点，关键字26及其前、后两个指针仍保留在*d结点中，而关键字37及其前、后两个指针存储到新产生的结点*d’中。同时，将关键字30和指示结点*d’的指针插入到其双亲结点中。由于*b结点中的关键字数目没有超过2，则插入完成。插入后的B-树如图9．16(d)所示。类似地，在*g中插入85之后需分裂成两个结点，而当70继而插入到双亲结点时，由于*e中关键字数目超过2，则再次分裂为结点*e和*e’，如图9．t6(g)所示。最后在插入关键字7时，*C、*b和*a相继分裂，并生成一个新的根结点*m，如图9．16(h)一(j)所示。
    图9．16在B-树中进行插入(省略叶子结点)
  一般情况下，结点可如下实现“分裂”。
  假设*p结点中已有m-1个关键字，当插入一个关键字之后，结点中含有信息为：
    m，Ao，(K1，A1)，…，(K。，A。)
且其中    Ki<KH 1    1≤i≤m
此时可将*p结点分裂为*p和*p’两个结点，其中*p结点中含有信息为
*p’结点中含有信息
而关键字Kr。／2]和指针*p’一起插入到*p的双亲结点中
    在B-树上插入关键字的过程如算法9．14所示，其中q和i是由查找函数SearchB―Tree返回的信息而得。
Status工nsertBTree(：BTree＆T，KeyType K，BTree q，int i){
  ∥在m阶B树T上结点*q的key[j1]与key[i十1]之间插入关键字K。
  ∥若引起结点过大，则沿双亲链进行必要的结点分裂调整，使T仍是m阶B树。
  x：K；  ap：NULL；  finished=FALSE；
  ．hile(q&&!finished){
    Insert(q，i，x，ap)；    ∥将x和ap分别插入到q>key[i+1]和q>ptr[i+1]
    if(q->keynu~I<m)finished：TRUE；  ∥插入完成
    else{    ∥分裂结点*q
    if(q)i=search(q，x)；    ∥在双亲结点*q中查找x的插入位置
    }∥else
    }∥while
    if(!finished)    ∥T是空树(参数q初值为NULl。)或者根结点已分裂为结点*q和*ap
    NewRoot(T，q，x，ap)；  ∥生成含信息(T，x，ap)的新的根结点*T，原T和ap为子树指针
    算法9．14
反之，若在B-树上删除一个关键字，则首先应找到该关键字所在结点，并从中删除之，若该结点为最下层的非终端结点，且其中的关键字数目不少于rm／2]，则删除完成，否则要进行“合并”结点的操作。假若所删关键字为非终端结点中的K，，则可以指针A所指子树中的最小关键字Y替代Ki，然后在相应的结点中删去Y。例如，在图9．16(a)的B．树上删去45，可以*f结点中的50替代45，然后在*f结点中删去50。因此，下面我们可以只需讨论删除最下层非终端结点中的关键字的情形。有下列三种可能：
    (1)被删关键字所在结点中的关键字数目不小于厂m／2]则只需从该结点中删去该关键字K。和相应指针Aj，树的其它部分不变，例如，从图9．16(a)所示B-树中删去关键字12，删除后的B．树如图9．17(a)所示。
    (2)被删关键字所在结点中的关键字数目等于广"z／2]-1，而与该结点相邻的右兄弟(或左兄弟)结点中的关键字数目大于厂研／2]-1，则需将其兄弟结点中的最小(或最大)的关键字上移至双亲结点中，而将双亲结点中小于(或大于)且紧靠该上移关键字的关键字下移至被删关键字所在结点中。例如，从图9．17(a)中删去50，需将其右兄弟结点中的61上移至*e结点中，而将*e结点中的53移至*f，从而使*f和*g中关键字数目均不小于厂m／2]-1，而双亲结点中的关键字数目不变，如图9．17(b)所示。
    (3)被删关键字所在结点和其相邻的兄弟结点中的关键字数目均等于／2]-1。
假设该结点有右兄弟，且其右兄弟结点地址由双亲结点中的指针A所指，则在删去关键字之后，它所在结点中剩余的关键字和指针，加上双亲结点中的关键字K．一起，合并到A所指兄弟结点中(若没有右兄弟，则合并至左兄弟结点中)。例如，从图9．17(b)所示
B-树中删去53；则应删去*f结点，并将*f中的剩余信息(指针“空”)和双亲*e结点中的61一起合并到右兄弟结点*g中。删除后的树如图9．17(c)所示。如果因此使双亲结点中的关键字数目小于厂m／2]-1，则依次类推。例如，在图9．17(c)的B-树中删去关键字37之后，双亲b结点中剩余信息(“指针c”)应和其双亲*a结点中关键字45一起合并至右兄弟结点*e中，删除后的B-树如图9．17(d)所示。
    在B-树中删除结点的算法在此不再详述，请读者参阅参考书目[1]后自己写出。
    四、B’树
    B’树是应文件系统所需而出的一种B．树的变型树①。一棵m阶的B’树和m阶的B-树的差异在于：
    (1)有n棵子树的结点中含有n个关键字；
    (2)所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。
    (3)所有的非终端结点可以看成是索引部分，结点中仅含有其子树(根结点)中的最大(或最小)关键字。
    例如图9．18所示为一棵3阶的B‘树，通常在Ⅳ树上有两个头指针，一个指向根结图9．18挺3阶的B’树点，另一个指向关键字最小的叶子结点。因此，可以对B’树进行两种查找运算：一种是从最小关键字起顺序查找，另一种是从根结点开始，进行随机查找。    在B’树上进行随机查找、插入和删除的过程基本上与B．树类似。只是在查找时，若非终端结点上的关键字等于给定值，并不终止，而是继续向下直到叶子结点。因此，在B’树，不管查找成功与否，每次查找都是走了一条从根到叶子结点的路径。B’树查找的分析类似于B树。B’树的插入仅在叶子结点卜进行．当结点中的关键字个数大于m时要分裂成两个结点，它们所含关键字的个数分别为L竿j和厂掣]。并且，它们的    <：z：
双亲结点中应同时包含这两个结点中的最大关键字。B’树的删除也仅在叶子结点进行，当叶子结点中的最大关键字被删除时，其在非终端结点中的值可以作为一个“分界关键字”存在。若因删除而使结点中关键字的个数少于厂号]时：其和兄弟结点的合并过程亦和B．树类似。
①  严格说来，它已不是第六章中定义的树了。
・  246・
9．2．3键树
    键树又称数字查找树(I)igital Search Trees)。它是一棵度≥2的树，树中的每个结点中不是包含一个或几个关键字，而是只含有组成关键字的符号。例如，若关键字是数值，则结点中只包含一个数位；若关键字是单词，则结点中只包含一个字母字符。这种树会给某种类型关键字的表的查找带来方便。
    假设有如下16个关键字的集合
    {CAI、CAO、LI、LAN、CHA、C}L&NG、WEN、CHAO、YUN、YANG、L,ONG、WANG、
    ZHAO、LIU、wU、CItEN}    (9―24)
可对此集合作如下的逐层分割。
首先按其首字符不同将它们分成五个子集：
    {CAI、CAO、CHA、C}tANG、C}tAO、CI-IEN}，{wEN、wANG、wU}，{ZHAO}，{LI、
    I．AN、I．ONG、LIU}，{YUN、YANG}，
然后对其中4个关键字个数大于1的子集再按其第二个字符不同进行分割。若所得子集的关键字多于1个，则还需按其第三个字符不同进行再分割。依此类推，直至每个小子集中只包含一个关键字为止。例如对首字符为C的集合可进行如下的分割：
    {{(CAI)、(CA0)}、{{(CHA)、((：HANG)、(CHAO)}、(CHEN)f}
显然，如此集合、子集和元素之间的层次关系可以用一棵树来表示，这棵树便为键树。例如，上述集合及其分割可用图9．19所示的键树来表示。树中根结点的五棵子树分别表示H】    (A)  (I)  fO】fA)(E1(U)fAl rUl fHI J(0)    (A)    (E)(N)($)(u)fNl fN)(N)($)rNl rNl rA
$)($)($)(N)(0)(N)($)    f$)fGl rG)f$
9㈣㈦    ㈤Q
工
$、
图9．19表示式(9―24)关键字集的一棵键树
}㈣置
$)    ($
首字符为c、L、w、Y和z的五个关键字子集。从根到叶子结点路径上所有结点的字符组成的字符串表示一个关键字，叶子结点中的特殊符号$表示字符串的结束。在叶子结点还含有指向该关键字记录的指针。
    为了查找和插入方便，我们约定键树是有序树，即同一层中兄弟结点之间依所含符号自左至右有序，并约定结束符$小于任何字符。
    ・247・
  通常，键树可有两种存储结构。
  (1)以树的孩子兄弟链表来表示键树，
则每个分支结点包括三个域：symbol域：存储关键字的一个字符；first域：存储指向第一棵子树根的指针；next域：存储指向右兄弟的指针。同时，叶子结点的infoptr域存储指向该关键字记录的指针。此时的键树又称双链树。例如，图9．19所示键树的双链树如图9．
20所示(图中只画出第一棵子树，其余部分省略)。
    双链树的查找可如下进行：假设给定值为K．ch(0．．num-1)，其中K．ch[0]至K．ch
[num一2]表示待查关键字中num-1个字符，K．ch[num-1]为结束符$，从双链树的根指针出发，顺first指针找到第一棵子树的图9．20双链树示例 根结点，以K．oh[0]和此结点的symbol域比较，若相等，则顺first域再比较下一字符，否则沿next域顺序查找。若直至“空”仍比较不等，则查找不成功。
    如果对双链树采用以下存储表示
#d|Ifine MAXKEYLEN 16
tltlmch~gtnlct{
  char ch[MAXKEYI／~]；
  iat nut．；
IKeysType；
typ|d|f enuta{LEAF，咖l
typI_d|If 81：alct DLTNode{
  char symbol；
∥关键字的最大长度
∥关键字
∥关键字长度
∥关键字类型
l~odeKind；∥结点种类：{叶子，分义
    stmaet DLTNode  *next；    ∥指向兄弟结点的指针
    NodeKind kind；    ．
    unlon{
    Record  *infoptr；    ∥叶子结点的记录指针
    stn|ct DLTNode  *first；∥分支结点的孩子链指针
    I    ’
  }DLTNode，*DLTree；    ∥双链树的类型
则在双链树中查找记录的操作由算法9．15实现。
  Record*SearchDLTree(DLTree T，KeysType K){
    ∥在非空双链树T中查找关键字等于K的记录，若存在，则返回指向该记录的指针，否则返回空
    }}
    P=T>first；  i=0；    ∥初始化
    ．bile(p&＆i<K．nul){
    ．bile(P&&Psymbol!=K．ch[i])P=P->next；∥查找关键字的第i位
    if(P＆＆i<K．nl／m―1)p=p一>first；    ∥准备查找下一位
    ++i：
    }  ∥查找结束
    算法9．15
    键树中每个结点的最大度d和关键字的“基”有关，若关键字是单词，则d=27，若关键字是数值，则d=11。键树的深度^则取决于关键字中字符或数位的个数。假设关键字为随机的(即关键字中每一位取基内任何值的概率相同)，则在双链树中查找每一位的平均查找长度为÷(1+d)。又假设关键字中字符(或数位)的个数都相等，则在双链树中进行查找的平均查找长度为詈(1+d)。
    在双链树中插入或删除一个关键字，相当于在树中某个结点上插入或删除一棵子树，在此不再详述。
    (2)若以树的多重链表表示键树，则树的每个结点中应含有d个指针域，此时的键树又称Trie树①。若从键树中某个结点到叶子结点的路径上每个结点都只有一个孩子，则可将该路径上所有结点压缩成一个“叶子结点”，且在该叶子结点中存储关键字及指向记录的指针等信息。例如，图9．19所示键树中，从结点Z到结点$为单支树，则在图9．21
相应的Trie树中只有一个含有关键字ZHAO及相关信息的叶子结点。由此，在Trie树中有两种结点：分支结点(含有d个指针域和一个指示该结点中非空指针域的个数的整数域)和叶子结点(含有关键字域和指向记录的指针域)。在分支结点中不设数据域，每个分支结点所表示的字符均由其双亲结点中(指向该结点)的指针所在位置决定。图9．21表示(9―24)关键字集的Trie树(深度=5)
    在Trie树上进行查找的过程为：从根结点出发，沿和给定值相应的指针逐层向下，直至叶子结点，若叶子结点中的关键字和给定值相等，则查找成功，若分支结点中和给定值相应的指针为空，或叶结点中的关键字和给定值不相等，则查找不成功。若设    。
①trie这个词是从retrieve(~)中取中间四个字符而构成，读音同(try)。
・249・
  typl6def struct TrieNode{
    Node_Kind kind；
    union{
    struct{Keyrype K；  Record  *infoptr}lf；  ∥叶子结点
    struct lTrieNode’ptr[27]；int num}  bh；  ∥分支结点
    }；
  }TrieNode，*TrieTree；  ∥键树类型
则键树查找操作可如算法9．16实现之。
  Record*SearchTrie(TrieTree T，Keys K)I
    ∥在键树T中查找关键字等于K的记录。
    for(P：T，i=0；    ∥对K的每个字符逐个查找
    P&＆P一>kind==BRANCH＆＆i<K．num；    ∥”P为分支结点
    P=P一>bh．ptr[ord(K．ch[i])]，++i)；  ∥ord~)求字符在字母表中序号
    if(P&＆P->kind==LEAF＆＆p一>If．K==K)return P一>if．infoptr；  ∥查找成功
    else return NULL；    ∥查找不成功
  l∥SearchTrie    ‘
    算法9．16
    从上述查找过程可见，在查找成功时走了一条从根到叶子结点的路径。例如，在图9．21上，查找关键字CHEN的过程为：从根结点a出发，经8、7结点，最后到达叶子结点6。而查找CHAI的过程为从根结点a出发，经J3、7结点后到e结点。由于该结点中和字符‘I’相应的指针为空，则查找不成功。由此，其查找的时间依赖于树的深度。我们可以对关键字集选择一种合适的分割，以缩减Trie树的深度。例如，根据(9．24)中关键字集的特点，可作如下分割。先按首字符不同分成多个子集之后，然后按最后一个字符不同分割每个子集，再按第二个字符……，前后交叉分割。由此得到如图9．22所示的Trie树，在该树上，除两个叶子结点在第四层上外，其余叶子结点均在第三层上。还可限制Trie    图9．22对(9．24)关键字集采用另一种分割法得到的Trie树(深度=4)
树的深度，假设允许Trie树的最大深度为l，则所有直至￡-1层皆为同义词的关键字都进入同一叶子结点。若分割得合适，则可使每个叶子结点中只含有少数几个同义词。当①  假设ord过程将K．ch[i]字符转换成该字符在字母表中序号，并假设字符’$’的序号为零。然也可增加分支的个数以减少树的深度。
　　在Trie树上易于进行插入和删除，只是需要相应地增加和删除一些分支结点。当分支结点中num域的值减为1时，便可被删除。
　　双链树和Trie树是键树的两种不同的表示方法，它们有各自的特点。从其不同的存储结构特性可见，若键树中结点的度较大，则采用Trie树结构较双链树更为合适。
　　综上对树表的讨论可见，它们的查找过程都是从根结点出发，走了一条从根到叶子(或非终端结点)的路径，其查找时间依赖于树的深度。由于树表主要用作文件索引，因此结点的存取还涉及外部存储设备的特性，故在此没有对它们作平均查找长度的分析。    9．3哈希表
9．3．1什么是哈希表
    在前面讨论的各种结构(线性表、树等)中，记录在结构中的相对位置是随机的，和记录的关键字之间不存在确定的关系，因此，在结构中查找记录时需进行一系列和关键字的比较。这一类查找方法建立在“比较”的基础上。在顺序查找时，比较的结果为“=”与“≠”两种可能；在折半查找、二叉排序树查找和B-树查找时，比较的结果为“<”、“=”和“>”三种可能。查找的效率依赖于查找过程中所进行的比较次数。
    理想的情况是希望不经过任何比较，一次存取便能得到所查记录，那就必须在记录的存储位置和它的关键字之间建立一个确定的对应关系厂，使每个关键字和结构中一个唯一的存储位置相对应。因而在查找时，只要根据这个对应关系厂找到给定值K的像厂(K)。若结构中存在关键字和K相等的记录，则必定在厂(K)的存储位置上，由此，不需要进行比较便可直接取得所查记录。在此，我们称这个对应关系厂为哈希(}lash)函数，按这个思想建立的表为哈希表。
    我们可以举一个哈希表的最简单的例子。假设要建立一张全国30个地区的各民族人口统计表，每个地区为一个记录，记录的各数据项为：显然，可以用一个一维数组c(1：30)来存放这张表，其中C[i]是编号为i的地区的人口情况。编号i便为记录的关键字，由它唯一确定记录的存储位置C[i]。例如：假设北京市的编号为1，则若要查看北京市的各民族人口，只要取出c[1]的记录即可。假如把这个数组看成是哈希表，则哈希函数，(key)=key。然而，很多情况下的哈希函数并不如此简单。可仍以此为例，为了查看方便应以地区名作为关键字。假设地区名以汉语拼音的字符表示，则不能简单地取哈希函数厂(key)=key，而是首先要将它们转化为数字，有时还要作些简单的处理。例如我们可以有这样的哈希函数：(1)取关键字中第一个字母在字母表中的序号作为哈希函数。例如：BEIJING的哈希函数值为字母“B”在字母表中的序号，等于02；或(2)先求关键字的第一个和最后一个字母在字母表中的序号之和，然后判别这个和值，若比30(表长)大，则减去30 c，例如：TIANJIN的首尾两个字母“T”和“N”序号之和为34，故取04为它的哈希函数值；或(3)先求每个汉字的第一个拼音字母的AS(：II码(和英文字母相同)之和的八进制形式，然后将这个八进制数看成是十进制再除以30取余数，若余数为零则加上30而为哈希函数值。例如：HENAN的头两个拼音字母为“H”和“N”，它们的AscII码之和~3(226)8，E1,(226)Lo除以(30)10得余数为16，则16为HENAN的哈希函数值，即记录在数组中的下标值。上述人口统计表中部分关键字在进三种不同的哈希函数情况下的哈希函数值如表9 l所列：
表9 l简单的哈希函数示例
  (1)哈希函数是一个映象，因此哈希函数的设定很灵活∞，只要使得任何关键字由此
所得的哈希函数值都，*住是长允许范围之内即可；
    (2)对不同的关键字f能得到同一哈希地址，这种现象称冲突(coll-啪n)。具有相同函数值的关键字对该哈希函数来说称做同义词(。y…ym)。例如：关键字HEBEI相HENAN不等，但^(HEBEI)=，l(HENAN)，叉如：^(SHArq x1)=^(sHANGHAI)；，3(HENAN)=^(sIcHuAN)。这种现象给建表造成困难，如在第一种哈希函数的情况下，因为山西、上海、山东和四川这四个记录的哈希地址均为19，而c[19]只能存放一个记录，那末其它三个记录存放在表中什么位置呢’井且从上表三个不同的哈希函数的情况可以看出，啥希函数选得合适可以减少这种冲突现象特别是在这个例子中。只可能有30个记录，可以仔细分析这30个关键字的特性l选择一个恰当的哈希函数来避免冲突的发生。
　　然而，在一般情况下，冲突只能尽可能地少，而不能完全避免。因为，l哈希函数是从键字集合到地址集合的映象。通常，关键字集合比较大，它的元素包括所有可能的关键字，而地址集合的元素仅为哈希表中的地址值。假设表长为玑则地址为0到”-1。例如，在c语言的编译程序中可对源程序中的标识符建立一张哈希表。在设定哈希函数时考虑的关键字集合应包含所有可能产生的关键字；假设标识符定义为雎字母为首的8位字母或数字，则关键字(标识符)的集合大小为c；2*c品*7 1=1 0t9388×10”．币『在源程序中出现的标识符是有限的，设表长为1000足矣。地址集合中的元素为0到999~,因此，在一般情况下，哈希函数是一个压缩映象，这就不可避免产生冲突。因此，在建造哈希表时不仅要设定一个“好”的哈希函数，而且要没定一种处理冲突的方法。 
　　 综上所述．可如下描述哈希表：根据设定的哈希函数H(女州)和处理冲突的方法将一①  Ha“(哈希)的原意率是杂凑252・
组关键字映象到一个有限的连续的地址集(区间)上，并以关键字在地址集中的“象”作为记录在表中的存储位置，这种表便称为哈希表，这一映象过程称为哈希造表或散列，所得存储位置称哈希地址或散列地址。
    下面分别就哈希函数和处理冲突的方法进行讨论。
    9．3．2哈希函数的构造方法
　　构造哈希函数的方法很多。在介绍各种方法之前，首先需要明确什么是“好”的哈希函数。
　　若对于关键字集合中的任一个关键字，经哈希函数映象到地址集合中任何一个地址的概率是相等的，则称此类哈希函数为均匀的(Llniform)哈希函数。换句话说，就是使关键字经过哈希函数得到一个“随机的地址”，以便使一组关键字的哈希地址均匀分布在整个地址区间中，从而减少冲突。  
    常用的构造哈希函数的方法有：
    1．直接定址法
    取关键字或关键字的某个线性函数值为哈希地址。即：
    H(key)=key或H(key)=a・key+b
    其中和6为常数(这种哈希函数叫做自身函数)o
    例如：有一个从1岁到100岁的人口数字统计表，其中，年龄作为关键字，哈希函数取关键字自身。如表9．2所示：
表9．2直接定址哈希函数例之一
这样，若要询问25岁的人有多少，则只要查表的第25项即可。
    又如：有一个解放后出生的人口调查表，关键字是年份，哈希函数取关键字加一常数：
H(key)=key+(-1948)，如表9．3所示。
表9．3直接定址哈希函数例之二
这样，若要查1970年出生的人数，则只要查第(1970―1948)=22项即可。
    由于直接定址所得地址集合和关键字集合的大小相同。因此，对于不同的关键字不会发生冲突。但实际中能使用这种哈希函数的情况很少。
  2．数字分析法
  假设关键字是以r为基的数(如：以10为基的十进制数)，并且哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干数位组成哈希地址。
    例如有80个记录，其关键宇为8位十进制数。假设哈希表的表长为100。0，则可取两位十进制数组成哈希地址。取哪两位?原则是使得到的哈希地址尽量避免产生冲突，则需从分析这80个关键字着手。假设这80个关键字中的一部分如下所列： 
对关键字全体的分析中我们发现：第①②位都是“8 1”，第⑨位只可能取1、2、3或4，第⑧位只可能取2、5或7，因此这四位都不可取。由于中间的四位可看成是近乎随机的，因此可取其中任意两位，或取其中两位与另外两位的叠加求和后舍去进位作为哈希地址。
  3．平方取中法
  取关键字平方后的中间几位为哈希地址。这是一种较常用的构造哈希函数的方法。
通常在选定哈希函数时不一定能知道关键字的全部情况，取其中哪几位也不一定合适，而一个数平方后的中间几位数和数的每一位都相关，由此使随机分布的关键字得到的哈希地址也是随机的。取的位数由表长决定。
    例如：为BASIC源程序中的标识符建立一个哈希表。假设BASIC语言中允许的标识符为一个字母，或一个字母和一个数字。在计算机内可用两位八进制数表示字母和数字，如图9．23(a)所示。取标识符在计算机中的八进制数为它的关键字。假设表长为512=2’，则可取关键字平方后的中间9位二进制数为哈希地址。例如，图9．23(b)列出了一些标识符及它们的哈希地址。
  4．折叠法
  将关键字分割成位数相同的几部分(最后一部分的位数可以不同)，然后取这几部分的叠加和(舍去进位)作为哈希地址，这方法称为折叠法(folding)。关键字位数很多，而且关键字中每一位上数字分布大致均匀时，可以采用折叠法得到哈希地址。
┃    记录  ┃    关键字  ┃    (关键字)。  ┃    哈希地址(2。’～2’)  ┃
    (b)
图9．23  (a)字符的八进制表示对照表  (b)标识符及其哈希地址
    例如：每一种西文图书都有一个国际标准图书编号(ISBN)，它是一个10位的十进制数字，若要以它作关键字建立一个哈希表，当馆藏书种类不到10，000时，可采用折叠法构造一个四位数的哈希函数。在折叠法中数位叠加可以有移位叠加和间界叠加两种方法。移位叠加是将分割后的每一部分的最低位对齐，然后相加；间界叠加是从一端向另一端沿分割界来回折迭，然后对齐相加。如国际标准图书编号0．442．20586．4的哈希地址分别如图9．24(a)和(b)所示。
    1．0088    6092
    H(key)=0088    H(电缈)=6092
    (a)    (b)
    图9．24由折叠法求得哈希地址
    (a)移位叠加；  (b)间界叠加。
  5．除留余数法
  取关键字被某个不大于哈希表表长仇的数p除后所得余数为哈希地址。即 H()=key  MOD  ≤m
    这是一种最简单，也最常用的构造哈希函数的方法。它不仅可以对关键字直接取模(MOD)，也可在折迭、平方取中等运算之后取模。
    值得注意的是，在使用除留余数法时，对户的选择很重要。若p选的不好，容易产生同义词。请看下面三个例子。
　　假设取标识符在计算机中的二进制表示为它的关键字(标识符中每个字母均用两位八进制数表示)，然后对户=2‘取模。这个运算在计算机中只要移位便可实现，将关键字左移直至只留下最低的6位二进制数。这等于将关键字的所有高位值都忽略不计。因而使得所有最后一个字符相同的标识符，如a1，i1，templ，cpl等均成为同义词。
若户含有质因子∥，则所有含有玎因子的关键字的哈希地址均为Ⅳ的倍数。例如，当P：21(=3×7)时，下列含因子7的关键字对21取模的哈希地址均为7的倍数。
    关键字    28  35  63  77  105
    哈希地址    7    14 0    14 0
    假设有两个标识符xy和yx，其中x、Y均为字符，又假设它们的机器代码(6位二进制数)分别为c(z)和c(Y)，则上述两个标识符的关键字分别为
    keyl=26c(z)+C(Y)和key2=26c(y)+c(z)
假设用除留余数法求哈希地址，且P=tq，t是某个常数，q是某个质数。则当q=3时，这两个关键字将被散列在差为3的地址上。因为
    [H(keyl)H(key2)]MOD q
    ={[26c(z)+f(Y)]MOD P[26c(Y)+c(z)]MOD P}MOD q
    ={267(z)MOD P十c(Y)MOD P26c(y)MOD Pf(z)MOD P：MOD q
    ={26f(z)MOD q+f(Y)MOD q26f(Y)MOD q(z)MOD q}MOD q
    (因对任z有(z MOD(t*q))MOD q：(z MOD q)MOD q)
当q：3时，上式为
    ={(2。MOD 3)((J・)MOD 3+f(Y)MOD 3一(2。MOD 3)f(Y)MOD 3c(X)
    M()D 3}MOD 3
    =0  M()D 3
    由众人的经验得知：一般情况下，可以选P为质数或不包含小于20的质因素的合数。
  6．随饥数法
  选择一个随机函数，取关键字的随机函数值为它的哈希地址，即H(key)=random(key)，其中r8,rldom为随机函数。通常，当关键字长度不等时采用此法构造哈希函数较恰当。
    实际工怍r{j需似不问的情I兄采用不同的哈希函数。通常，考虑的因素有：
    (1)计算哈希函数所需时删(包括硬件指令的因素)；
    (2)关键字的长度；
    (3)哈希表的人小；
    (4)关键字的分布情况；
    (5)记录的查找频率i
    9．3．3处理冲突的方法
　　在“9．3．1什么是哈希表”巾曾提及均匀的哈希函数可以减少冲突，但不能避免，因此，如何处理冲突是哈希造表不可缺少的另一方面。
　　假设哈希表的地址集为0～(”-1)，冲突是指由关键字得到的哈希地址为j(O≤J≤”-1)的位置上已存有记录，则“处理冲突”就是为该关键字的记录找到另--个“空”的哈希地址。在处理冲突的过程中可能得到一个地址序列H，  i=1，2，…，k，
(Hl∈[0，n-1])。即在处理哈希地址的冲突时，若得到的另一个哈希地址H1仍然发生冲突，则再求下一个地址H2，若1-12仍然冲突，再求得H3。依次类推，直至巩不发生冲突为止，则Hk为记录在表中的地址。
    通常用的处理冲突的方法有下列几种：
    1．开放定址法
    H=(H(key)+di)MOD m  i=1，2，…，忌(愚≤m-1)    (9-25)
其中：H(五纠)为哈希函数；m为哈希表表长；以为增量序列，可有下列三种取法：
(1)么=1，2，3，…，m-1，称线性探测再散列；(2)么=l。，-1。，22，一2。，3。，…，±忌。，(忌≤研／2)称二次探测再散列；(3)西=伪随机数序列，称伪随机探测再散列。
    例如，在长度为11的哈希表中已填有关键字分别为17，60，29的记录(哈希函数H(key)=key-MOD 11)，现有第四个记录，其关键字为38，由哈希函数得到哈希地址为5，产生冲突。若用线性探测再散列的方法处理时，得到下一个地址6，仍冲突；再求下一个地址7，仍冲突；直到哈希地址为8的位置为“空”时止，处理冲突的过程结束，记录填入哈希表中序号为8的位置。若用二次探测再散列，则应该填入序号为4的位置。类似地可得到伪随机再散列的地址(参见图9．25)。
    图9．25用开放定址处理冲突时，关键字为38的记录插入前后的哈希表
    (a)插入前；(b)线性探测再散列；(c)二次探测再散列；(d)伪随机探测再散列，伪随机数列9，…
    从上述线性探测再散列的过程中可以看到一个现象：当表中i，i+l，i+2位置上已填有记录时，下一个哈希地址为i、i+1，i+2和i+3的记录都将填入i+3的位置，这种在处理冲突过程中发生的两个第一个哈希地址不同的记录争夺同一个后继哈希地址的现象称作“二次聚集”，即在处理同义词的冲突过程中又添加了非同义词的冲突，显然，这种现象对查找不利。但另一方面，用线性探测再散列处理冲突可以保证做到：只要哈希表未填满，总能找到一个不发生冲突的地址巩，而二次探测再散列只有在哈希表长优为形如4j+3(j为整数)的素数时才可能[川，随机探测再散列，则取决于伪随机数列。
    ・257・
  2．再哈希法
．RH．i均是不同的哈希函数，即在同义词产生地址冲突时计算另一个哈希函数地址，直到冲突不再发生。这种方法不易产生“聚集”，但增加了计算的时间。
  3．链地址法
  将所有关键字为同义词的记录存储在同一线性链表中。假设某哈希函数产生的哈希地址在区间[0，优-1]上，则设立一个指针型向量   Chain ChainHash[m]；
其每个分量的初始状态都是空指针。凡哈希地址为i的记录都插入到头指针为Chain-Hash[i]的链表中。在链表中的插入位置可以在表头或表尾；也可以在中间，以保持同义词在同一线性链表中按关键字有序。
    例9．3  已知一组关键字为(19，14，23，01，68，20，84，27，55，11，10，79)则按哈希函数H(忌掣)=key MOD 13和链地址法处理冲突构造所得的哈希表如图9．26所示。
    图9．26链地址法处理冲突时的哈希表
    (同一链表中关键字自小至大有序)
  4．建立一个公共溢出区    ’
  这也是处理冲突的一种方法。假设哈希函数的值域为[0，m-1]，则设向量}lashTable[0．．m-1]为基本表，每个分量存放一个记录，另设立向量OverTable[0．．v]为溢出表。所有关键字和基本表中关键字为同义词的记录，不管它们由哈希函数得到的哈希地址是什么，一旦发生冲突，都填入溢出表。
  9．3．4啥希表的查找及其分析
在哈希表上进行查找的过程和哈希造表的过程基本一致。给定K值，根据造表时设定的哈希函数求得哈希地址，若表中此位置上没有记录，则查找不成功；否则比较关键字，若和给定值相等，则查找成功；否则根据造表时设定的处理冲突的方法找“下一地址”，直至哈希表中某个位置为“空”或者表中所填记录的关键字等于给定值时为止。
    算法9．17为以开放定址等方法(除链地址法外)处理冲突的哈希表的查找过程。
∥…开放定址哈希表的存储结构…
int hashsize[]={997，…}；    ／／哈希表容量递增表，一个合适的素数序列
ty~：lef struct{
  Zl~Type  *elem；    ∥数据元素存储基址，动态分配数组
  int    count；    ∥当前数据元素个数
  int    sizeindex；    ∥hashsize[sizeindex]为当前容量
I Has抽址le；
#define SUCCESS 1
#aeflne UNSUCCESS 0
#define DUPLICATE―i
Startle SearchRash(HashTable H，KeyType K．ilIt&P，int＆c){
  ∥在开放定址哈希表H中查找关键码为K的元素，若查找成功，以P指示待查数据
  ∥元素在表中位置，并返回SUCCESS；否则，以P指示插入位置，并返UNSUCCESS，
  ∥C用以计冲突次数，其初值置零，供建表插入时参考
  P=Hash(Z)；    ／／求得哈希地址
  ．bile(H．elem[p]．key『-NULLKEY＆＆  ／／该位置中填有记录
    !EQ(K，H．elem[p]．key))    ∥并且关键字不相等
    collision(p，++c)；    ／／求得下一探查地址P
  if EQ(K，H．elem[p]．key)
    return SUCCESS；    ／／查找成功，P返回待查数据元素位置
  elu r．t哪UNSUCCESS；  ／／查找不成功(H．elem[p]．key==NULLKEY)，
    ／／P返回的是插入位置
}∥SearchHash
    算法9．17
算法9．1B通过调用查找算法(算法9．17)实现了开放定址哈希表的插入操作。
S~tus Insert#ash(Hagh瞄le＆H，Elemtype e){
  ∥查找不成功时插入数据元素e到开放定址哈希表H中，并返回OK；若冲突次数
  ∥过大，则重建哈希表
  c=0；
  if(1Iashsearch(H，e．key，P，C))
    retuEn DUPLICATE；    ／／表中已有与e有相同关键字的元素
  else if(C<hashsize[H．sizeindex]／2){    ∥冲突次数c未达到上限，(c的阀值可调)
    H．elem[p]=e；  ++H．count；  return OK；  ／／插入e
    }
else RecreateHashTable(H)；    ／／重建哈希表
＼f|InsertHash
    算法9．18
例9-4  已知例9-3中所示的一组关键字按哈希函数H(忌缈)=key MOD 13和线性探测处理冲突构造所得哈希表a．elem[0．．15]如图9．27所示。
0  1  2  3  4  5  6  7  8  9  lO 11  12 13  14 15
  I 14 l 01 I 68 l 27 1 55 I 19 l 20 I 84 l 79 I 23 l 11 l lO l  l  I
    图9．27哈希表a．dem[0：15]
    (其哈希函数为H(￡呵)=^缈MOD 13，处理冲突为线性探测再散列)
　　给定值K=84的查找过程为：首先求得哈希地址H(84)=6，因a．elem[6]不空且a．elem[6]．key=／=84，则找第一次冲突处理后的地址H1=(6+1)MOD 16=7，而a．elem[7]不空且a．elem[7]．key=／=84，则找第二次冲突处理后的地址H2=(6+2)elem[8]不空且a．elem[8]．key=84，则查找成功，返回记录在表中序号8。    
　　给定值K=38的查找过程为：先求哈希地址H(38)=12，a．elem[12]不空且a．elem【12]．key~38，则找下一地址H1：(12+1)MOD 16：13，由于a．elem[13]是空记录，则表明表中不存在关键字等于38的记录。
    从哈希表的查找过程可见：
    1)虽然哈希表在关键字与记录的存储位置之间建立了直接映象，但由于“冲突”的产生，使得哈希表的查找过程仍然是一个给定值和关键字进行比较的过程。因此，仍需以平均查找长度作为衡量哈希表的查找效率的量度。
    2)查找过程中需和给定值进行比较的关键字的个数取决于下列三个因素：哈希函数，处理冲突的方法和哈希表的装填因子。
    哈希函数的“好坏”首先影响出现冲突的频繁程度。但是，对于“均匀的”哈希函数可以假定：不同的哈希函数对同一组随机的关键字，产生冲突的可能性相同，因为一般情况下设定的哈希函数是均匀的，则可不考虑它对平均查找长度的影响。
　　对同样一组关键字，设定相同的哈希函数，则不同的处理冲突的方法得到的哈希表不同，它们的平均查找长度也不同。如例9―3和例9．4中的两个哈希表，在记录的查找概率相等的前提下，前者(链地址法)的平均查找长度为
　　    ASL，(12)=老(1・6+2・4+3+4)=1．75
后者(线性探测再散列)的平均查找长度为
    ASl，(12)=麦(1・6+2+3・3+4+9)=2．5
    容易看出，线性探测再散列在处理冲突的过程中易产生记录的二次聚集，如即使得哈希地址不相同的记录又产生新的冲突；而链地址法处理冲突不会发生类似情况，因为哈希地址不同的记录在不同的链表中。
    在一般情况下，处理冲突方法相同的哈希表，其平均查找长度依赖于哈希表的装填因子。
    哈希表的装填因子定义为  表中填入的记录数  哈希表的长度
a标志哈希表的装满程度。直观地看，a越小，发生冲突的可能性就越小；反之，a越大，表中已填入的记录越多，再填记录时，发生冲突的可能性就越大，则查找时，给定值需与之进行比较的关键字的个数也就越多。
    可以证明：[’][2]
    线性探测再散列的哈希表查找成功时的平均查找长度为
    s。。≈丢(1+击)    (9．27)
　　随机探测再散列、二次探测再散列和再哈希的哈希表查找戊功时的平均查找长度为
　　    链地址法处理冲突的哈希表查找成功时的平均查找长度为
    由于哈希表在查找不成功时所用比较次数也和给定值有关，则可类似地定义哈希表在查找不成功时的平均查找长度为：查找不成功时需和给定值进行比较的关键字个数的期望值。同样可证明，不同的处理冲突方法构成的哈希表查找不成功时的平均查找长度分别为  线性探测再散列,  伪随机探测再散列等 链地址
    下面仅以随机探测的一组公式为例进行分析推导。
    先分析长度为m的哈希表中装填有n个记录时查找不成功的平均查找长度。这个问题相当于要求在这张表中填入第九+1个记录时所需作的比较次数的期望值。
　　假定：(1)哈希函数是均匀的。即产生表中各个地址的概率相等；(2)处理冲突后产生的地址也是随机的。
若设A表示前i个哈希地址均发生冲突的概率；qi表示需进行i次比较才找到一个“空位”的哈希地址(即前i-1次发生冲突，第i次不冲突)的概率。则有： 
可见，在户i和q；之间，存在关系式
由此，当长度为优的哈希表中已填有扎个记录时，查找不成功的平均查找长度为
　　由于哈希表中扎个记录是先后填入的，查找每一个记录所需比较次数的期望值，恰为填入此记录时找到此哈希地址时所进行的比较次数的期望值。因此，对表长为m、记录数为，z的哈希表，查找成功时的平均查找长度为
　　    s。=∑PiCi=∑PiU；
设对挖个记录的查找概率相等。即户；=÷则
    从以上分析可见，哈希表的平均查找长度是a的函数，而不是，z的函数。由此，不管n多大，我们总可以选择一个合适的装填因子以便将平均查找长度限定在一个范围内。
    值得提醒的是，若要在非链地址处理冲突的哈希表中删除一个记录，则需在该记录的位置上填入一个特殊的符号，以免找不到在它之后填入的“同义词”的记录。
    最后要说明的是，对于预先知道且规模不大的关键字集，有时也可以找到不发生冲突的哈希函数，因此，对频繁进行查找的关键字集，还是应尽力设计一个完美的(perfect)的哈希函数。例如，对PASCAI。语言中的26个保留字可设定下述无冲突的哈希函数
    H(key)=L+g(key[1])+g(key[L])    (9．34)
其中L为保留字长度，key[1]为第一个字符，key[L]为最后一个字符，g(x)为从字符到数字的转换函数，例如g[F]=15，g(N)=13，H(F15NCTION)：8+15+13=36~所得哈希表长度为37(请参见参考书目[14]p．327一p．328)。