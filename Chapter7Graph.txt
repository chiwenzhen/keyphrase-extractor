
第7章  图
    图(Graph)是一种较线性表和树更为复杂的数据结构。在线性表中，数据元素之间仅有线性关系，每个数据元素只有一个直接前驱和一个直接后继；在树形结构中，数据元素之间有着明显的层次关系，并且每一层上的数据元素可能和下一层中多个元素(即其孩子结点)相关，但只能和上一层中一个元素(即其双亲结点)相关；而在图形结构中，结点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关。由此，图的应用极为广泛，特别是近年来的迅速发展，已渗入到诸如语言学、逻辑学、物理、化学、电讯工程、计算机科学以及数学的其它分支中。
    读者在“离散数学”课程中已学习了图的理论，在此仅应用图论的知识讨论如何在计算机上实现图的操作，因此主要学习图的存储结构以及若干图的操作的实现。
7．1  图的定义和术语
    图是一种数据结构，加上一组基本操作，就构成了抽象数据类型。抽象数据类型图的定义如下：
^DT Graph{
    数据对象V：v是具有相同特性的数据元素的集合，称为顶点集。
    数据关系R：
    R={VR}
    VR={<v，w>l、r，w∈v且P(v，w)，<v，w>表示从v到w的弧，
    谓词P(v，w)定义了弧<v，w>的意义或信息  }
  基本操作：
    CreateGraph(＆G，V，vR)；
    初始条件：v是图的顶点集，VR是图中弧的集合。
    操作结果：按v和1l，R的定义构造图G。
    DestroyGraph(&G)；
    初始条件：图G存在。
    操作结果：销毁图G。
    LocateVex(G，u)；
    初始条件：图G存在，u和G中顶点有相同特征。
    操作结果：若G中存在顶点u，则返回该顶点在图中位置；否则返回其它信息。
    GetVex(G，v)；
    初始条件‘：图G存在，v是G中某个顶点。
    操作结果：返回v的值。
    PutVex(&G，v，value)；
    初始条件：图G存在，v是G中某个顶点。
    操作结果：对v赋值value。
    FirstAd[jVe)【(G，v)；
    初始条件：图G存在，v是G中某个顶点。
  操作结果：返回v的第一个邻接顶点。若顶点在G中没有邻接顶点，则返回“空”。
NextAdjVe】【(G，v，w)；    
  初始条件：图G存在，v是G中某个顶点，w是v的邻接顶点。
  操作结果：返回v的(相对于w的)下一个邻接顶点。若w是v的最后一个邻接点，则返回“空”。
InsettVex(＆G，v)；
  初始条件：图G存在，v和图中顶点有相同特征。
  操作结果：在图G中增添新顶点v。
DeleteVex(＆G，v)；
  初始条件：图G存在，v是G中某个顶点。
  操作结果：删除G中顶点v及其相关的弧。
Insez“tArc(＆Gi v，w)；
  初始条件：图G存在，v和w是G中两个顶点。
  操作结果：在G中增添弧<v，w>，若G是无向的，则还增添对称弧<w，v>。
DeleteArc(＆G，v，w)；
  初始条件：图G存在，v和w是G中两个顶点。
  操作结果：在G中删除弧<v，w>，若G是无向的，则还删除对称弧<w，v>。
DFSTraverse(G，v，Visit())；    
  初始条件：图G存在，v是G中某个顶点，visit是顶点的应用函数。
  操作结果：从顶点v起深度优先遍历图G，并对每个顶点调用函数visit一次且仅一次。一旦vis北()失败，则操作失败。
BFSTraverse(G，v，visit())；
  初始条件：图G存在，v是G中某个顶点，visit是顶点的应用函数。
  操作结果：从顶点v起广度优先遍历图G，并对每个顶点调用函数visit一次且仅一次。一旦visit()失败，则操作失败。
    }ADT Graph
在图中的数据元素通常称做顶点(Vertex)，V是顶点的有穷非空集合；VR是两个顶点之间
的关系的集合。若(a，b)∈VR，则(a，b)表示从口到叫的一条弧(心c)，且称a为弧尾(Tail)或初始点(Initial nocle)，称叫为弧头(Head)或终端点(Terrninal node)，此时的图称为有向图(Digraph)。若(。，a)∈Ⅷ必有(a，v)∈c，即VR是对称的，则以无序对(a，a)代替这两个有序对，表示a和b之间的一条边(Edge)，此时的图称为无向图(Undigrap’rt)。例如图7．1(a)中G。是有向图，定义此图的谓词P(v，w)则表示从v到w的一条单向通路。
(a)    (b)
    图7．1图的示例  
(a)有向图G1；(b)无向图G2。
      G1=(V1，{A1})
    其中V2={Vl，V2，7J3，U4，7J5÷・
    E2=：(l，2)，(u1，u4)(V2，3)，(V2，口5)，("03，734)，(733，V5)}
    我们用”表示图中顶点数目，用e表示边或弧的数目。在下面的讨论中，我们不考虑顶点到其自身的弧或边，即若(u，u，)∈VR，则可i≠u，，那末，对于无向图，e的取值范围是0到{”(n-1)。有寺n(”-1)条边的无向图称为完全图(Completed graph)。对于有向图，。的取值范围是0到n(n-1)。具有n(”-1)条弧的有向图称为有向完全图。
有很少条边或弧(如B<”log”)的图称为稀疏图(Sparse graph)，反之称为稠密图(Densegraph)。
    有时图的边或弧具有与它相关的数，这种与图的边或弧相关的数叫做权(Weight)。这些权可以表示从一个顶点到另一个顶点的距离或耗费。这种带权的图通常称为网 (Network)。
    假设有两个图G=(V，{E})和G’=(V’，{E，})，如果V’∈V且E’∈E，则称G’为G的子图(Subgraph)?例如，图7．2是子图的一些例子。
    图7．2子图示例
(a)G1的子图；(b)G2的子图。
    对于无向图G=(V，{E})，如果边(V，b’)∈E，则称顶点口和u’互为邻接点(Adja．cent)，即”’相邻接。边(u，u’)依附(Incident)于顶点u和g’，或者说(u，g’)和顶点u和u’相关联。顶点u的度(Degree)是和u相关联的边的数目，记为TD(V)。例如，G2中顶点V3的度是3。对于有向图G=(V，{A})，如果弧(u，’)∈A，则称顶点u邻接到顶点u’，顶点73’邻接自顶点u。弧(73，f’)和顶点”，f’相关联。以顶点口为头的弧的数目称为V的入度(InDegree)，记为ID(73)；以73为尾的弧的数目称为7J的出度(Outde．
gree)，记为OD()；顶点7．3的度为TD(u)：ID(”)+OD()。例如，图G1中顶点，的入度119(731)=1，出度OF)(1)=2，度TD(1)=11)(7．31)+OD(1)=3。一般地，如果顶点”i的度记为TD(。。)，那么一个有”个顶点，e条边或弧的图，满足如下关系：TD(i)
    无向图G=(V，{E})中从顶点a到顶点u’的路径(Path)是一个顶点序列(="Ui。，”a，…，”i，。=u，)，其中(可¨一l，u¨)∈E，1≤a≤a。如果G是有向图，则路径也是有向的，顶点序列应满足(u¨1，让．i)∈E，l≤歹≤m。路径的长度是路径上的边或弧的数目。第一个顶点和最后一个顶点相同的路径称为回路或环(c)ycle)。序列中顶点不重复出现的路径称为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。
    在无向图G中，如果从顶点口到顶点u’有路径，则称a和’是连通的。如果对于图中任意两个顶点i、ui∈V，让和u，都是连通的，则称G是连通图((]onnected Graph)。图7．1(b)中的G2就是一个连通图，而图7．3(a)中的G3则是非连通图，但G3有三个连通分量，如图7．3(b)所示。所谓连通分量((]onnected Component)，指的是无向图中的极大连通子图。
    在有向图G中，如果对于每一对f，u、，r，i≠f，从i到，和从uf到矾都存在路径，则称G是强连通图。有向图中的极大强连通子图称作有向图的强连通分量。例如图7．1(a)中的G，不是强连通图，但它有两个强连通分量，如图7．4所示。
    图7．3无向图及其连通分量
(a)无向图G3；    (b)G3的三个连通分量。
    图7．4  G-的两个强连通分量    图7．5 G，的最大连通分量的一棵生成树
    一个连通图的生成树是一个极小连通子图，它含有图中全部顶点，但只有足以构成一棵树的n-1条边。图7．5是G，中最大连通分量的一棵生成树。如果在一棵生成树上添加一条边，必定构成一个环，因为这条边使得它依附的那两个顶点之间有了第二条路径。一棵有，z个顶点的生成树有且仅有n-1条边。如果一个图有。个顶点和小于。-1条边，则是非连通图。如果它多于n-1条边，则一定有环。但是，有n-1条边的图不一定是生成树。
    如果一个有向图恰有一个顶点的入度为0，其余顶点的入度均为1，则是一棵有向树。一个有向图的生成森林由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。图7．6所示为其一例。
    图7．6一个有向图及其生成森林
    在前述图的基本操作的定义中，关于“顶点的位置”和“邻接点的位置”只是一个相对的概念。因为，从图的逻辑结构的定义来看，图中的顶点之间不存在全序的关系(即无法将图中顶点排列成一个线性序列)，任何一个顶点都可被看成是第一个顶点；另一方面，任一顶点的邻接点之间也不存在次序关系。但为了操作方便，我们需要将图中顶点接任意的顺序排列起来(这个排列和关系VR无关)。由此，所谓“顶点在图中的位置”指的是该顶点在这个人为的随意排列中的位置(或序号)。同理，可对某个顶点的所有邻接点进行排队，在这个排队中自然形成了第一个或第点个邻接点。若某个顶点的邻接点的个数大，于是，则称第n+1个邻接点为第五个邻接点的下一个邻接点，而最后一个邻接点的下一个邻接点为“空”。
7．2图的存储结构
在前面几章讨论的数据结构中，除了广义表和树以外，都可以有两类不同的存储结构，它们是由不同的映象方法(顺序映象和链式映象)得到的。由于图的结构比较复杂，任意两个顶点之间都可能存在联系，因此无法以数据元素在存储区中的物理位置来表示元素之间的关系，即图没有顺序映象的存储结构，但可以借助数组的数据类型表示元素之间的关系。另一方面，用多重链表表示图是自然的事，它是一种最简单的链式映象结构，即以一个由一个数据域和多个指针域组成的结点表示图中一个顶点，其中数据域存储该顶点的信息，指针域存储指向其邻接点的指针，如图7．7所示为图7．1中有向图G，和无向图G2的多重链表。但是，由于图中各个结点的度数各不相同，最大度数和最小度数可能相差很多，因此，若按度数最大的顶点设计结点结构，则会浪费很多存储单元；反之，若按每个顶点自己的度数设计不同的结点结构，又会给操作带来不便。因此，和树类似，在实际应用中不宜采用这种结构，而应根据具体的图和需要进行的操作，设计恰当的结点结构和表结构。常用的有邻接表、邻接多重表和十字链表。下面分别讨论。
    图7．7图的多重链表
(a)Gl的多重链表；(b)G2的多重链表。7．2．1数组表示法
  用两个数组分别存储数据元素(顶点)的信息和数据元素之间的关系(边或弧)的信息。其形式描述如下：
例如，图7．1中G1和G2的邻接矩阵如图7．8所示。以二维数组表示有”个顶点的图时，需存放n个顶点信息和n。个弧信息的存储量。若考虑无向图的邻接矩阵的对称性，则可采用压缩存储的方式只存入矩阵的下三角(或上三角)元素。
    借助于邻接矩阵容易判定任意两个顶点之间是否有边(或弧)相连，并容易求得各个顶点的度。对于无向图，顶点q的度是邻接矩阵中第{行(或第i列)的元素之和，即    TD(Vi)=∑A[i][J](”=MAX―VERTEX―NUM)对于有向图，第i行的元素之和为顶点q的出度OD(a)，第J列的元素之和为顶点ai的。例如，图7．9列出了一个有向网和它的邻接矩阵。
    图7．9 网及其邻接矩阵
    (a)网N；(b)邻接矩阵。
    算法7．1是在邻接矩阵存储结构MGraph上对图的构造操作的实现框架，它根据图G的种类调用具体构造算法。如果G是无向网，则调用算法7．2。构造一个具有n个顶点和e条边的无向网G的时间复杂度是O(n。+e・n)，其中对邻接矩阵G．arcs的初始化耗费了O(n2)的时间。
  Status CreateGraph(MGraph＆G){
    ∥采用数组(邻接矩阵)表示法，构造图G。
    8canf(＆G．kind)；
    Hitch(G．kind)l
    ∞8e DG：return Creat~G(G)；  ∥构造有向图G
    case DN：return CreateDN(G)；  ∥构造有向网G
    case UDG：return CreateUDG(G)；  ∥构造无向图G
    ∞的UDN：return CreateUDN(G)；  ∥构造无向网G
    default：return ERROR；
    }
＼fl CreateGraph
    算法7．1
 Status CreateUDN(MGraph&G){
    ∥采用数组(邻接矩阵)表示法，构造无向网G。
　　SC．aDf(＆G．vexnum，＆G．arcnum，&Inclnfo)；    ／／Inclnfo为0则各弧不含其它信息
　　for(i=0；i<G．vexntm；++i)s∞nf(&G．vexs[i])；  ∥构造顶点向量
    for(i=0；i<G．vexnum；++i)    ∥初始化邻接矩阵
    for(J=0；J<G．v~num；++J)G．arcs[i][J]={INFINITY，NULL}；  ∥{adj，info
    for(k=0；k<G．arcnum；++k){    ∥构造邻接矩阵
    8csnf(&vl，＆v2，&w)；    ／／输入一条边依附的顶点及权值
    i=LocateVex(G，v1)；J=LocateVex(G，v2)；  ∥确定vl和v2在G中位置
    G．arcs[i][J]．adj=w；    ∥弧<v1，v2>的权值
    if(IncInfo)Input(*G．arCS[i][j]．info)；  ∥若弧含有相关信息，则输入
    G．arcs[j][i]=G．arCS[i][J]；    ／／置<v1，v2>的对称弧<V2，v1>
    }    。
    return OK；
・  162・
、ff CreateUDN
算法7．2
　　在这个存储结构上也易于实现7．2节所列的基本操作。如，FIRS"r―ADJ(G，v)找a的第一个邻接点。首先，由LOC―VERTEX(G，秒)找到口在图G中的位置，即a在一维数组vexs中的序号i，则二维数组arcs中第i行上第一个adj域的值为“1”的分量所在列号j，便为t，的第一个邻接点在图G中的位置。同理，下一个邻接点在图G中的位置便为j列之后第一个adj域的值为“1”的分量所在列号。
　　7．2．2邻接表
    邻接表(Adjacency IAst)是图的一种链式存储结构。在邻接表中，对图中每个顶点建立一个单链表，第i个单链表中的结点表示依附于顶点功的边(对有向图是以顶点q为尾的弧)。每个结点由三个域组成，其中邻接点域(adjvex)指示与顶点口；邻接的点在图中的位置，链域(nextarc)指示下一条边或弧的结点；数据域(info)存储和边或弧相关的信息，如权值等。每个链表上附设一个表头结点。在表头结点中，除了设有链域(firstarc)指向链表中第一个结点之外，还设有存储顶点矶的名或其它有关信息的数据域(data)。如下图所示
    表结点
adjvex[nextarc info
    头结点
这些表头结点(可以链相接)通常以顺序结构的形式存储，以便随机访问任一顶点的链表。例如图7．10(a)和(b)所示分别为图7．1中G。和Gz的邻接表。一个图的邻接表存储结构可形式地说明如下：
∥…图的邻接表存储表示…
#define MAX-VERTE-NDM 20
td|I：t ArcNode 1
  int    adjvex；。    ∥该弧所指向的顶点的位置
  struct ArcNode  *nextarc；    ∥指向下一条弧的指针
  InfoType    *info；    ∥该弧相关信息的指针
IArcNode；    
typed《8truer VNode{
  VertexType data；
  ArcNode    *firstarc：
IYNode，AdjList[MAX―VERTEX―NUM]；
typedef struct{
  AdjList veIrices：
  i|It    vex21um．arcnum；
  int  kind~
f ALGraph；
∥顶点信息
∥指向第一条依附该顶点的弧的指针
∥图的当前顶点数和弧数
∥图的种类标志
    图7．10邻接表和逆邻接表
(a)G1的邻接表；(b)G2的邻接表；(c)G1的逆邻接表。	
若无向图中有n个顶点、e条边，则它的邻接表需n个头结点和2。个表结点。显然，在边稀疏(e《＼的情况下，用邻接表表示图比邻接矩阵节省存储空间，当和边相关的信息较多时更是如此。
    在无向图的邻接表中，顶点t，i的度恰为第i个链表中的结点数；而在有向图中，第i个链表中的结点个数只是顶点q的出度，为求入度，必须遍历整个邻接表。在所有链表中其邻接点域的值为i的结点的个数是顶点n的入度。有时，为了便于确定顶点的入度或以顶点让为头的弧，可以建立一个有向图的逆邻接表，即对每个顶点n建立一个链接以u；为头的
弧的表，例如图7．10(c)所示为有向图G1的逆邻接表j
    在建立邻接表或逆邻接表时，若输入的顶点信息即为顶点的编号，则建立邻接表的时间复杂度为0(，z+e)，否则。需要通过查找才能得到顶点在图中位置，则时间复杂度为o(n・e)。
　　在邻接表上容易找到任一顶点的第一个邻接点和下一个邻接点，但要判定任意两个顶点(q和q)之间是否有边或弧相连，则需搜索第i个或第j个链表，因此，不及邻接矩阵方便。
　　7．2．3十字链表
    十字链表(Orthogonal List)是有向图的另一种链式存储结构。可以看成是将有向图的邻接表和逆邻接表结合起来得到的一种链表。在十字链表中，对应于有向图中每一条弧有一个结点，对应于每个顶点也有一个结点。这些结点的结构如下所示：
    弧结点    顶点结点~
    data-firstin firstout
在弧结点中有五个域：其中尾域(tailvex)和头域(I~eadvex)分别指示弧尾和弧头这两个顶点在图中的位置，链域hlink指向弧头相同的下一条弧，而链域tlink指向弧尾相同的下一条弧，inlo域指向该弧的相关信息。弧头相同的弧在同一链表上，弧尾相同的弧也在同一链表上。它们的头结点即为顶点结点，它由三个域组成：其中data域存储和顶点相关的信息，如顶点的名称等；firstin和firstout为两个链域，分别指向以该顶点为弧头或弧尾的第一个弧结点。例如，图7．1l(a)中所示图的十字链表如图7．1l(b)所示。若将有向图的邻接矩阵看成是稀疏矩阵的话，则十字链表也可以看成是邻接矩阵的链表存储结构，在图的十字链表中，弧结点所在的链表非循环链表，结点之间相对位置自然形成，不一定按顶点序号有序，表头结点即顶点结点，它们之间而是顺序存储。
图7．11有向图的十字链表
    有向图的十字链表存储表示的形式说明如下所示：
    ∥有向图的十字链表存储表示
    #d《iMAX．VERTEX一ⅫJM 20
    t’『P．d81I、1ct Arcl~x{
    in七tailvex，headvex；∥该弧的尾和头顶点的位置
    8truct ArcBox  *hl／nk，*tlLnk；  ／／分别为弧头相同和弧尾相同的弧的链域
    InfoType    *info；    ／／该弧相关信息的指针
    }ArcBox；
    typ|ld．f 8tZ％1~'t VexNode{
    VertexType data；
    Axe．Box    *firstin，'．firstout；//分别指向该顶点第一条入弧和出弧
    }VexNode；
    tl・d・f struct{
    VexNode xlist[MAX―VERTEX―NUM]；∥表头向量
        vexnum，arcnum；    ∥有向图的当前顶点数和弧数
    }OLGraph；
    只要输入，z个顶点的信息和e条弧的信息，便可建立该有向图的十字链表，其算法如算法7．3所示。
Status CreateDG(OLGraph＆G){
  ∥采用十字链表存储表示，构造有向图G(G．kind=DG)。
  sc-nf(＆G．vexnl~，＆G．arcnum，&IncInfo)；    ∥IncInfo为0则各弧不含其它信息
  for(i。0；i<G．vex~um；++i){    ∥构造表头向量
    。∞f(&G．xlist[i]．data)；    ／／输入顶点值
    G・xlist【iJ．firstin=NULL；G．xlist[i]．firstout=BT／LL；∥初始化指针
}
for(k：0；k<G．arcnum；++k){
  ec∞f(&vl，＆v2)；
  i=LocateVex(G，v1)；  J=LocateVex(G，v2)；
  P=(ArcBox*)ulloc(sizeof(ArcBox))；
∥输入各弧并构造十字链表
∥输入一条弧的始点和终点
∥确定v1和v2在G中位置
∥假定有足够空间
    。p={i，j，G．xlist[j]．firstin，G．xlist[i]．firstout，NuLL}  ∥对弧结点赋值
    ∥{tail・vex，headvex，hl ink，tlinJ【，info}
    G．xlist[j]．firstin：G．xlist[i]．firstout=p；    ∥完成在入弧和出弧链头的插入
    if(IncInfo)Input(‘p->info)；    ∥若弧含有相关信息，则输入
  }
＼l}CreateDG
    算法7．3
    在十字链表中既容易找到以让为尾的弧，也容易找到以ui为头的弧，因而容易求得顶点的出度和入度(或需要，可在建立十字链表的同时求出)。同时，由算法7．3可知，建立十字链表的时间复杂度和建立邻接表是相同的。在某些有向图的应用中，十字链表是很有用的工具。    
7．2．4邻接多重表
    邻接多重表(．Adjacency Multilist)是无向图的另一种链式存储结构。虽然邻接表是无向图的一种很有效的存储结构，在邻接表中容易求得顶点和边的各种信息。但是，在邻接表中每一条边(％u，)有两个结点，分别在第i个和第歹个链表中，这给某些图的操作带来不便。例如在某些图的应用问题中需要对边进行某种操作，如对已被搜索过的边作记号或删除一条边等，此时需要找到表示同一条边的两个结点。因此，在进行这一类操作的无向图的问题中采用邻接多重表作存储结构更为适宜。
    邻接多重表的结构和十字链表类似。在邻接多重表中，每一条边用一个结点表示，它由如下所示的六个域组成：
maTk l  |v“  1  i|ink  l  jvex  1  ilink  l  in{o
其中，mark为标志域，可用以标记该条边是否被搜索过；ivex和ivex为该边依附的两个顶点在图中的位置；ilink指向下一条依附于顶点ivex的边；jlink指向下一条依附于顶点jvex的边，info为指向和边相关的各种信息的指针域。每一个顶点也用一个结点表示，它由如下所示的两个域组成：
其中，data域存储和该顶点相关的信息，firstedge域指示第一条依附于该顶点的边。例如，图7．12所示为无向图G2的邻接多重表。在邻接多重表中，所有依附于同一顶点的边串联在同一链表中，由于每条边依附于两个顶点，则每个边结点同时链接在两个链表中。可见，对无向图而言，其邻接多重表和邻接表的差别，仅仅在于同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点。因此，除了在边结点中增加一个标志域外，邻接多重表所需的存储量和邻接表相同。在邻接多重表上，各种基本操作的实现亦和邻接表相似。邻接多重表的类型说明如下：
图7 12无向囤G：的邻接多重表
∥    无向图的邻接多重表存储表示
#“fi…MAX vⅧ20
typedef emnu junviglted．～ited}V1sltIf{
typedf BtⅢE‰I
  vlsitlf    ma；    ∥访同标记
  int    …．]vex．    ∥该边依附的两个顶点的位置
  Btruct EBo11nk，。]link；∥分别指向依附这两个顶点的下一条边
  Inf00e    *it0；    ∥该边信息指针
lEB0*：
‘ypedef 8tnlct v【B。x I
  VertemlⅦe  data；
  EB。x    *flrstedge．    ∥指向第一条依附该顶点的边
{ve)∞ox：
t““f 8tfuct I
  ve心Dx ad]list【MA】(．VERx．NUMJ{
  i    um，eem皿；    ∥无向图的当前顶点数和边数
lAMLm∞；
7．3图的遍历
  和树的遍历类似，在此．我们希望从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次。这一过程就叫做图的遍历(Travers・ng Graph)。图的遍历算法是求解图的连通性问题、拓扑排序和求关键路径等算法的基础。
  然而，图的遍历要比树的遍历复杂得多。因为图的任一顶点都可能和其余的顶点相邻接。所以在访问了某个顶点之后，可能沿着某条路径搜索之后，又回到该顶点上。例如图7．1(b)中的G2，由于图中存在回路，因此在访问了。l，％"，。4之后，沿着边(”4，”1)又可访问到”-。为了避免同一顶点被访间多次，在遍历图的过程中，必须记下每个已访问过的顶点。为此，我们可以设一个辅助数组vts・L【O n-1]，它的初始值置为”假”或者零，一旦访问了顶点％便置vtedn]为“真”或者为被访问时的次序号。
　  通常有两条遍历图的路径：深度优先搜索和广度优先搜索。它们对无向图和有向图都适用。
7．3．1深度优先搜索
    深度优先搜索([)epth―First Search)遍历类似于树的先根遍历，是树的先根遍历的推广。
　　假设初始状态是图中所有顶点未曾被访问，则深度优先搜索可从图中某个顶点可出发，访问此顶点，然后依次从n的未被访问的邻接点出发深度优先遍历图，直至图中所有和u有路径相通的顶点都被访问到；若此时图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。
　　    图7．13遍历图的过程
　　(a)无向图G。；(b)深度优先搜索的过程；(c)广度优先搜索的过程。
    以图7．13(a)中无向图G。为例，深度优先搜索遍历图的过程如图7．13(b)所示①。假设从顶点u，出发进行搜索，在访问了顶点u。之后，选择邻接点u2。因为口2未曾访问，则从wz出发进行搜索。依次类推，接着从z，。，u8、tU5 L出I发进行搜索。在访问了u5之后，由于”5的邻接点都已被访问，则搜索回到u。。由于同样的理由，搜索继续回到”。u：直至。。，此时由于口1的另一个邻接点未被访问，则搜索又从u。到u。，再继续进行下去。由此，得到的顶点访问序列为：
    ①  图中以带箭头的粗实线表示遍历时的访问路径，以带箭头的虚线表示回溯的路径。图中的小圆圈表示已被访问过的邻接点，大圆圈表示访问的邻接点。
    显然，这是一个递归的过程。为了在遍历过程中便于区分顶点是否已被访问，需附设访问标志数组visited[0：n-1]，其初值为“false'’，一旦某个顶点被访问，则其相应的分量置为“true”。整个图的遍历如算法7．4和7．5所示。
∥算法7．4和7．5使用的全局变量
    Boolean visited[MAX]；    ∥访问标志数组
    Status(*visitFunc)(int v)；  ∥函数变量
void DFSTraverse(Graph G，Status(*Visit)(int v)){
    ∥对图G作深度优先遍历。
  visitFunc=visit；    ∥使用全局变量visitFi／nc，使DFS不必设函数指针参数
  for(v=0；v<G．vexnum；++v)visited[v]=FALSE；  ∥访问标志数组初始化
  for(v=0；v<G．vexnum；++v)
    if(!visited[v])DFS(G，v)；  ∥对尚未访问的顶点调用DFS
}
    算法7．4
void DFS(Graph G，int v){
  ∥从第v个顶点出发递归地深度优先遍历图G。
  visitea[v]=TRUE；  visitFunc(v)；  ∥访问第v个顶点
  for(w=FirstAdJVex(G，v)；  w；  w=NextAdjVex(G，v，w))
    if(!visited[w])DFS(G，w)；    ∥对v的尚未访问的邻接顶点w递归调用DFS
}
    算法7．5
    分析上述算法，在遍历图时，对图中每个顶点至多调用一次【)FS函数，因为一旦某个顶点被标志成已被访问，就不再从它出发进行搜索。因此，遍历图的过程实质上是对每个顶点查找其邻接点的过程。其耗费的时间则取决于所采用的存储结构。当用二维数组表示邻接矩阵作图的存储结构时，查找每个顶点的邻接点所需时间为0(n。)，其中n为图中顶点数。而当以邻接表作图的存储结构时，找邻接点所需时间为O(e)，其中e为无向图中边的数或有向图中弧的数。由此，当以邻接表作存储结构时，深度优先搜索遍历图的时间复杂度为0(n+F)。    
7．3．2广度优先搜索
    广度优先搜索(Breadth―First Search)遍历类似于树的按层次遍历的过程。
    假设从图中某顶点。出发，在访问了u之后依次访问可的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使“先被访问的顶点的邻接点”先于“后被访问的顶点的邻接点”被访问，直至图中所有已被访问的顶点的邻接点都被访问到。若此时图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。换句话说，广度优先搜索遍历图的过程是以u为起始点，由近至远，依次访问和u有路径相通且路径长度为1，2，…的顶点。例如，对图G。进行广度优先搜索遍历的过程如图7．13(c)所示，首先访问n，和n，的邻接点u2和a3，然后依次访问a2的邻接点a4和u5及a3的邻接点a6和a7，最后访问a4的邻接点a。由于这些顶点的邻接点均已被访问，并且图中所有顶点都被访问，由此完成了图的遍历。得到的顶点访问序列为a和深度优先搜索类似，在遍历的过程中也需要一个访问标志数组。并且，为了次访问路径长度为2、3、…的顶点，需附设队列以存储已被访问的路径长度为1，2，…的顶点。
广度优先遍历的算法如算法7．6所示。
    void BFSTraverse(Graph G，Status(*Visit)(int v)){
    ∥按广度优先非递归遍历图G。使用辅助队列Q和访问标志数组visited。
    for(v=0；v<G．vexnum；++v)  visited[v]=FALSE；
    InitQueue(Q)；    ∥置空的辅助队列Q
    for(v=O；  v<G．vexilum；  ++v)
    if(!visited[v]){    ／／v尚未访问
    EnQueue(Q，v)；    ∥v入队列
    ．hile(!QueueEmpty(Q))  {
    DeQueue(Q，u)；    ∥队头元素出队并置为u
    vi。。Slted[u]=TRUE；  Visit(u)；  ∥访问u
    for(w=FirstAdjVex(G，u)；  w；  w=NextAdjVex(G，u，w))
    if(!visited[w])EnQueue(Q，w)；∥u的尚未访问的邻接顶点w入队列Q
    l∥while
    }∥if
    ＼}}BFSTraverse
    算法7．6
    分析上述算法，每个顶点至多进一次队列。遍历图的过程实质上是通过边或弧找邻接点的过程，因此广度优先搜索遍历图的时间复杂度和深度优先搜索遍历相同，两者不同之处仅仅在于对顶点访问的顺序不同。
7．4图的连通性问题
    在这一节中，我们将利用遍历图的算法求解图的连通性问题，并讨论最小代价生成树以及重连通性与通信网络的经济性和可靠性的关系。
7．4．1无向图的连通分量和生成树
    在对无向图进行遍历时，对于连通图，仅需从图中任一顶点出发，进行深度优先搜索或广度优先搜索，便可访问到图中所有顶点。对非连通图，则需从多个顶点出发进行搜索，而每一次从一个新的起始点出发进行搜索过程中得到的顶点访问序列恰为其各个连通分量中的顶点集。例如，图7．3中的G3是非连通图，按照图7．14所示G3的邻接表进行深度优先搜索遍历，三次调用【)FS过程(分别从顶点A、D和G出发)得到的顶点访问序列为：
    A L M J B F C    D E    G K H I
图7．14 G3的邻接表
别为连通图G。的深度优先生成树和广度优先生成树，图中虚线为集合B(G)中的边。
    对于非连通图，每个连通分量中的顶点集，和遍历时走过的边一起构成若干棵生成树，这些连通分量的生成树组成非连通图的生成森林。例如，图7．15(c)所示为G3的深度优先生成森林，它由三棵深度优先生成树组成。
    假设以孩子兄弟链表作生成森林的存储结构，则算法7．7生成非连通图的深度优先生成森林，其中DFSTree函数如算法7．8所示。显然，算法7．7的时间复杂度和遍历相同。
void DFSForest(Graph G，CSTree＆T){
  ∥建立无向图G的深度优先生成森林的
  ∥(最左)孩子(右)兄弟链表T。
  T=NULL；
  for(v：0；v<G．vexnum；++v)
    Visited[vJ=FALSE；
    for(v=0；v<G．vexnum；++v)
  这三个顶点集分别加上所有依附于这些顶点的边，便构成了非连通图G3的三个连通分量，如图7．3(b)所示。设E(G)为连通图G中所有边的集合，则从图中任一顶点出发遍历图时，必定将E(G)分成两个集合T(G)和B(G)，其中T(G)是遍历图过程中历经的边的集合；B(G)是剩余的边的集合。
显然，T(G)和图G中所有顶点一起构成连通图G的极小连通子图，按照7．1节的定义，它是连通图的一棵生成树，并且称由深度优先搜索得到的为深度优先生成树；由广度优先搜索得到的为广度优先生成树。例如，图7．15(a)和(b)所示分图7．15生成树和生成森林  (a)G。的深度优先生成树；
  (b)G。的广度优先生成树；
  (c)G，的深度优先生成森林。
if(!visited[v]){    ∥第v顶点为新的生成树的根结点  p=(CSTree)realloc(8izeo~(CSNede))；  ∥分配根结点
p={GetVex(G，v)，NULL，NULL}；    ∥给该结点赋值
  if(!T)T=p；    ∥是第一棵生成树的根(T的根)
  else q->nextsibling=p；    ∥是其它生成树的根(前一棵的根的“兄弟”)
  DFSTree(G，v，p)；
    }
ff DFSForest
算法7．7
∥q指示当前生成树的根
∥建立以p为根的生成树
void DFSTree(Graph G．in％v，CSTree&T){
  ∥从第v个顶点出发深度优先遍历图G，建立以T为根的生成树。
  visited[v]=TRUE；first=17RUE；
  for(w=FisrtAdjVex(C，v)；  w；  w=NextAdjVex(G，V，w))
    if(!visiteatw]){
    p=(CSTree)lloc(8izeof(CSNocIe))；  ∥分配孩子结点
    *p=!GetVex(G，w)，m『u一，NUI-L}；
    if(first){    ∥w是v的第--个未被访问的邻接顶点
    T->Ichild=p；  first=FALSE；    ∥是根的左孩子结点
}∥if
else I
    q->nextsibling：p
 l∥else
∥w是v的其它未被访问的邻接顶点
∥是上一邻接顶点的右兄弟结点
    q=p；
    DFSTree(G，w，q)；    ∥从第w个顶点出发深度优先遍历图G，建立r生成树q
    f∥if
}f DFSTree
    算法7．8
    7．4．2有向图的强连通分量
　　深度优先搜索是求有向图的强连通分量的一个新的有效方法。假设以十字链表作有向图的存储结构，则求强连通分量的步骤如下：
　　(1)在有向图G上，从某个顶点出发沿以该顶点为尾的弧进行深度优先搜索遍历，并按其所有邻接点的搜索都完成(即退出DFs函数)的顺序将顶点排列起来。此时需对7．3．1中的算法作如下两点修改：(a)在进入．DF、sTraverse函数时首先进行计数变量的初始化，即在入口处加上count=0的语句；(b)在退出DFS函数之前将完成搜索的顶点号记录在另一个辅助数组[inished[vexnum]中，即在I)FS函数结束之前加上finished[++count]。v的语句。
    (2)在有向图G上，从最后完成搜索的顶点(即finished[vexnum―1]中的顶点)出发，沿着以该顶点为头的弧作逆向的深度优先搜索遍历，若此次遍历不能访问到有向图中所有顶点，则从余下的顶点中最后完成搜索的那个顶点出发，继续作逆向的深度优先搜索遍历，依次类推，直至有向图中所有顶点都被访问到为止。此时调用I)FSTraverse时需作如下修改：函数中第二个循环语句的边界条件应改为。从finished[vexrlt，m-1]至finished[0]。
    由此，每一次调用DFs作逆向深度优先遍历所访问到的顶点集便是有向图G中一个强连通分量的顶点集。    
　　例如图7．11所示的有向图，假设从顶点训，出发作深度优先搜索遍历，得到finished数组中的顶点号为(1，3，2，0)；则再从顶点u，出发作逆向的深度优先搜索遍历，得到两个顶点集{口，，抄，，”。}和{秽：}，这就是该有向图的两个强连通分量的顶点集。
　　上述求强连通分量的第二步，其实质为：(1)构造一个有向图G，，设G=(V，{A})，则G，=(V，{A，})，对于所有(ui，u，)∈A，必有(u，，到i)∈A，。即G，中拥有和(；方向相反的弧；(2)在有向图G，上，从顶点finished[vexnum-1]出发作深度优先搜索遍历。可以证明，在G，上所得深度优先生成森林中每一棵树的顶点集即为G的强连通分量的顶点集‘引。
    显然，利用遍历求强连通分量的时间复杂度亦和遍历相同。
    7．4．3最小生成树
    假设要在n个城市之间建立通信联络网，则连通n个城市只需要n-l条线路。这时，自然会考虑这样一个问题，如何在最节省经费的前提下建立这个通信网。
　　在每两个城市之间都可以设置一条线路，相应地都要付出一定的经济代价  ，。个城市之间，最多可能设置”(，，-1)／2条线路，那么，如何在这些可能的线路中选择”l条，以使总的耗费最少呢?
　　可以用连通网来表示n个城市以及”个城市间可能设置的通信线路，其中M的顶点表示城市，边表示两城市之间的线路，赋于边的权值表示相应的代价．．对于”个顶点的连通网可以建立许多不同的生成树，每一棵生成树都可以是・个通信问。现在，我们要选择这样一棵生成树，也就是使总的耗费最少。这个问题就是构造、代价生成树(Minimum(；ost Spanning Tree)(简称为最小生成树)的问题。一棵生成树的代价就是树上各边的代价之和。   构造最小生成树可以有多种算法。其中多数算法利用了最小生成书寸的下列一种简称为MST的性质：假设N=(V，{E})是一个连通网，U是顶点集V的～一个非空子集。若(“，秽)是一条具有最小权值(代价)的边，其中“∈L，，勘∈V-u，则必存在一棵包含边(“，u)的最小生成树。
    可以用反证法证明之。假设网N的任何一棵最小生成树都不包含(“，u)。设T是连通网上的一棵最小生成树，当将边(“，)加入到T中时，由生成树的定义，中必存在一条包含(“，u)的回路。另一方面，由于T是生成树，则在T上必存在另一条边(“’，u’)，其中“’∈【，，’∈V-u，且“和“’之间，。和’之间均有路径相通。删去边(“’，u’)，便可消除上述回路，同时得到另一棵生成树T’。因为(“，)的代价不高于(“’，’)，则T’的代价亦不高于T，T’是包含(，。)的一棵最小生成树。由此和假设矛盾。
    普里姆算法和克鲁斯卡尔算法是两个利用MST性质构造最小生成树的算法。    
    下面先介绍普里姆算法。
　　假设N=(、厂，{E})是连通网，TE是N上最小生成树中边的集合。算法从u={“o}(“0∈、，r)，。TE={}开始，重复执行下述操作：在所有M∈U，∈vU的边(。，u)∈E中找一条代价最小的边(“0，0)并入集合TE，同时移0并入u，直至u=、为止。此时TE中必有，z-1条边，则T：(V，{TE})为N的最小生成树。
图7．16普里姆算法构造最小生成树的过程
　　为实现这个算法需附设一个辅助数组closedge，以记录从u到Vu具有最小代价的边。对每个顶点口i∈yu，在辅助数组中存在一个相应分量closedge[i-1]，它包括两个域，其中loweost存储该边上的权。显然，closedge[i-1]．|owcost=Min{cost(u，vi)①lu∈U} vex域存储该边依附的在u中的顶点。例如，图7．16所示为按普里姆算法构造网的一棵最小生成树的过程；在构造过程中辅助数组中各分量值的变化如图7．17所示。初始状态时，由于U={”1}，则到V―u中各顶点的最小边，即为从依附于顶点1的各条边中，找到一条代价最小的边(“o，u0)=(1，3)为生成树上的第一条边，同时将口0(=Z)3)并入集合【，。然后修改辅助数组中的值。首先将closedge[2]．10wcost改为’0’，以示顶点V3已并入u。然后，由于边(3，u2)上的权值小于closedge[1]．10wcost，则需修改closedge[1]为边(3，2)及其权值。同理修改closedge[4]和closedge[5]。依次类推，直到U=V。
    图7．17  图7．16构造最小生成树过程中辅助数组中各分量的值
假设以二维数组表示网的邻接矩阵，且令两个顶点之间不存在的边的权值为机内允许的最大值(INT―MAX)，则普里姆算法如算法7．9所示。
  void MiniSpanTree―PRIM(MGraph G，7ertexType U){
    ∥用普里姆算法从第u个顶点出发构造网G的最小生成树T，输出T的各条边。
    ∥记录从顶点集U到vU的代价最小的边的辅助数组定义：
    ∥struet{
    ∥    VertexType adjvex；
    ∥啪ype lowcost；
    ∥}closedge[MAX-VERTEX-NUM]；
    k=LocateVex(G，u)；
    ~or(J=0；j<G．vexrl~,N；++j)    ∥辅助数组初始化
    if(j!=k)  closedge[J]={u，G．arcs[k][J]．adj}；  ∥{adjvex，lowcost}
    closedge[k]．10wcost=0；    ∥初始，U={u}
    for(i=i；i<G．vexnum；++i){    ∥选择其余G．vexnum-1个顶点
    k=minimum(closedge)；    ∥求出T的下一个结点：第k顶点
    ∥此时closedge[k]．10wcost=
    ∥    MIN{closedge[vi]．10wcost l closedge[vi]．10wcost>0，vi∈V-U}
    printf(closedge[k]．adjvex，G．vexs[k])；    ∥输出生成树的边
    closedge[k]．10weost：0；    ∥第k顶点并入U集
    for(j=0；j<G．vexnum；++j)
    if(G．arcs[k][j]．adj<closedge[j]．10weost)    ∥新顶点并入U后重新选择最小边
    、    closedge[j]：{G．vexs[k]，G．arcs[k][j]．adj；；
    }
    }∥MiniSlE)anTree
    算法7．9
    例如，对图7．16(a)中的网，利用算法7．9，将输出生成树上的五条边为：{(u1，3)，(3，u6)，(6，4)，(V3，2)，(2，5)}。
    分析算法7．9，假设网中有n个顶点，则第一个进行初始化的循环语句的频度为n，第二个循环语句的频度为n-1。其中有两个内循环：其一是在closedge[v]．10wcost中求最小值，其频度为n-1；其二是重新选择具有最小代价的边，其频度为n。由此，普里姆算法的时间复杂度为0(rt0)，与网中的边数无关，因此适用于求边稠密的网的最小生成树。
    而克鲁斯卡尔算法恰恰相反，它的时间复杂度为O(doge)(e为网中边的数目)，因此它相对于普里姆算法而言，适合于求边稀疏的网的最小生成树。
    克鲁斯卡尔算法从另一途径求网的最小生成树。假设连通网N=(、，r，{E})，则令最小生成树的初始状态为只有n个顶点而无边的非连通图T=(v，{j)，图中每个顶点自成一个连通分量。在E中选择代价最小的边，若该边依附的顶点落在T中不同的连通分量上，则将此边加入到T中，否则舍去此边而选择下一条代价最小的边。依次类推，直至T中所有顶点都在同一连通分量上为止。
例如，图7．18所示为依照克鲁斯卡尔算法构造一棵最小生成树的过程。代价分别为
    图7．18克鲁斯卡尔算法构造最小生成讨的过程
1，2，3，4的四条边由于满足上述条件，则先后被加入到丁中，代价为5的两条边(u-，可4)图7．19连通图G 5
和(v；，u。)被舍去。因为它们依附的两顶点在同一连通分量上，它们若加入丁中，则会使T中产生回路，而下一条代价(=5)最小的边(2，3)联结两个连通分量，则可加入T。由此，构造成一棵最小生成树。
    上述算法至多对e条边各扫描一次，假若以第九章将介绍的“堆”来存放网中的边，则每次选择最小代价的边仅需0(10ge)的时间(第一次需0(e))。又生成树T的每个连通分量可看成是一个等价类，则构造T加入新的边的过程类似于求等价类的过程，由此可以以6．5节中介绍的MFSet类型来描述．『，使构造T的过程仅需0(eloge)的时间，由此，克鲁斯卡尔算法的时间复杂度为0(eloge)。
  7．4．4关节点和重连通分量
  假若在删去顶点可以及和口相关联的各边之后，将图的一个连通分量分割成两个或两个以上的连通分量，则称顶点。为该图的一个关节点(articulation point)。一个没有关节点的连通图称为是重连通图(I)iconnected graph)。在重连通图上，任意一对顶点之间至少存在两条路径，则在删去某个顶点以及依附于该顶点的各边时也不破坏图的连通性。若在连通图上至少删去n个顶点才能破坏图的连通性，则称此图的连通度为忌。关节点和重连通在实际中有较多应用。显然，一个表示通信网络的图的连通度越高，其系统越可靠，无论是哪一站点出现故障或遭到外界破坏，都不影响系统的正常工作；又如，一个航空网若是重连通的，则当某条航线因天气等某种原因关闭时，旅客仍可从别的航线绕道而行；再如，若将大规模集成电路的关键线路设计成重连通的话，则在某些元件失效的情况下，整个片子的功能不受影响，反之，在战争中，若要摧毁敌方的运输线，仅需破坏其运输网中的关节点即可。    
    例如，图7．．19中图G5是连通图，但不是重连通图。图中有四个关节点A、B、D和G。若删去顶点B以及所有依附顶点B的边，G5就被分割成三个连通分量{A、c、F、L、JⅥ、J}、{G、H、J、K}和{D、E}。类似地，若删去顶点A或D或G以及所有依附于它们的边，则G，被分割成两个连通分量，由此，关节点亦称割点。利用深度优先搜索便可求得图的关节点，并由此可判别图是否是重连通的。
    图7．20所示为从顶点A出发深度优先搜索遍历图G5所得深度优先生成树，图中实线表示树边，虚线表示回边(即不在生成树上的边)。对树中任一顶点u而言，其孩子结点为在它之后搜索到的邻接点，而其双亲结点和由回边联结的祖先结点是在它之前搜索到的邻接点。由深度优先生成树可得出两类关节点的特性：
图7．20  (；；的深度
    优先生成树
    (1)若生成树的根有两棵或两棵以上的子树，则此根顶点必为关节点。因为图中不存在联结不同子树中顶点的边，因此，若删去根顶点，生成树便变成生成森林。如图7．20中的顶点A。
    (2)若生成树中某个非叶子顶点”，其某棵子树的根和子树中的其它结点均没有指向n的祖先的回边，则u为关节点。因为，若删去”，则其子树和图的其它部分被分割开来。如图7．20中的顶点B、D和G。
    若对图(；raph：(V、；Edge})重新定义遍历时的访问函数visited，并引入一个新的函数low，则由一次深度优先搜索遍历便可求得连通图中存在的所有关节点。
    定义vted[v]为深度优先搜索遍历连通图时访问顶点勘的次序号；定义    f    j w是顶点v在深度优先生成树上的孩子结点；在深度优先生成树上由回边联结的祖先结点；若对于某个顶点u，存在孩子结点low[w]≥visited[v]，则该顶点u必为关节点。因为当Ⅲ是a的孩子结点时，low[w]≥visited[v]，表明”及其子孙均无指向T的祖先的回边。
    由定义可知，visited[v]值即为副在深度优先生成树的前序序列中的序号，只需将DFS函数中头两个语句改为visited[v0]=++count(在DFSTraverlSe中设初值count：1)即可；low[v]可由后序遍历深度优先生成树求得，而秒在后序序列中的次序和遍历时退出DFS函数的次序相同，由此修改深度优先搜索遍历的算法便可得到求关节点的算法(见算法7．10和算法7．)。
void Fi】71dArticul(A【／3raph G){
  ∥连通图G以邻接表作存储结构，查找并输出G上全部关节点。全局量count
    对访问计数。
  count=I；  visited[O]=I；    ∥设定邻接表上0号顶点为生成树的根
  for(i=i；  i<G．vexn；+十i)visited[i]=0；∥其余顶点尚未访问
  P=G．vertices[O]．firstarc；  v=P->adjvex；
  DFSArticui(G，v)；    ∥从第v顶点出发深度优先查找关节点。
  if(count<G．vex~um){    ∥生成树的根有至少两棵子树
    printf(0，G．vertices[O]．data)；  ∥根是关节点。输出
    while(P->nextarc){
    p=P->nextarc；  V=P->adjvex；
    if(visited[v]==0)DFSArticul(g，v)；
    }∥while
  }∥if
＼#{FindArticul
    算法7．10
void DFSArticul(ALGraph G，int V0){
  ∥从第v10个顶点出发深度优先遍历图G，查找并输出关节点。
  visited[v0]=min=++count；  ∥vO是第count个访问的顶点
  for(P=G．vertices[v0]．firstarc；p；P=P->nextarc){  ∥对v0的每个邻接顶点检查
    W=P->adjvex；    ∥W为Vo的邻接顶点
    if(visited[w]==0){    ∥W未曾访问，是vo的孩子
    DFSArticul(G，W)；    ∥返回前求得low[．]
    if(10w[w]<min)min=low[w]；
    if(10w[w]>=visited[M)])pr／ntf(vO，G．vertices[vO]．data)；∥关节点
    Ielse if(visited[w]<min)  min=visited[w]；
    ∥W已访问，W是Vo在生成树上的祖先
    low[]=rain；
f／／DFSArticul
    算法7．11
例如，图G5中各顶点计算所得visited和low的函数值如下所列：其中J是第一个求得low值的顶点，由于存在回边(，，L)，则low[J]=Min{visited[J]、vis．ited[L]}=2。顺便提一句，上述算法中将指向双亲的树边也看成是回边，由于不影响关节点的判别，因此，为使算法简明起见，在算法中没有区别之。    
    由于上述算法的过程就是一个遍历的过程，因此，求关节点的时间复杂度仍为0(，z+e)。若尚需输出双连通分量，仅需在算法中增加一些语句即可，在此不再详述，留给读者自己完成。
7．5有向无环图及其应用
一个无环的有向图称做有向无环图(directed acycline graph)，简称DAG图。DAG图是一类较有向树更一般的特殊有向图，如图7．21列示了有向树、DAG图和有向图的例子。
    有向无环图是描述含有公共子式的表达式的有效工具。例如下述表达式    ((a十b)*(b*(c+d))十(c+d)*e)*((c+d)*e)图7．21有向树、DAG图和有向图一例
可以用第6章讨论的二叉树来表示，如图7．22所示。仔细观察该表达式，可发现有一些相同的子表达式，如(c+d)和(c+d)*e等，在二叉树中，它们也重复出现。若利用有向无图7．22用二叉树描述表达式环图，则可实现对相同子式的共享，从而节省存储空间。
   图7．23描述表达式的有向无环图
例如图7．23所示为表示同一表达式的有向无环图。
　　检查一个有向图是否存在环要比无向图复杂。对于无向图来说，若深度优先遍历过程中遇到回边(即指向已访问过的顶点的边)，则必定存在环；而对于有向图来说，这条回边有可能是指向深度优先生成森林中另一棵生成树上顶点的弧。但是，如果从有向图上某个顶点a出发的遍历，在dfs(v)结束之前出现一条从顶点“到顶点。的回边(如图7．24所示)，由于tt在生成树上是。的子孙，则有向图中必定存在包含顶点。
　　有向无环图也是描述一项工程或系统的进行过程的有效工具。除最简单的情况之外，几乎所有的工程(pro．图7．24含有环的有向图    的深度优先生成树ject：)都可分为若干个称作活动(activity)的子工程，而这些子工程之间，通常受着一定条件的约束，如其中某些子工程的开始必须在另一些子工程完成之后。对整个工程和系统，人们关心的是两个方面的问题：一是工程能否顺利进行；二是估算整个工程完成所必须的最短时间，对应于有向图，即为进行拓扑排序和关键路径的操作。下面分别就这两个问题讨论之。
  7．5．1拓扑排序
  什么是拓扑排序(Topological Sort)?简单地说，由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为拓扑排序。回顾离散数学中关于偏序和全序的定义：
    若集合X上的关系R是自反的、反对称的和传递的，则称R是集合x上的偏序关系。
　　设R是集合X上的偏序(Pat・tial()rder)，如果对每个z，y∈X必有zR了或y／Cz‘。称R是集合x上的全序关系。
　　直观地看，偏序指集合中仅有部分成员之间可比较，而全序指集合中全体成员之间均可比较。例如，图7．25所示的两个有向图，图中弧(T，y)表示z≤了，则(a)表示偏序，(b)(a)    (b)图7．25表示偏序和全序的有向图    (a)表示偏序；(b)表示全序。
表示全序。若在(a)的有向图上人为地加一个表示训2≤口。的弧(符号“≤”表示口：领先于”，)，则(a)表示的亦为全序，且这个全序称为拓扑有序(Topological()rder)，而由偏序定义得到拓扑有序的操作便是拓扑排序。
    一个表示偏序的有向图可用来表示一个流程图。它或者是一个施工流程图，或者是一个产品生产的流程图，再或是一个数据流图(每个顶点表示一个过程)。图中每一条有向边表示两个子工程之间的次序关系(领先关系)。
    例如，一个软件专业的学生必须学习一系列基本课程(如图7．26所示)，其中有些课程是基础课，它独立于其它课程，如《高等数学》；而另一些课程必须在学完作为它的基础的先修课程才能开始。如，在《程序设计基础》和《离散数学》学完之前就不能开始学习<数据结构》。这些先决条件定义了课程之间的领先(优先)关系。这个关系可以用有向图更清楚地表示，如图7．27所示。图中顶点表示课程，有向边(弧)表示先决条件。若课程i是课程j的先决条件，则图中有弧(j，i)。
    这种用顶点表示活动，用弧表示活动间的优先关系的有向图称为顶点表示活动的网(Activity On Vertex Network)，简称AOV一网。在网中，若从顶点i到顶点j有一条有向路径，则i是j的前驱；J是i的后继。若(i，J)是网中一条弧，则i是J的直接前驱；j是i的直接后继。
图7．26软件专业的学生必须学习的课程    
    在AOV．网中，不应该出现有向环，因为存在环意味着某项活动应以自己为先决条件。显然，这是荒谬的。若设计出这样的流程图，工程便无法进行。而对程序的数据流图来说，则表明存在一个死循环。因此，对给定的AOV．网应首先判定网中是否存在环。检测的办法是对有向图构造其顶点的拓扑有序序列，若网中所有顶点都在它的拓扑有序序列中，则该．AOV一网中必定不存在环。例如，图7．27的有向图有如下两个拓扑有序序列：图7．27表示课程之间优先关系的有向图    (Cl，C2，C3，C4，C5，C7，C9，Clo，C11，C6，C12，C8)和    (C9，Clo，C11，C6，Cl，C12，C4，C2，C3，C5，C7，C8)(当然，对此图也可构造得其它的拓扑有序序列)。若某个学生每学期只学一门课程的话，则他必须按拓扑有序的顺序来安排学习计划。
    如何进行拓扑排序?解决的方法很简单：
    (1)在有向图中选一个没有前驱的顶点且输出之。
    (2)从图中删除该顶点和所有以它为尾的弧。
    重复上述两步，直至全部顶点均已输出，或者当前图中不存在无前驱的顶点为止。后一种情况则说明有向图中存在环。
    以图7．28(a)中的有向图为例，图中，ul和可6没有前驱，则可任选一个。假设先输出a6，在删除a6及弧(a6，a4)，(a6，V5)之后，只有顶点a1没有前驱，则输出a1且删去ul及弧(u，，v2>、(a。，v3>和(u1，734)，之后u3和可。都没有前驱。依次类推，可从中任选一个继续进行。整个拓扑排序的过程如图7．28所示。最后得到该有向图的拓扑有序序列为
图7．28 AOV一网及其拓扑有序序列产生的过程
  (a)AOV一网；(b)输出"6之后；(c)输出口1之后；
(d)输出”。之后；(e)输出。3之后；(f)输出口2之后。
    如何在计算机中实现?针对上述两步操作，我们可采用邻接表作有向图的存储结构，且在头结点中增加一个存放顶点入度的数组(indegree)。入度为零的顶点即为没有前驱的顶点，删除顶点及以它为尾的弧的操作，则可换以弧头顶点的入度减1来实现。
    为了避免重复检测入度为零的顶点，可另设一栈暂存所有入度为零的顶点，由此可得拓扑排序的算法如算法7．12所示。
Status TopologicalSort(ALGraph G)I
  ∥有向图G采用邻接表存储结构。
  ∥若G无回路，则输出G的顶点的一个拓扑序列并返回0K，否则ERROR。
  FindInDegree(G，indegree)；    ∥对各顶点求入度indegree[0．．vernum-1]
  InitStack(S)；
  for(i=0；i<G．vexnum；++i)    ／／建零入度顶点栈S
    if(!indegree[i])Push(S，i)；    ∥入度为0者进栈
  count=0；    ∥对输出顶点计数
  while(!StackEmpty(S))I
    Pop(S，i)；printf(i，G．vertices[i]．data)；  ++count；∥输出i号顶点并计数
    ~or(P=G．vertices[i]．firstarc；p；P=P->nextarc){
    k=P->adjvex；    ∥对i号顶点的每个邻接点的入度减1
    if(!(--indegree[k]))Push(S，k)；／／若入度减为0，则入栈
    }／／for
  ＼“while
  if(count<G．vexnum)return ERROR；    ／／该有向图有回路
  else return OK；
＼}{TopologicalSort
    算法7．12
    分析算法7．12，对有九个顶点和e条弧的有向图而言，建立求各顶点的入度的时间复杂度为O(e)；建零入度顶点栈的时间复杂度为O(n)；在拓扑排序过程中，若有向图无环，则每个顶点进一次栈，出一次栈，入度减1的操作在WHILE语句中总共执行e次，所以，总的时间复杂度为0(”+s)。上述拓扑排序的算法亦是下节讨论的求关键路径的基础。
    当有向图中无环时，也可利用深度优先遍历进行拓扑排序，因为图中无环，则由图中某点出发进行深度优先搜索遍历时，最先退出【)FS函数的顶点即出度为零的顶点，是拓扑有序序列中最后一个顶点。由此，按退出DFs函数的先后记录下来的顶点序列(如同求强连通分量时finished数组中的顶点序列)即为逆向的拓扑有序序列。
7．5．2关键路径
　　与Aov一网相对应的是AOE一网(Activity On’Edge)即边表示活动的网。AOE一网是一个带权的有向无环图，其中，顶点表示事件(Event)，弧表示活动，权表示活动持续的时间。通常，AOE．网可用来估算工程的完成时间。
　　例如，图7．29是一个假想的有11项活动的AOE一网。其中有9个事件可l，a2，u3，…，u9，每个事件表示在它之前的活动已经完成，在它之后的活动可以开始。如a，表示整个工程开始，a，表示整个工程结束，a5表示和5已经完成，，和a。可以开始。与每个活动相联系的数是执行该活动所需的时间。比如，活动a，需要6天，a2需要4天等。
图7．29一个AoE网
    由于整个工程只有一个开始点和一个完成点，故在正常的情况(无环)下，网中只有一个入度为零的点(称作源点)和一个出度为零的点(叫做汇点)。
    和AOV一网不同，对AOE．网有待研究的问题是：(1)完成整项工程至少需要多少时间?(2)哪些活动是影响工程进度的关键?
    由于在AOE一网中有些活动可以并行地进行，所以完成工程的最短时间是从开始点到完成点的最长路径的长度(这里所说的路径长度是指路径上各活动持续时间之和，不是路径上弧的数目)。路径长度最长的路径叫做关键路径(Critical Path)。假设开始点是"。，从”。到口i的最长路径长度叫做事件口i的最早发生时间。这个时间决定了所有以u，为尾的弧所表示的活动的最早开始时间。我们用e(i)表示活动口i的最早开始时间。还可以定义一个活动的最迟开始时间z(i)，这是在不推迟整个工程完成的前提下，活动n，最迟必须开始进行的时间。两者之差￡(i)一e(i)意味着完成活动ai的时间余量。我们把z(i)=e(i)的活动叫做关键活动。显然，关键路径上的所有活动都是关键活动，因此提前完成非关键活动并不能加快工程的进度。例如图7．29中的网，从u，到a。的最长路径是(a1，a2，a5，a8，u9)，路径长度是18，即口9的最早发生时间是18。而活动n6的最早开始时间是5，最迟开始时间是8，这意味着：如果n。推迟3天开始或者延迟3天完成，都不会影响整个工程的完成。因此，分析关键路径的目的是辨别哪些是关键活动，以便争取提高关键活动的工效，缩短整个工期。
    由上分析可知，辨别关键活动就是要找e(i)=z(1)的活动。为了求得AOE+网中活动的e(i)和z(i)，首先应求得事件的最早发生时间伽(j)和最迟发生时间讲(歹)。如果活动a；由弧(J，)表示，其持续时间记为d．t((a，b))，则有如下关系
 (7―1)
    Z(i)=(”dut((J，))
    求w(J)和“()需分两步进行：
    (1)从W(0)=0开始向前递推(j)=Max{(i)+dut((i，j))I    (7・2)
    (i，J)∈T，  j：1，2，…，n-1
其中，T是所有以第J=个顶点为头的弧的集合。
    (2)从z(～1)=(n-1)起向后递推
    uz(i)=Min{"z(j)dut((i，j))}    (7―3)
    J
    (i，』)∈S，  i：n一2，…，O
其中，s是所有以第i个顶点为尾的弧的集合。
    这两个递推公式的计算必须分别在拓扑有序和逆拓扑有序的前提下进行。也就是说，化(j-1)必须在f的所有前驱的最早发生时间求得之后才能确定，而"z(J-1)则必须在vj的所有后继的最迟发生时间求得之后才能确定。因此，可以在拓扑排序的基础上计算(1)和z(．1)。
    由此得到如下所述求关键路径的算法：
    (1)输入P条弧(J，)，建立．AOE一网的存储结构；
    (2)从源点a。出发，令[0]=0，按拓扑有序求其余各顶点的最早发生时间i](1≤i≤n―1)。如果得到的拓扑有序序列中顶点个数小于网中顶点数n，则说明网中存在环，不能求关键路径，算法终止；否则执行步骤(3)。
    (3)从汇点u。出发，令[-1]：w[”-1]，按逆拓扑有序求其余各顶点的最迟发生时间“[i](2≥i≥2)；
　　(4)根据各顶点的ve和vl值，求每条弧s的最早开始时间e(s)和最迟开始时间l(s)。若某条弧满足条件e(s)=z(s)，则为关键活动。
　　如上所述，计算各顶点的ve值是在拓扑排序的过程中进行的，需对拓扑排序的算法作如下修改：(a)在拓扑排序之前设初值，令[i]=0(0≤i≤-1)；(b)在算法中增加一个计算aj的直接后继m的最早发生时间的操作：若[j]+dut((j，))>[]，则[]=[J]+dut((J，))；(c)为了能按逆拓扑有序序列的顺序计算各顶点的引值，需记下在拓扑排序的过程中求得的拓扑有序序列，这需要在拓扑排序算法中，增设一个栈以记录拓扑有序序列，则在计算求得各顶点的伽值之后，从栈顶至栈底便为逆拓扑有序序列。
    先将算法7．12改写成算法7．13，则算法7．14便为求关键路径的算法。S~atun TopologicalOrder(ALGraph G，Stack＆T){    ∥有向网G采用邻接表存储结构，求各顶点事件的最早发生时间re(全局变量)。
    ∥T为拓扑序列顶点栈，s为零入度顶点栈。
∥若G无回路，则用栈T返回G的一个拓扑序列，且函数值为0K，否则为ERROR。
FindInDegree(G，indegree)；∥对各顶点求入度indegree[0．．vernum-1]
建零入度顶点栈S．
InitStack(T)；count=0；ve[0．．G．vexnl／m―i]：0；  ∥初始化
while(!StackEmpty(s)){
  Pop(S，J)；Push(T，J)；  ++count；    ∥J号顶点入T栈并计数
  for(P=G．vertices[J J．firstarc；P；P=P->nextarc)l
    k=P->adjvex；    ∥对J号顶点的每个邻接点的入度减l
    if(--indegree[k]==0)Push(S。k)；∥若入度减为0，则入栈
    if(ve[J]+*(P->info)>ve[k])ve[k]=ve[J]+*(P->info)；
    }∥for  *(p->info)：dut(<J，k>)
  ＼{}while
  if(count<G．vexnum)return ERROR；／／该有向网有回路
  el∞return OK：
}}TopologicalOrder
    算法7．13
Status CriticalPath((ALGraph G)f
  ∥G为有向网，输出G的各项关键活动。
  if(!TopologicalOrder(G，T))  return ERROR；
  vl[O．．G．vexn~l-1]=ve[O．．G．vexnLlm-1]；    ∥初始化顶点事件的最迟发生时间
  while(!StackEmpty(T))    ∥按拓扑逆序求各顶点的vl值
  for(Pop(T，j)。P=G．vertices[j]．firstarc；p；P=P->nextarc)I
    k=P->adjvex；dut=*(p->info)；    ∥dut<j，k>
    if(vl[k]～dut<vl[j])vl[J]=vi[k]．dut；
    、}，for
  for(J=0；j<G．vexnum；++J)    ∥求ee，el和关键活动
    for(P=G．vertices[j]；p；P=P->nextarc){
    k=P->adjvex；dut=*(p->info)；
    ee=ve【J J；el=vi[k]一dut；
    tag。(ee=。e1)?’*’：～：
    printf(j，k，dut，ee，el，tag)；  ∥输出关键活动
    }
＼#}CriticalPath
    算法7．14
    由于逆拓扑排序必定在网中无环的前提下进行，则亦可利用DFS函数，在退出DFS函数之前按式(7―3)计算顶点a的vl值(因为此时可的所有直接后继的az值都已求出)。
图7．30 AOE-网及其关键路径
  (a)AOE．网；(b)关键路径。
    这两种算法的时间复杂度均为0(”+e)，显然，前一种算法的常数因子要小些。由于计算弧的活动最早开始时间和最迟开始时间的复杂度为0(e)，所以总的求关键路径的时间复杂度为O(n+e)。
    例如，对图7．30(a)所示网的计算结果如图7．31所示，可见n2、口5和n7为关键活动，组成一条从源点到汇点的关键路径，如图7．30(b)所示。
    图7．31  图7．30(a)所示AOE一网中顶点的发生时间和活动的开始时间对于图7．29所示的网，可计算求得关键活动为1，n。，7，8，lo和n11。如图7．32所示，它们构成两条关键路径：(1，u2，5，7，u9)和(l，"2，5，8，9)。
    实践已经证明：用AOE-网来估算某些工程完成的时间是非常有用的。实际上，求关键路径的方法本身最初就是与维修和建造工程一起发展的。但是，由于网中各项活动是互相牵涉的，因此，影响关键活动的因素亦是多方面的，任何一项活动持续时间的改变都会影响关键路径的改变。例如，对于图7．30(a)所示的网来说，若口，的持续时间改为3，则可发现，关键活动数量增加，关键路径也增加。若同时将a。的时间 图7・。。图7・。9所示网的关键路径  改成4，则(1，3，u4，6)不再是关键路径。由此可见，关键活动的速度提高是有限度的。只有在不改变网的关键路径的情况下，提高关键活动的速度才有效。
　　另一方面，若网中有几条关键路径，那么，单是提高一条关键路径上的关键活动的速度，还不能导致整个工程缩短工期，而必须提高同时在几条关键路径上的活动的速度。7．6最短路径
假若要在计算机上建立一个交通咨询系统则可以采用图的结构来表示实际的交通网络。如图7．33所示，图中顶点表示城市，边表示城市间的交通联系。这个咨询系统可以回答。旅客提出的各种问题。例如，一位旅客要从A城到B城，他希望选择一条途中中转次数最少的路线。假设图中每一站都需要换车，则这个问题反映到图上就是要找一条从顶点A到B所含边的数目最少的路径。我们只须从顶点A出发对图作广度优先搜索，一旦遇到顶点B就终止。由此所得广度优先生成树上，从根顶点A到顶点B的路径就是中转次数最少的路径，路径上A与B之间的顶点就是途径的中转站数，但是，这只是一类最简单的图的最短路径问题。有时，对于旅客来说，可能更关心的是节省交通费用；而对于司机来说，里程和速度则是他们感兴趣的信息。为了在图上表示有关信息，可对边赋以权，权的值表示两城市间的距离，或途中所需时间，或交通费用等等。此时路径长度的度量就不再是路径上边的数目，而是路径上边的权值之和。考虑到交通图的有向性(如航运，逆水和顺水时的船速就不一样)，本节将讨论带权有向图，并称路径上的第一个顶点为源点(Sourse)，最后一个顶点为终点(【)estination)。下面讨论两种最常见的最短路径问题。
7．6．1 从某个源点到其余各顶点的最短路径
    我们先来讨论单源点的最短路径问题：给定带权有向图G和源点。，求从”到G中其余各顶点的最短路径。例如，图7．34所示带权有向图G6中从口0到其余各顶点之间的最短路径，如图7．35图7．34带权有向图G6    图7．35有向图G6中从v0到其余各点的最短路径所示。从图中可见，从v0到v3有两条不同的路径：(v0，v2，v3)和(v0，v4，v3)，前者长度为60，而后者的长度为50。因此，后者是从v0到v3的最短路径；而从v0到v1没有路径。
    如何求得这些路径?迪杰斯特拉(D西kst-ra)提出了一个按路径长度递增的次序产生最短路径的算法。
    首先，引进一个辅助向量D，它的每个分量D[i]表示当前所找到的从始点u到每个终点让的最短路径的长度。它的初态为：若从口到矾有弧，则D[i]为弧上的权值；否则置D[i]为o。。显然，长度为    D[J]=Min{D[i]l∈V}的路径就是从u出发的长度最短的一条最短路径。此路径为(，)。
    那么，下一条长度次短的最短路径是哪一条呢?假设该次短路径的终点是％，则可想而知，这条路径或者是(”，b)，或者是(”，ui，u)。它的长度或者是从v到b的弧上的权值，或者是D[J]和从q到b的弧上的权值之和。
    一般情况下，假设s为已求得最短路径的终点的集合，则可证明：下一条最短路径(设其终点为z)或者是弧(，z)，或者是中间只经过s中的顶点而最后到达顶点．z的路径。这可用反证法来证明。假设此路径上有一个顶点不在5中，则说明存在一条终点不在S而长度比此路径短的路径。但是，这是不可能的。因为我们是按路径长度递增的次序来产生各最短路径的，故长度比此路径短的所有路径均已产生，它们的终点必定在S中，即假设不成立。
    因此，在一般情况下，下一条长度次短的最短路径的长度必是    D[歹]=Min{D[i]l q∈V―S}其中，D[i]或者是弧(，i)上的权值，或者是D[]({∈S)和弧(，i)上的权值之和。
    根据以上分析，可以得到如下描述的算法：
    (1)假设用带权的邻接矩阵nrcs来表示带权有向图，nrcs[i][j]表示弧(q，％)上的权值。若(ui，uf)不存在，则置rcs[i][J]为∞(在计算机上可用允许的最大值代替)。s为已找到从u出发的最短路径的终点的集合，它的初始状态为空集。那么，从a出发到图上其余各顶点(终点)a可能达到的最短路径长度的初值为：
    D[i]=rcs[L．ocate Vex(G，)[i]  ui∈v
    (2)选择ui，使得
    D[』]=Min{D[i]『∈V-S}
i就是当前求得的一条从a出发的最短路径的终点。令 S：S U{．j}
    (3)修改从a出发到集合V-S上任一顶点％可达的最短路径长度。如果 D[]+d[j][]<D[]
则修改D[]为 D[]=D[]+arc5[．f][]
    (4)重复操作(2)、(3)共以-1次。由此求得从a到图上其余各顶点的最短路径是依路径长度递增的序列。
    算法7．15为用C语言描述的迪杰斯特拉算法。
    VOi4 ShortestPath．DIJ(MGraph G，int、ro，PathMatrix&P，ShortPathTable＆D){
    ∥用Dijkstra算法求有向网G的、r0顶点到其余顶点v的最短路径P[v]及其带权长度D[v]。
    ∥若P[v][w]为TR【IE，则W是从、，0到v当前求得最短路径上的顶点。
    ∥final[v]为TRUE当且仅当v∈S，即已经求得从、r0到v的最短路径。
    for(v=0；v<G．vexxlum；++v){
    final[v]：FALSE；D[v]=G．arcs[、，0][v]；
    for(W=0；w<G．vexnum；++W)P[v][W]=FALSE；  ∥设空路径
    if(D[v]<INFINITY){P[v][vO]=TRUE；P[v][v]=TRUE；}
    }／／for
    D[、ro]=0；final[vO]=TRUE；    ∥初始化，v0顶点属于S集
    ∥开始主循环，每次求得V0到某个v顶点的最短路径，并加v到S集
    for(i=I；i<G．vexnum；++i){    ∥其余G．vex~um-1个顶点
    min=INFINITY；    ／i'当前所知离、，o顶点的最近距离
    for w。0；w<G．vexntlm；++W)
    if(!final[w])    ∥W顶点在V-S中
    if(D[w]<min){v=w；min=D[w]；}    ∥W顶点离、，0顶点更近
    final[v]=TRUE；    ∥离vo顶点最近的v加入S集
    for(W=0；w<G．vexnum；++w)  ∥更新当前最短路径及距离
    if(!final[w]＆＆(min+G．arcs[v][W]<D[w]))l∥修改D[w]和P[w]，w6V―S
    D[w]=min+G．arcs[v][W]；
    P[w]=P[v]；P[w][W]=TRUE；∥P[w]=e[v]+[W]
    I∥if
    }∥for
    I∥ShortestPath―DIJ
    算法7．15    ’    、
例如，图7．34所示有向网G6的带权邻接矩阵为：
    若对G6施行迪杰斯特拉算法，则所得从v0到其余各顶点的最短路径，以及运算过程中D向量的变化状况，如下所示：
从vn到各终点的D值和最短路径的求解过程 
    我们分析这个算法的运行时间。第一个FOR循环的时间复杂度是O()，第二个FOR循环共进行以-1次，每次执行的时间是0(”)。所以总的时间复杂度是0(，z0)。如果用带权的邻接表作为有向图的存储结构，则虽然修改D的时间可以减少，但由于在D向量中选择最小分量的时间不变，所以总的时间仍为0(n0)。
    人们可能只希望找到从源点到某一个特定的终点的最短路径，但是，这个问题和求源点到其它所有顶点的最短路径一样复杂，其时间复杂度也是0(”0)的。
7．6．2每一对顶点之间的最短路径
    解决这个问题的一个办法是：每次以一个顶点为源点，重复执行迪杰斯特拉算法n次。这样，便可求得每一对顶点之间的最短路径。总的执行时间为O(n。)。
　　这里要介绍由弗洛伊德(f?loyd)提出的另一个算法。这个算法的时间复杂度也是0(n。)，但形式上简单些。
　　弗洛伊德算法仍从图的带权邻接矩阵cost出发，其基本思想是：
    假设求从顶点q到v，的最短路径。如果从。i到uf有弧，则从让到矾存在一条长度为n懈[i][j]的路径，该路径不一定是最短路径，尚需进行他次试探。首先考虑路径(u：，uo，q)是否存在(即判别弧(”i，可o)和(。，f)是否存在)。如果存在，则比较(i，，)和(让，u0，)的路径长度取长度较短者为从q到，的中间顶点的序号不大于0的最短路径。假如在路径上再增加一个顶点可1，也就是说，如果(∥，。)和(”∥”，。i)分别是当前找到的中间顶点的序号不大于0的最短路径，那么(∥--，∥，；)就有可能是从i到q的中间顶点的序号不大于1的最短路径。将它和已经得到的从ui到。，中间顶点序号不大于0的最短路径相比较，从中选出中间顶点的序号不大于1的最短路径之后，再增加一个顶点2，继续进行试探。依次类推。在一般情况下，若(∥，。)和(…，)分别是从”i到Tt和从n到q的中间顶点的序号不大于m-1的最短路径，则将(u∥，”^，…，q)和已经得到的从ui到g且中间顶点序号不大于是-1的最短路径相比较，≥￡长度较短者便是从q到q的中间顶点的序号不大k的最短路径a这样，在经过n次比较后．接后求得的必是从vi到vj的最短路径。按此方法，可以同时求得各对顶点间的最短路径。
  现定义一个”阶方阵序列。
其中
    D。。。’[i][i]=(；aⅢ[j]
    从上述计算公式可见，D[i][J]是从v，到v．的中间顶点的序号不大干l的最短路径的长度；”[J]是从v到Ⅵ的中间顶点的序号不大于k的最短路径的K／~；D””[1]【j]就是从u到v．的最短路径的长度
    由此可得算法7 16。
    vnid ShortestPath F【DYD(MGraph G+PathM~tr／x＆P(]Dist~cMetrlx＆D){
　　∥用floyd算法求有向网G中各对顶点v和w之间的最短路径P[v][wJ及其
　　∥带权长度DIv]fw]。若P[v][w][u]为TRUE，则u是从v到w当前求得最短路径l的顶点。
    f∞(v=0：v<G…_|v)    ／／各对结点之间初始已知路径及距离
    f(w：”：w<G…：}w){
    Ⅱv][w]=G…[v]【w1；
    for(u=0 u<G…．{十u)P【v][Ⅵ][uj=FhtSE；
    (D[v1【w]<IrrT){  ∥从v到“有直接路径
    v1(w][v1=TP(v][w]h]=T；
    l∥
    l∥for
    forf…0 u<G v。：。“u)
    farf…0 v<G…m；11 v)
  for fwIO：w<G…LI】n．}+w)
    if(D[v][u¨Dfu][w]<D[v][w])
    D_v][w]=D[v][u]+D[u][w]；
    forfi=O：1<G…；}+1)
    v][w][，]：P[v]【u][-]Il
    l∥1f
?I ShortestPath。FLOYD
∥从v经u到w的一条路径更短
P[u][w][i
算法7 16
  图7 36带根有向图
；I)#向网G．．(5)邻接矩阵
  例如，利用上述算法，可求得图7．36所示带权有向图G，的每一对顶点之间的最短路径及其路径长度如图7．37所示。

图7．37图7．36中有向图的各对顶点间的最短路径及其路径长度